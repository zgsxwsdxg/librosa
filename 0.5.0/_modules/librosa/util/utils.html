

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>librosa.util.utils &mdash; librosa 0.5.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../_static/banner.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="librosa 0.5.0 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> librosa
          

          
          </a>

          
            
            
              <div class="version">
                0.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core.html">Core IO and DSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../display.html">Display</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../feature.html">Feature extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../onset.html">Onset detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../beat.html">Beat and tempo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../decompose.html">Spectrogram decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../effects.html">Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../output.html">Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../segment.html">Temporal segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../util.html">Utilities</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../filters.html">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cache.html">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ioformats.html">Advanced I/O Use Cases</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">librosa</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>librosa.util.utils</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for librosa.util.utils</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Utility functions&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">scipy.ndimage</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span>
<span class="kn">import</span> <span class="nn">six</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.lib.stride_tricks</span> <span class="k">import</span> <span class="n">as_strided</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="k">import</span> <span class="n">ParameterError</span>

<span class="c1"># Constrain STFT block sizes to 256 KB</span>
<span class="n">MAX_MEM_BLOCK</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="mi">10</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;MAX_MEM_BLOCK&#39;</span><span class="p">,</span>
           <span class="s1">&#39;frame&#39;</span><span class="p">,</span> <span class="s1">&#39;pad_center&#39;</span><span class="p">,</span> <span class="s1">&#39;fix_length&#39;</span><span class="p">,</span>
           <span class="s1">&#39;valid_audio&#39;</span><span class="p">,</span> <span class="s1">&#39;valid_int&#39;</span><span class="p">,</span> <span class="s1">&#39;valid_intervals&#39;</span><span class="p">,</span>
           <span class="s1">&#39;fix_frames&#39;</span><span class="p">,</span>
           <span class="s1">&#39;axis_sort&#39;</span><span class="p">,</span> <span class="s1">&#39;localmax&#39;</span><span class="p">,</span> <span class="s1">&#39;normalize&#39;</span><span class="p">,</span>
           <span class="s1">&#39;match_intervals&#39;</span><span class="p">,</span> <span class="s1">&#39;match_events&#39;</span><span class="p">,</span>
           <span class="s1">&#39;peak_pick&#39;</span><span class="p">,</span>
           <span class="s1">&#39;sparsify_rows&#39;</span><span class="p">,</span>
           <span class="s1">&#39;roll_sparse&#39;</span><span class="p">,</span>
           <span class="s1">&#39;index_to_slice&#39;</span><span class="p">,</span>
           <span class="s1">&#39;sync&#39;</span><span class="p">,</span>
           <span class="s1">&#39;softmask&#39;</span><span class="p">,</span>
           <span class="s1">&#39;buf_to_float&#39;</span><span class="p">,</span>
           <span class="s1">&#39;tiny&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="frame"><a class="viewcode-back" href="../../../generated/librosa.util.frame.html#librosa.util.frame">[docs]</a><span class="k">def</span> <span class="nf">frame</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">frame_length</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Slice a time series into overlapping frames.</span>

<span class="sd">    This implementation uses low-level stride manipulation to avoid</span>
<span class="sd">    redundant copies of the time series data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)]</span>
<span class="sd">        Time series to frame. Must be one-dimensional and contiguous</span>
<span class="sd">        in memory.</span>

<span class="sd">    frame_length : int &gt; 0 [scalar]</span>
<span class="sd">        Length of the frame in samples</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        Number of samples to hop between frames</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y_frames : np.ndarray [shape=(frame_length, N_FRAMES)]</span>
<span class="sd">        An array of frames sampled from `y`:</span>
<span class="sd">        `y_frames[i, j] == y[j * hop_length + i]`</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If `y` is not contiguous in memory, framing is invalid.</span>
<span class="sd">        See `np.ascontiguous()` for details.</span>

<span class="sd">        If `hop_length &lt; 1`, frames cannot advance.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Extract 2048-sample frames from `y` with a hop of 64 samples per frame</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.frame(y, frame_length=2048, hop_length=64)</span>
<span class="sd">    array([[ -9.216e-06,   7.710e-06, ...,  -2.117e-06,  -4.362e-07],</span>
<span class="sd">           [  2.518e-06,  -6.294e-06, ...,  -1.775e-05,  -6.365e-06],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ -7.429e-04,   5.173e-03, ...,   1.105e-05,  -5.074e-06],</span>
<span class="sd">           [  2.169e-03,   4.867e-03, ...,   3.666e-06,  -5.571e-06]], dtype=float32)</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">frame_length</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Buffer is too short (n=</span><span class="si">{:d}</span><span class="s1">)&#39;</span>
                             <span class="s1">&#39; for frame_length=</span><span class="si">{:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">frame_length</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">hop_length</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid hop_length: </span><span class="si">{:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hop_length</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">y</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;C_CONTIGUOUS&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Input buffer must be contiguous.&#39;</span><span class="p">)</span>

    <span class="n">valid_audio</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="c1"># Compute the number of frames that will fit. The end may get truncated.</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">frame_length</span><span class="p">)</span> <span class="o">/</span> <span class="n">hop_length</span><span class="p">)</span>

    <span class="c1"># Vertical stride is one sample</span>
    <span class="c1"># Horizontal stride is `hop_length` samples</span>
    <span class="n">y_frames</span> <span class="o">=</span> <span class="n">as_strided</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">frame_length</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">),</span>
                          <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,</span> <span class="n">hop_length</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="n">itemsize</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">y_frames</span></div>


<span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<div class="viewcode-block" id="valid_audio"><a class="viewcode-back" href="../../../generated/librosa.util.valid_audio.html#librosa.util.valid_audio">[docs]</a><span class="k">def</span> <span class="nf">valid_audio</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mono</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Validate whether a variable contains valid, mono audio data.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray</span>
<span class="sd">      The input data to validate</span>

<span class="sd">    mono : bool</span>
<span class="sd">      Whether or not to force monophonic audio</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    valid : bool</span>
<span class="sd">        True if all tests pass</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If `y` fails to meet the following criteria:</span>
<span class="sd">            - `type(y)` is `np.ndarray`</span>
<span class="sd">            - `mono == True` and `y.ndim` is not 1</span>
<span class="sd">            - `mono == False` and `y.ndim` is not 1 or 2</span>
<span class="sd">            - `np.isfinite(y).all()` is not True</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 20.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Only allow monophonic signals</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.valid_audio(y)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; # If we want to allow stereo signals</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(), mono=False)</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.valid_audio(y, mono=False)</span>
<span class="sd">    True</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;data must be of type numpy.ndarray&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mono</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid shape for monophonic audio: &#39;</span>
                             <span class="s1">&#39;ndim=</span><span class="si">{:d}</span><span class="s1">, shape=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid shape for audio: &#39;</span>
                             <span class="s1">&#39;ndim=</span><span class="si">{:d}</span><span class="s1">, shape=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Audio buffer is not finite everywhere&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="valid_int"><a class="viewcode-back" href="../../../generated/librosa.util.valid_int.html#librosa.util.valid_int">[docs]</a><span class="k">def</span> <span class="nf">valid_int</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">cast</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Ensure that an input value is integer-typed.</span>
<span class="sd">    This is primarily useful for ensuring integrable-valued</span>
<span class="sd">    array indices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : number</span>
<span class="sd">        A scalar value to be cast to int</span>

<span class="sd">    cast : function [optional]</span>
<span class="sd">        A function to modify `x` before casting.</span>
<span class="sd">        Default: `np.floor`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_int : int</span>
<span class="sd">        `x_int = int(cast(x))`</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If `cast` is provided and is not callable.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">cast</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cast</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">cast</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;cast parameter must be callable&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">x</span><span class="p">))</span></div>


<div class="viewcode-block" id="valid_intervals"><a class="viewcode-back" href="../../../generated/librosa.util.valid_intervals.html#librosa.util.valid_intervals">[docs]</a><span class="k">def</span> <span class="nf">valid_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Ensure that an array is a valid representation of time intervals:</span>

<span class="sd">        - intervals.ndim == 2</span>
<span class="sd">        - intervals.shape[1] == 2</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    intervals : np.ndarray [shape=(n, 2)]</span>
<span class="sd">        set of time intervals</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    valid : bool</span>
<span class="sd">        True if `intervals` passes validation.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">intervals</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;intervals must have shape (n, 2)&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="pad_center"><a class="viewcode-back" href="../../../generated/librosa.util.pad_center.html#librosa.util.pad_center">[docs]</a><span class="k">def</span> <span class="nf">pad_center</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Wrapper for np.pad to automatically center an array prior to padding.</span>
<span class="sd">    This is analogous to `str.center()`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Generate a vector</span>
<span class="sd">    &gt;&gt;&gt; data = np.ones(5)</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.pad_center(data, 10, mode=&#39;constant&#39;)</span>
<span class="sd">    array([ 0.,  0.,  1.,  1.,  1.,  1.,  1.,  0.,  0.,  0.])</span>

<span class="sd">    &gt;&gt;&gt; # Pad a matrix along its first dimension</span>
<span class="sd">    &gt;&gt;&gt; data = np.ones((3, 5))</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.pad_center(data, 7, axis=0)</span>
<span class="sd">    array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.,  1.,  1.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.]])</span>
<span class="sd">    &gt;&gt;&gt; # Or its second dimension</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.pad_center(data, 7, axis=1)</span>
<span class="sd">    array([[ 0.,  1.,  1.,  1.,  1.,  1.,  0.],</span>
<span class="sd">           [ 0.,  1.,  1.,  1.,  1.,  1.,  0.],</span>
<span class="sd">           [ 0.,  1.,  1.,  1.,  1.,  1.,  0.]])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        Vector to be padded and centered</span>

<span class="sd">    size : int &gt;= len(data) [scalar]</span>
<span class="sd">        Length to pad `data`</span>

<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to pad and center the data</span>

<span class="sd">    kwargs : additional keyword arguments</span>
<span class="sd">      arguments passed to `np.pad()`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data_padded : np.ndarray</span>
<span class="sd">        `data` centered and padded to length `size` along the</span>
<span class="sd">        specified axis</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If `size &lt; data.shape[axis]`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.pad</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="n">lpad</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">size</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">lengths</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">lengths</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lpad</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="n">lpad</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">lpad</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">((</span><span class="s1">&#39;Target size (</span><span class="si">{:d}</span><span class="s1">) must be &#39;</span>
                              <span class="s1">&#39;at least input size (</span><span class="si">{:d}</span><span class="s1">)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="fix_length"><a class="viewcode-back" href="../../../generated/librosa.util.fix_length.html#librosa.util.fix_length">[docs]</a><span class="k">def</span> <span class="nf">fix_length</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Fix the length an array `data` to exactly `size`.</span>

<span class="sd">    If `data.shape[axis] &lt; n`, pad according to the provided kwargs.</span>
<span class="sd">    By default, `data` is padded with trailing zeros.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y = np.arange(7)</span>
<span class="sd">    &gt;&gt;&gt; # Default: pad with zeros</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fix_length(y, 10)</span>
<span class="sd">    array([0, 1, 2, 3, 4, 5, 6, 0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; # Trim to a desired length</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fix_length(y, 5)</span>
<span class="sd">    array([0, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; # Use edge-padding instead of zeros</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fix_length(y, 10, mode=&#39;edge&#39;)</span>
<span class="sd">    array([0, 1, 2, 3, 4, 5, 6, 6, 6, 6])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">      array to be length-adjusted</span>

<span class="sd">    size : int &gt;= 0 [scalar]</span>
<span class="sd">      desired length of the array</span>

<span class="sd">    axis : int, &lt;= data.ndim</span>
<span class="sd">      axis along which to fix length</span>

<span class="sd">    kwargs : additional keyword arguments</span>
<span class="sd">        Parameters to `np.pad()`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data_fixed : np.ndarray [shape=data.shape]</span>
<span class="sd">        `data` either trimmed or padded to length `size`</span>
<span class="sd">        along the specified axis.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.pad</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">:</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">slices</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">:</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">lengths</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="fix_frames"><a class="viewcode-back" href="../../../generated/librosa.util.fix_frames.html#librosa.util.fix_frames">[docs]</a><span class="k">def</span> <span class="nf">fix_frames</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Fix a list of frames to lie within [x_min, x_max]</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Generate a list of frame indices</span>
<span class="sd">    &gt;&gt;&gt; frames = np.arange(0, 1000.0, 50)</span>
<span class="sd">    &gt;&gt;&gt; frames</span>
<span class="sd">    array([   0.,   50.,  100.,  150.,  200.,  250.,  300.,  350.,</span>
<span class="sd">            400.,  450.,  500.,  550.,  600.,  650.,  700.,  750.,</span>
<span class="sd">            800.,  850.,  900.,  950.])</span>
<span class="sd">    &gt;&gt;&gt; # Clip to span at most 250</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fix_frames(frames, x_max=250)</span>
<span class="sd">    array([  0,  50, 100, 150, 200, 250])</span>
<span class="sd">    &gt;&gt;&gt; # Or pad to span up to 2500</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fix_frames(frames, x_max=2500)</span>
<span class="sd">    array([   0,   50,  100,  150,  200,  250,  300,  350,  400,</span>
<span class="sd">            450,  500,  550,  600,  650,  700,  750,  800,  850,</span>
<span class="sd">            900,  950, 2500])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fix_frames(frames, x_max=2500, pad=False)</span>
<span class="sd">    array([  0,  50, 100, 150, 200, 250, 300, 350, 400, 450, 500,</span>
<span class="sd">           550, 600, 650, 700, 750, 800, 850, 900, 950])</span>

<span class="sd">    &gt;&gt;&gt; # Or starting away from zero</span>
<span class="sd">    &gt;&gt;&gt; frames = np.arange(200, 500, 33)</span>
<span class="sd">    &gt;&gt;&gt; frames</span>
<span class="sd">    array([200, 233, 266, 299, 332, 365, 398, 431, 464, 497])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fix_frames(frames)</span>
<span class="sd">    array([  0, 200, 233, 266, 299, 332, 365, 398, 431, 464, 497])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.fix_frames(frames, x_max=500)</span>
<span class="sd">    array([  0, 200, 233, 266, 299, 332, 365, 398, 431, 464, 497,</span>
<span class="sd">           500])</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frames : np.ndarray [shape=(n_frames,)]</span>
<span class="sd">        List of non-negative frame indices</span>

<span class="sd">    x_min : int &gt;= 0 or None</span>
<span class="sd">        Minimum allowed frame index</span>

<span class="sd">    x_max : int &gt;= 0 or None</span>
<span class="sd">        Maximum allowed frame index</span>

<span class="sd">    pad : boolean</span>
<span class="sd">        If `True`, then `frames` is expanded to span the full range</span>
<span class="sd">        `[x_min, x_max]`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fixed_frames : np.ndarray [shape=(n_fixed_frames,), dtype=int]</span>
<span class="sd">        Fixed frame indices, flattened and sorted</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If `frames` contains negative values</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">frames</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Negative frame index detected&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pad</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">x_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pad</span><span class="p">:</span>
        <span class="n">pad_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">x_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pad_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pad_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_max</span><span class="p">)</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">pad_data</span><span class="p">,</span> <span class="n">frames</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">x_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="n">frames</span> <span class="o">&gt;=</span> <span class="n">x_min</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">x_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="n">frames</span> <span class="o">&lt;=</span> <span class="n">x_max</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></div>


<div class="viewcode-block" id="axis_sort"><a class="viewcode-back" href="../../../generated/librosa.util.axis_sort.html#librosa.util.axis_sort">[docs]</a><span class="k">def</span> <span class="nf">axis_sort</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Sort an array along its rows or columns.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Visualize NMF output for a spectrogram S</span>

<span class="sd">    &gt;&gt;&gt; # Sort the columns of W by peak frequency bin</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; W, H = librosa.decompose.decompose(S, n_components=32)</span>
<span class="sd">    &gt;&gt;&gt; W_sort = librosa.util.axis_sort(W)</span>

<span class="sd">    Or sort by the lowest frequency bin</span>

<span class="sd">    &gt;&gt;&gt; W_sort = librosa.util.axis_sort(W, value=np.argmin)</span>

<span class="sd">    Or sort the rows instead of the columns</span>

<span class="sd">    &gt;&gt;&gt; W_sort_rows = librosa.util.axis_sort(W, axis=0)</span>

<span class="sd">    Get the sorting index also, and use it to permute the rows of H</span>

<span class="sd">    &gt;&gt;&gt; W_sort, idx = librosa.util.axis_sort(W, index=True)</span>
<span class="sd">    &gt;&gt;&gt; H_sort = H[idx, :]</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 2, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(W, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;W&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(H, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;H&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 2, 3)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(W_sort,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;W sorted&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 2, 4)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(H_sort, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;H sorted&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray [shape=(d, n)]</span>
<span class="sd">        Array to be sorted</span>

<span class="sd">    axis : int [scalar]</span>
<span class="sd">        The axis along which to compute the sorting values</span>

<span class="sd">        - `axis=0` to sort rows by peak column index</span>
<span class="sd">        - `axis=1` to sort columns by peak row index</span>

<span class="sd">    index : boolean [scalar]</span>
<span class="sd">        If true, returns the index array as well as the permuted data.</span>

<span class="sd">    value : function</span>
<span class="sd">        function to return the index corresponding to the sort order.</span>
<span class="sd">        Default: `np.argmax`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_sort : np.ndarray [shape=(d, n)]</span>
<span class="sd">        `S` with the columns or rows permuted in sorting order</span>

<span class="sd">    idx : np.ndarray (optional) [shape=(d,) or (n,)]</span>
<span class="sd">        If `index == True`, the sorting index used to permute `S`.</span>
<span class="sd">        Length of `idx` corresponds to the selected `axis`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If `S` does not have exactly 2 dimensions (`S.ndim != 2`)</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span>

    <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;axis_sort is only defined for 2D arrays&#39;</span><span class="p">)</span>

    <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">value</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">axis</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">bin_idx</span><span class="p">)</span>

    <span class="n">sort_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">S</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">sort_slice</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>

    <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span><span class="p">[</span><span class="n">sort_slice</span><span class="p">],</span> <span class="n">idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span><span class="p">[</span><span class="n">sort_slice</span><span class="p">]</span></div>


<span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<div class="viewcode-block" id="normalize"><a class="viewcode-back" href="../../../generated/librosa.util.normalize.html#librosa.util.normalize">[docs]</a><span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Normalize an array along a chosen axis.</span>

<span class="sd">    Given a norm (described below) and a target axis, the input</span>
<span class="sd">    array is scaled so that</span>

<span class="sd">        `norm(S, axis=axis) == 1`</span>

<span class="sd">    For example, `axis=0` normalizes each column of a 2-d array</span>
<span class="sd">    by aggregating over the rows (0-axis).</span>
<span class="sd">    Similarly, `axis=1` normalizes each row of a 2-d array.</span>

<span class="sd">    This function also supports thresholding small-norm slices:</span>
<span class="sd">    any slice (i.e., row or column) with norm below a specified</span>
<span class="sd">    `threshold` can be left un-normalized, set to all-zeros, or</span>
<span class="sd">    filled with uniform non-zero values that normalize to 1.</span>

<span class="sd">    Note: the semantics of this function differ from</span>
<span class="sd">    `scipy.linalg.norm` in two ways: multi-dimensional arrays</span>
<span class="sd">    are supported, but matrix-norms are not.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        The matrix to normalize</span>

<span class="sd">    norm : {np.inf, -np.inf, 0, float &gt; 0, None}</span>
<span class="sd">        - `np.inf`  : maximum absolute value</span>
<span class="sd">        - `-np.inf` : mininum absolute value</span>
<span class="sd">        - `0`    : number of non-zeros (the support)</span>
<span class="sd">        - float  : corresponding l_p norm</span>
<span class="sd">            See `scipy.linalg.norm` for details.</span>
<span class="sd">        - None : no normalization is performed</span>

<span class="sd">    axis : int [scalar]</span>
<span class="sd">        Axis along which to compute the norm.</span>

<span class="sd">    threshold : number &gt; 0 [optional]</span>
<span class="sd">        Only the columns (or rows) with norm at least `threshold` are</span>
<span class="sd">        normalized.</span>

<span class="sd">        By default, the threshold is determined from</span>
<span class="sd">        the numerical precision of `S.dtype`.</span>

<span class="sd">    fill : None or bool</span>
<span class="sd">        If None, then columns (or rows) with norm below `threshold`</span>
<span class="sd">        are left as is.</span>

<span class="sd">        If False, then columns (rows) with norm below `threshold`</span>
<span class="sd">        are set to 0.</span>

<span class="sd">        If True, then columns (rows) with norm below `threshold`</span>
<span class="sd">        are filled uniformly such that the corresponding norm is 1.</span>

<span class="sd">        .. note:: `fill=True` is incompatible with `norm=0` because</span>
<span class="sd">            no uniform vector exists with l0 &quot;norm&quot; equal to 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_norm : np.ndarray [shape=S.shape]</span>
<span class="sd">        Normalized array</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If `norm` is not among the valid types defined above</span>

<span class="sd">        If `S` is not finite</span>

<span class="sd">        If `fill=True` and `norm=0`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.linalg.norm</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 40.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Construct an example matrix</span>
<span class="sd">    &gt;&gt;&gt; S = np.vander(np.arange(-2.0, 2.0))</span>
<span class="sd">    &gt;&gt;&gt; S</span>
<span class="sd">    array([[-8.,  4., -2.,  1.],</span>
<span class="sd">           [-1.,  1., -1.,  1.],</span>
<span class="sd">           [ 0.,  0.,  0.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.,  1.]])</span>
<span class="sd">    &gt;&gt;&gt; # Max (l-infinity)-normalize the columns</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.normalize(S)</span>
<span class="sd">    array([[-1.   ,  1.   , -1.   ,  1.   ],</span>
<span class="sd">           [-0.125,  0.25 , -0.5  ,  1.   ],</span>
<span class="sd">           [ 0.   ,  0.   ,  0.   ,  1.   ],</span>
<span class="sd">           [ 0.125,  0.25 ,  0.5  ,  1.   ]])</span>
<span class="sd">    &gt;&gt;&gt; # Max (l-infinity)-normalize the rows</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.normalize(S, axis=1)</span>
<span class="sd">    array([[-1.   ,  0.5  , -0.25 ,  0.125],</span>
<span class="sd">           [-1.   ,  1.   , -1.   ,  1.   ],</span>
<span class="sd">           [ 0.   ,  0.   ,  0.   ,  1.   ],</span>
<span class="sd">           [ 1.   ,  1.   ,  1.   ,  1.   ]])</span>
<span class="sd">    &gt;&gt;&gt; # l1-normalize the columns</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.normalize(S, norm=1)</span>
<span class="sd">    array([[-0.8  ,  0.667, -0.5  ,  0.25 ],</span>
<span class="sd">           [-0.1  ,  0.167, -0.25 ,  0.25 ],</span>
<span class="sd">           [ 0.   ,  0.   ,  0.   ,  0.25 ],</span>
<span class="sd">           [ 0.1  ,  0.167,  0.25 ,  0.25 ]])</span>
<span class="sd">    &gt;&gt;&gt; # l2-normalize the columns</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.normalize(S, norm=2)</span>
<span class="sd">    array([[-0.985,  0.943, -0.816,  0.5  ],</span>
<span class="sd">           [-0.123,  0.236, -0.408,  0.5  ],</span>
<span class="sd">           [ 0.   ,  0.   ,  0.   ,  0.5  ],</span>
<span class="sd">           [ 0.123,  0.236,  0.408,  0.5  ]])</span>

<span class="sd">    &gt;&gt;&gt; # Thresholding and filling</span>
<span class="sd">    &gt;&gt;&gt; S[:, -1] = 1e-308</span>
<span class="sd">    &gt;&gt;&gt; S</span>
<span class="sd">    array([[ -8.000e+000,   4.000e+000,  -2.000e+000,</span>
<span class="sd">              1.000e-308],</span>
<span class="sd">           [ -1.000e+000,   1.000e+000,  -1.000e+000,</span>
<span class="sd">              1.000e-308],</span>
<span class="sd">           [  0.000e+000,   0.000e+000,   0.000e+000,</span>
<span class="sd">              1.000e-308],</span>
<span class="sd">           [  1.000e+000,   1.000e+000,   1.000e+000,</span>
<span class="sd">              1.000e-308]])</span>

<span class="sd">    &gt;&gt;&gt; # By default, small-norm columns are left untouched</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.normalize(S)</span>
<span class="sd">    array([[ -1.000e+000,   1.000e+000,  -1.000e+000,</span>
<span class="sd">              1.000e-308],</span>
<span class="sd">           [ -1.250e-001,   2.500e-001,  -5.000e-001,</span>
<span class="sd">              1.000e-308],</span>
<span class="sd">           [  0.000e+000,   0.000e+000,   0.000e+000,</span>
<span class="sd">              1.000e-308],</span>
<span class="sd">           [  1.250e-001,   2.500e-001,   5.000e-001,</span>
<span class="sd">              1.000e-308]])</span>
<span class="sd">    &gt;&gt;&gt; # Small-norm columns can be zeroed out</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.normalize(S, fill=False)</span>
<span class="sd">    array([[-1.   ,  1.   , -1.   ,  0.   ],</span>
<span class="sd">           [-0.125,  0.25 , -0.5  ,  0.   ],</span>
<span class="sd">           [ 0.   ,  0.   ,  0.   ,  0.   ],</span>
<span class="sd">           [ 0.125,  0.25 ,  0.5  ,  0.   ]])</span>
<span class="sd">    &gt;&gt;&gt; # Or set to constant with unit-norm</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.normalize(S, fill=True)</span>
<span class="sd">    array([[-1.   ,  1.   , -1.   ,  1.   ],</span>
<span class="sd">           [-0.125,  0.25 , -0.5  ,  1.   ],</span>
<span class="sd">           [ 0.   ,  0.   ,  0.   ,  1.   ],</span>
<span class="sd">           [ 0.125,  0.25 ,  0.5  ,  1.   ]])</span>
<span class="sd">    &gt;&gt;&gt; # With an l1 norm instead of max-norm</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.normalize(S, norm=1, fill=True)</span>
<span class="sd">    array([[-0.8  ,  0.667, -0.5  ,  0.25 ],</span>
<span class="sd">           [-0.1  ,  0.167, -0.25 ,  0.25 ],</span>
<span class="sd">           [ 0.   ,  0.   ,  0.   ,  0.25 ],</span>
<span class="sd">           [ 0.1  ,  0.167,  0.25 ,  0.25 ]])</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Avoid div-by-zero</span>
    <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">tiny</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">threshold</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;threshold=</span><span class="si">{}</span><span class="s1"> must be strictly &#39;</span>
                             <span class="s1">&#39;positive&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">threshold</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">fill</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;fill=</span><span class="si">{}</span><span class="s1"> must be None or boolean&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fill</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">S</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Input must be finite&#39;</span><span class="p">)</span>

    <span class="c1"># All norms only depend on magnitude, let&#39;s do that first</span>
    <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="c1"># For max/min norms, filling with 1 works</span>
    <span class="n">fill_norm</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fill</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Cannot normalize with norm=0 and fill=True&#39;</span><span class="p">)</span>

        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mag</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">norm</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span> <span class="ow">and</span> <span class="n">norm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mag</span><span class="o">**</span><span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">norm</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fill_norm</span> <span class="o">=</span> <span class="n">mag</span><span class="o">.</span><span class="n">size</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="n">norm</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fill_norm</span> <span class="o">=</span> <span class="n">mag</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="n">norm</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Unsupported norm: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">norm</span><span class="p">)))</span>

    <span class="c1"># indices where norm is below the threshold</span>
    <span class="n">small_idx</span> <span class="o">=</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="n">threshold</span>

    <span class="k">if</span> <span class="n">fill</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Leave small indices un-normalized</span>
        <span class="n">length</span><span class="p">[</span><span class="n">small_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">Snorm</span> <span class="o">=</span> <span class="n">S</span> <span class="o">/</span> <span class="n">length</span>

    <span class="k">elif</span> <span class="n">fill</span><span class="p">:</span>
        <span class="c1"># If we have a non-zero fill value, we locate those entries by</span>
        <span class="c1"># doing a nan-divide.</span>
        <span class="c1"># If S was finite, then length is finite (except for small positions)</span>
        <span class="n">length</span><span class="p">[</span><span class="n">small_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">Snorm</span> <span class="o">=</span> <span class="n">S</span> <span class="o">/</span> <span class="n">length</span>
        <span class="n">Snorm</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Snorm</span><span class="p">)]</span> <span class="o">=</span> <span class="n">fill_norm</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Set small values to zero by doing an inf-divide.</span>
        <span class="c1"># This is safe (by IEEE-754) as long as S is finite.</span>
        <span class="n">length</span><span class="p">[</span><span class="n">small_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">Snorm</span> <span class="o">=</span> <span class="n">S</span> <span class="o">/</span> <span class="n">length</span>

    <span class="k">return</span> <span class="n">Snorm</span></div>


<div class="viewcode-block" id="match_intervals"><a class="viewcode-back" href="../../../generated/librosa.util.match_intervals.html#librosa.util.match_intervals">[docs]</a><span class="k">def</span> <span class="nf">match_intervals</span><span class="p">(</span><span class="n">intervals_from</span><span class="p">,</span> <span class="n">intervals_to</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Match one set of time intervals to another.</span>

<span class="sd">    This can be useful for tasks such as mapping beat timings</span>
<span class="sd">    to segments.</span>

<span class="sd">    .. note:: A target interval may be matched to multiple source</span>
<span class="sd">      intervals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    intervals_from : np.ndarray [shape=(n, 2)]</span>
<span class="sd">        The time range for source intervals.</span>
<span class="sd">        The `i` th interval spans time `intervals_from[i, 0]`</span>
<span class="sd">        to `intervals_from[i, 1]`.</span>
<span class="sd">        `intervals_from[0, 0]` should be 0, `intervals_from[-1, 1]`</span>
<span class="sd">        should be the track duration.</span>

<span class="sd">    intervals_to : np.ndarray [shape=(m, 2)]</span>
<span class="sd">        Analogous to `intervals_from`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    interval_mapping : np.ndarray [shape=(n,)]</span>
<span class="sd">        For each interval in `intervals_from`, the</span>
<span class="sd">        corresponding interval in `intervals_to`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    match_events</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If either array of input intervals is not the correct shape</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intervals_from</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">intervals_to</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Attempting to match empty interval list&#39;</span><span class="p">)</span>

    <span class="c1"># Verify that the input intervals has correct shape and size</span>
    <span class="n">valid_intervals</span><span class="p">(</span><span class="n">intervals_from</span><span class="p">)</span>
    <span class="n">valid_intervals</span><span class="p">(</span><span class="n">intervals_to</span><span class="p">)</span>

    <span class="c1"># The overlap score of a beat with a segment is defined as</span>
    <span class="c1">#   max(0, min(beat_end, segment_end) - max(beat_start, segment_start))</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intervals_from</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

    <span class="n">n_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">MAX_MEM_BLOCK</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intervals_to</span><span class="p">)</span> <span class="o">*</span> <span class="n">intervals_to</span><span class="o">.</span><span class="n">itemsize</span><span class="p">))</span>
    <span class="n">n_rows</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">bl_s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">intervals_from</span><span class="p">),</span> <span class="n">n_rows</span><span class="p">):</span>
        <span class="n">bl_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bl_s</span> <span class="o">+</span> <span class="n">n_rows</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">intervals_from</span><span class="p">))</span>
        <span class="n">tmp_from</span> <span class="o">=</span> <span class="n">intervals_from</span><span class="p">[</span><span class="n">bl_s</span><span class="p">:</span><span class="n">bl_t</span><span class="p">]</span>

        <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">tmp_from</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">intervals_to</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">tmp_from</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">intervals_to</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ends</span> <span class="o">-</span> <span class="n">starts</span><span class="p">)</span>

        <span class="n">output</span><span class="p">[</span><span class="n">bl_s</span><span class="p">:</span><span class="n">bl_t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="match_events"><a class="viewcode-back" href="../../../generated/librosa.util.match_events.html#librosa.util.match_events">[docs]</a><span class="k">def</span> <span class="nf">match_events</span><span class="p">(</span><span class="n">events_from</span><span class="p">,</span> <span class="n">events_to</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Match one set of events to another.</span>

<span class="sd">    This is useful for tasks such as matching beats to the nearest</span>
<span class="sd">    detected onsets, or frame-aligned events to the nearest zero-crossing.</span>

<span class="sd">    .. note:: A target event may be matched to multiple source events.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Sources are multiples of 7</span>
<span class="sd">    &gt;&gt;&gt; s_from = np.arange(0, 100, 7)</span>
<span class="sd">    &gt;&gt;&gt; s_from</span>
<span class="sd">    array([ 0,  7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91,</span>
<span class="sd">           98])</span>
<span class="sd">    &gt;&gt;&gt; # Targets are multiples of 10</span>
<span class="sd">    &gt;&gt;&gt; s_to = np.arange(0, 100, 10)</span>
<span class="sd">    &gt;&gt;&gt; s_to</span>
<span class="sd">    array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])</span>
<span class="sd">    &gt;&gt;&gt; # Find the matching</span>
<span class="sd">    &gt;&gt;&gt; idx = librosa.util.match_events(s_from, s_to)</span>
<span class="sd">    &gt;&gt;&gt; idx</span>
<span class="sd">    array([0, 1, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 8, 9, 9])</span>
<span class="sd">    &gt;&gt;&gt; # Print each source value to its matching target</span>
<span class="sd">    &gt;&gt;&gt; zip(s_from, s_to[idx])</span>
<span class="sd">    [(0, 0), (7, 10), (14, 10), (21, 20), (28, 30), (35, 30),</span>
<span class="sd">     (42, 40), (49, 50), (56, 60), (63, 60), (70, 70), (77, 80),</span>
<span class="sd">     (84, 80), (91, 90), (98, 90)]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    events_from : ndarray [shape=(n,)]</span>
<span class="sd">      Array of events (eg, times, sample or frame indices) to match from.</span>

<span class="sd">    events_to : ndarray [shape=(m,)]</span>
<span class="sd">      Array of events (eg, times, sample or frame indices) to</span>
<span class="sd">      match against.</span>

<span class="sd">    left : bool</span>
<span class="sd">    right : bool</span>
<span class="sd">        If `False`, then matched events cannot be to the left (or right)</span>
<span class="sd">        of source events.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    event_mapping : np.ndarray [shape=(n,)]</span>
<span class="sd">        For each event in `events_from`, the corresponding event</span>
<span class="sd">        index in `events_to`.</span>

<span class="sd">        `event_mapping[i] == arg min |events_from[i] - events_to[:]|`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    match_intervals</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If either array of input events is not the correct shape</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">events_from</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">events_to</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Attempting to match empty event list&#39;</span><span class="p">)</span>

    <span class="c1"># If we can&#39;t match left or right, then only strict equivalence</span>
    <span class="c1"># counts as a match.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">left</span> <span class="ow">or</span> <span class="n">right</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">events_from</span><span class="p">,</span> <span class="n">events_to</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Cannot match events with left=right=False &#39;</span>
                                 <span class="s1">&#39;and events_from is not contained &#39;</span>
                                 <span class="s1">&#39;in events_to&#39;</span><span class="p">)</span>

    <span class="c1"># If we can&#39;t match to the left, then there should be at least one</span>
    <span class="c1"># target event greater-equal to every source event</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">max</span><span class="p">(</span><span class="n">events_to</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">events_from</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Cannot match events with left=False &#39;</span>
                             <span class="s1">&#39;and max(events_to) &lt; max(events_from)&#39;</span><span class="p">)</span>

    <span class="c1"># If we can&#39;t match to the right, then there should be at least one</span>
    <span class="c1"># target event less-equal to every source event</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">right</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">min</span><span class="p">(</span><span class="n">events_to</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">events_from</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Cannot match events with right=False &#39;</span>
                             <span class="s1">&#39;and min(events_to) &gt; min(events_from)&#39;</span><span class="p">)</span>

    <span class="c1"># Pre-allocate the output array</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">events_from</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

    <span class="c1"># Compute how many rows we can process at once within the memory block</span>
    <span class="n">n_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">MAX_MEM_BLOCK</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">events_to</span><span class="p">)</span>
                                  <span class="o">*</span> <span class="n">events_from</span><span class="o">.</span><span class="n">itemsize</span><span class="p">))</span>

    <span class="c1"># Make sure we can at least make some progress</span>
    <span class="n">n_rows</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">)</span>

    <span class="c1"># Iterate over blocks of the data</span>
    <span class="k">for</span> <span class="n">bl_s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">events_from</span><span class="p">),</span> <span class="n">n_rows</span><span class="p">):</span>
        <span class="n">bl_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bl_s</span> <span class="o">+</span> <span class="n">n_rows</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">events_from</span><span class="p">))</span>

        <span class="n">event_block</span> <span class="o">=</span> <span class="n">events_from</span><span class="p">[</span><span class="n">bl_s</span><span class="p">:</span><span class="n">bl_t</span><span class="p">]</span>

        <span class="c1"># distance[i, j] = |events_from - events_to[j]|</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">event_block</span><span class="p">,</span>
                                            <span class="n">events_to</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="c1"># If we can&#39;t match to the right, squash all comparisons where</span>
        <span class="c1"># events_to[j] &gt; events_from[i]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">distance</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">event_block</span><span class="p">,</span> <span class="n">events_to</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># If we can&#39;t match to the left, squash all comparisons where</span>
        <span class="c1"># events_to[j] &lt; events_from[i]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">left</span><span class="p">:</span>
            <span class="n">distance</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">event_block</span><span class="p">,</span> <span class="n">events_to</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># Find the minimum distance point from whatever&#39;s left after squashing</span>
        <span class="n">output</span><span class="p">[</span><span class="n">bl_s</span><span class="p">:</span><span class="n">bl_t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="localmax"><a class="viewcode-back" href="../../../generated/librosa.util.localmax.html#librosa.util.localmax">[docs]</a><span class="k">def</span> <span class="nf">localmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find local maxima in an array `x`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1, 0, 1, 2, -1, 0, -2, 1])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.localmax(x)</span>
<span class="sd">    array([False, False, False,  True, False,  True, False,  True], dtype=bool)</span>

<span class="sd">    &gt;&gt;&gt; # Two-dimensional example</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[1,0,1], [2, -1, 0], [2, 1, 3]])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.localmax(x, axis=0)</span>
<span class="sd">    array([[False, False, False],</span>
<span class="sd">           [ True, False, False],</span>
<span class="sd">           [False,  True,  True]], dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.localmax(x, axis=1)</span>
<span class="sd">    array([[False, False,  True],</span>
<span class="sd">           [False, False,  True],</span>
<span class="sd">           [False, False,  True]], dtype=bool)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x     : np.ndarray [shape=(d1,d2,...)]</span>
<span class="sd">      input vector or array</span>

<span class="sd">    axis : int</span>
<span class="sd">      axis along which to compute local maximality</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    m     : np.ndarray [shape=x.shape, dtype=bool]</span>
<span class="sd">        indicator array of local maximality along `axis`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">paddings</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">paddings</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">x_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">paddings</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>

    <span class="n">inds1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">inds1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">inds2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">inds2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">x_pad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">x_pad</span><span class="p">[</span><span class="n">inds1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">x_pad</span><span class="p">[</span><span class="n">inds2</span><span class="p">])</span></div>


<div class="viewcode-block" id="peak_pick"><a class="viewcode-back" href="../../../generated/librosa.util.peak_pick.html#librosa.util.peak_pick">[docs]</a><span class="k">def</span> <span class="nf">peak_pick</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pre_max</span><span class="p">,</span> <span class="n">post_max</span><span class="p">,</span> <span class="n">pre_avg</span><span class="p">,</span> <span class="n">post_avg</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">wait</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Uses a flexible heuristic to pick peaks in a signal.</span>

<span class="sd">    A sample n is selected as an peak if the corresponding x[n]</span>
<span class="sd">    fulfills the following three conditions:</span>

<span class="sd">    1. `x[n] == max(x[n - pre_max:n + post_max])`</span>
<span class="sd">    2. `x[n] &gt;= mean(x[n - pre_avg:n + post_avg]) + delta`</span>
<span class="sd">    3. `n - previous_n &gt; wait`</span>

<span class="sd">    where `previous_n` is the last sample picked as a peak (greedily).</span>

<span class="sd">    This implementation is based on [1]_ and [2]_.</span>

<span class="sd">    .. [1] Boeck, Sebastian, Florian Krebs, and Markus Schedl.</span>
<span class="sd">        &quot;Evaluating the Online Capabilities of Onset Detection Methods.&quot; ISMIR.</span>
<span class="sd">        2012.</span>

<span class="sd">    .. [2] https://github.com/CPJKU/onset_detection/blob/master/onset_program.py</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x         : np.ndarray [shape=(n,)]</span>
<span class="sd">        input signal to peak picks from</span>

<span class="sd">    pre_max   : int &gt;= 0 [scalar]</span>
<span class="sd">        number of samples before `n` over which max is computed</span>

<span class="sd">    post_max  : int &gt;= 1 [scalar]</span>
<span class="sd">        number of samples after `n` over which max is computed</span>

<span class="sd">    pre_avg   : int &gt;= 0 [scalar]</span>
<span class="sd">        number of samples before `n` over which mean is computed</span>

<span class="sd">    post_avg  : int &gt;= 1 [scalar]</span>
<span class="sd">        number of samples after `n` over which mean is computed</span>

<span class="sd">    delta     : float &gt;= 0 [scalar]</span>
<span class="sd">        threshold offset for mean</span>

<span class="sd">    wait      : int &gt;= 0 [scalar]</span>
<span class="sd">        number of samples to wait after picking a peak</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    peaks     : np.ndarray [shape=(n_peaks,), dtype=int]</span>
<span class="sd">        indices of peaks in `x`</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If any input lies outside its defined range</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(), duration=15)</span>
<span class="sd">    &gt;&gt;&gt; onset_env = librosa.onset.onset_strength(y=y, sr=sr,</span>
<span class="sd">    ...                                          hop_length=512,</span>
<span class="sd">    ...                                          aggregate=np.median)</span>
<span class="sd">    &gt;&gt;&gt; peaks = librosa.util.peak_pick(onset_env, 3, 3, 3, 5, 0.5, 10)</span>
<span class="sd">    &gt;&gt;&gt; peaks</span>
<span class="sd">    array([  4,  23,  73, 102, 142, 162, 182, 211, 261, 301, 320,</span>
<span class="sd">           331, 348, 368, 382, 396, 411, 431, 446, 461, 476, 491,</span>
<span class="sd">           510, 525, 536, 555, 570, 590, 609, 625, 639])</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; times = librosa.frames_to_time(np.arange(len(onset_env)),</span>
<span class="sd">    ...                                sr=sr, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; ax = plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; D = librosa.stft(y)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(D, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1, sharex=ax)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(times, onset_env, alpha=0.8, label=&#39;Onset strength&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.vlines(times[peaks], 0,</span>
<span class="sd">    ...            onset_env.max(), color=&#39;r&#39;, alpha=0.8,</span>
<span class="sd">    ...            label=&#39;Selected peaks&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True, framealpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">pre_max</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;pre_max must be non-negative&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pre_avg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;pre_avg must be non-negative&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;delta must be non-negative&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">wait</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;wait must be non-negative&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">post_max</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;post_max must be positive&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">post_avg</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;post_avg must be positive&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;input array must be one-dimensional&#39;</span><span class="p">)</span>

    <span class="c1"># Ensure valid index types</span>
    <span class="n">pre_max</span> <span class="o">=</span> <span class="n">valid_int</span><span class="p">(</span><span class="n">pre_max</span><span class="p">,</span> <span class="n">cast</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">)</span>
    <span class="n">post_max</span> <span class="o">=</span> <span class="n">valid_int</span><span class="p">(</span><span class="n">post_max</span><span class="p">,</span> <span class="n">cast</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">)</span>
    <span class="n">pre_avg</span> <span class="o">=</span> <span class="n">valid_int</span><span class="p">(</span><span class="n">pre_avg</span><span class="p">,</span> <span class="n">cast</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">)</span>
    <span class="n">post_avg</span> <span class="o">=</span> <span class="n">valid_int</span><span class="p">(</span><span class="n">post_avg</span><span class="p">,</span> <span class="n">cast</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">)</span>
    <span class="n">wait</span> <span class="o">=</span> <span class="n">valid_int</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">cast</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">)</span>

    <span class="c1"># Get the maximum of the signal over a sliding window</span>
    <span class="n">max_length</span> <span class="o">=</span> <span class="n">pre_max</span> <span class="o">+</span> <span class="n">post_max</span>
    <span class="n">max_origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">pre_max</span> <span class="o">-</span> <span class="n">post_max</span><span class="p">))</span>
    <span class="c1"># Using mode=&#39;constant&#39; and cval=x.min() effectively truncates</span>
    <span class="c1"># the sliding window at the boundaries</span>
    <span class="n">mov_max</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">maximum_filter1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_length</span><span class="p">),</span>
                                                     <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                                                     <span class="n">origin</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">max_origin</span><span class="p">),</span>
                                                     <span class="n">cval</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>

    <span class="c1"># Get the mean of the signal over a sliding window</span>
    <span class="n">avg_length</span> <span class="o">=</span> <span class="n">pre_avg</span> <span class="o">+</span> <span class="n">post_avg</span>
    <span class="n">avg_origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">pre_avg</span> <span class="o">-</span> <span class="n">post_avg</span><span class="p">))</span>
    <span class="c1"># Here, there is no mode which results in the behavior we want,</span>
    <span class="c1"># so we&#39;ll correct below.</span>
    <span class="n">mov_avg</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">uniform_filter1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">avg_length</span><span class="p">),</span>
                                                     <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                                                     <span class="n">origin</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">avg_origin</span><span class="p">))</span>

    <span class="c1"># Correct sliding average at the beginning</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Only need to correct in the range where the window needs to be truncated</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">-</span> <span class="n">pre_avg</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c1"># This just explicitly does mean(x[n - pre_avg:n + post_avg])</span>
        <span class="c1"># with truncation</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">pre_avg</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">mov_avg</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">n</span> <span class="o">+</span> <span class="n">post_avg</span><span class="p">])</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Correct sliding average at the end</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">post_avg</span>
    <span class="c1"># When post_avg &gt; x.shape[0] (weird case), reset to 0</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">pre_avg</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">mov_avg</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">n</span> <span class="o">+</span> <span class="n">post_avg</span><span class="p">])</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># First mask out all entries not equal to the local max</span>
    <span class="n">detections</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">mov_max</span><span class="p">)</span>

    <span class="c1"># Then mask out all entries less than the thresholded average</span>
    <span class="n">detections</span> <span class="o">=</span> <span class="n">detections</span> <span class="o">*</span> <span class="p">(</span><span class="n">detections</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">mov_avg</span> <span class="o">+</span> <span class="n">delta</span><span class="p">))</span>

    <span class="c1"># Initialize peaks array, to be filled greedily</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Remove onsets which are close together in time</span>
    <span class="n">last_onset</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">detections</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c1"># Only report an onset if the &quot;wait&quot; samples was reported</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">last_onset</span> <span class="o">+</span> <span class="n">wait</span><span class="p">:</span>
            <span class="n">peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1"># Save last reported onset</span>
            <span class="n">last_onset</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span></div>


<span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<div class="viewcode-block" id="sparsify_rows"><a class="viewcode-back" href="../../../generated/librosa.util.sparsify_rows.html#librosa.util.sparsify_rows">[docs]</a><span class="k">def</span> <span class="nf">sparsify_rows</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">quantile</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return a row-sparse matrix approximating the input `x`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray [ndim &lt;= 2]</span>
<span class="sd">        The input matrix to sparsify.</span>

<span class="sd">    quantile : float in [0, 1.0)</span>
<span class="sd">        Percentage of magnitude to discard in each row of `x`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_sparse : `scipy.sparse.csr_matrix` [shape=x.shape]</span>
<span class="sd">        Row-sparsified approximation of `x`</span>

<span class="sd">        If `x.ndim == 1`, then `x` is interpreted as a row vector,</span>
<span class="sd">        and `x_sparse.shape == (1, len(x))`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If `x.ndim &gt; 2`</span>

<span class="sd">        If `quantile` lies outside `[0, 1.0)`</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 40.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Construct a Hann window to sparsify</span>
<span class="sd">    &gt;&gt;&gt; x = scipy.signal.hann(32)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([ 0.   ,  0.01 ,  0.041,  0.09 ,  0.156,  0.236,  0.326,</span>
<span class="sd">            0.424,  0.525,  0.625,  0.72 ,  0.806,  0.879,  0.937,</span>
<span class="sd">            0.977,  0.997,  0.997,  0.977,  0.937,  0.879,  0.806,</span>
<span class="sd">            0.72 ,  0.625,  0.525,  0.424,  0.326,  0.236,  0.156,</span>
<span class="sd">            0.09 ,  0.041,  0.01 ,  0.   ])</span>
<span class="sd">    &gt;&gt;&gt; # Discard the bottom percentile</span>
<span class="sd">    &gt;&gt;&gt; x_sparse = librosa.util.sparsify_rows(x, quantile=0.01)</span>
<span class="sd">    &gt;&gt;&gt; x_sparse</span>
<span class="sd">    &lt;1x32 sparse matrix of type &#39;&lt;type &#39;numpy.float64&#39;&gt;&#39;</span>
<span class="sd">        with 26 stored elements in Compressed Sparse Row format&gt;</span>
<span class="sd">    &gt;&gt;&gt; x_sparse.todense()</span>
<span class="sd">    matrix([[ 0.   ,  0.   ,  0.   ,  0.09 ,  0.156,  0.236,  0.326,</span>
<span class="sd">              0.424,  0.525,  0.625,  0.72 ,  0.806,  0.879,  0.937,</span>
<span class="sd">              0.977,  0.997,  0.997,  0.977,  0.937,  0.879,  0.806,</span>
<span class="sd">              0.72 ,  0.625,  0.525,  0.424,  0.326,  0.236,  0.156,</span>
<span class="sd">              0.09 ,  0.   ,  0.   ,  0.   ]])</span>
<span class="sd">    &gt;&gt;&gt; # Discard up to the bottom 10th percentile</span>
<span class="sd">    &gt;&gt;&gt; x_sparse = librosa.util.sparsify_rows(x, quantile=0.1)</span>
<span class="sd">    &gt;&gt;&gt; x_sparse</span>
<span class="sd">    &lt;1x32 sparse matrix of type &#39;&lt;type &#39;numpy.float64&#39;&gt;&#39;</span>
<span class="sd">        with 20 stored elements in Compressed Sparse Row format&gt;</span>
<span class="sd">    &gt;&gt;&gt; x_sparse.todense()</span>
<span class="sd">    matrix([[ 0.   ,  0.   ,  0.   ,  0.   ,  0.   ,  0.   ,  0.326,</span>
<span class="sd">              0.424,  0.525,  0.625,  0.72 ,  0.806,  0.879,  0.937,</span>
<span class="sd">              0.977,  0.997,  0.997,  0.977,  0.937,  0.879,  0.806,</span>
<span class="sd">              0.72 ,  0.625,  0.525,  0.424,  0.326,  0.   ,  0.   ,</span>
<span class="sd">              0.   ,  0.   ,  0.   ,  0.   ]])</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Input must have 2 or fewer dimensions. &#39;</span>
                             <span class="s1">&#39;Provided x.shape=</span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">quantile</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid quantile </span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">quantile</span><span class="p">))</span>

    <span class="n">x_sparse</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">mags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mags</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">mag_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">mags</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">cumulative_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">mag_sort</span> <span class="o">/</span> <span class="n">norms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">threshold_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">cumulative_mag</span> <span class="o">&lt;</span> <span class="n">quantile</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">threshold_idx</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">mag_sort</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
        <span class="n">x_sparse</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">x_sparse</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span></div>


<div class="viewcode-block" id="roll_sparse"><a class="viewcode-back" href="../../../generated/librosa.util.roll_sparse.html#librosa.util.roll_sparse">[docs]</a><span class="k">def</span> <span class="nf">roll_sparse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Sparse matrix roll</span>

<span class="sd">    This operation is equivalent to ``numpy.roll``, but operates on sparse matrices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : scipy.sparse.spmatrix or np.ndarray</span>
<span class="sd">        The sparse matrix input</span>

<span class="sd">    shift : int</span>
<span class="sd">        The number of positions to roll the specified axis</span>

<span class="sd">    axis : (0, 1, -1)</span>
<span class="sd">        The axis along which to roll.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_rolled : same type as `x`</span>
<span class="sd">        The rolled matrix, with the same format as `x`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.roll</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Generate a random sparse binary matrix</span>
<span class="sd">    &gt;&gt;&gt; X = scipy.sparse.lil_matrix(np.random.randint(0, 2, size=(5,5)))</span>
<span class="sd">    &gt;&gt;&gt; X_roll = roll_sparse(X, 2, axis=0)  # Roll by 2 on the first axis</span>
<span class="sd">    &gt;&gt;&gt; X_dense_r = roll_sparse(X.toarray(), 2, axis=0)  # Equivalent dense roll</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(X_roll, X_dense_r.toarray())</span>
<span class="sd">    True</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">isspmatrix</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="c1"># shift-mod-length lets us have shift &gt; x.shape[axis]</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;axis must be one of (0, 1, -1)&#39;</span><span class="p">)</span>

    <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">shift</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">fmt</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">format</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

    <span class="c1"># lil matrix to start</span>
    <span class="n">x_r</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">idx_in</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">idx_out</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x_r</span><span class="o">.</span><span class="n">ndim</span>

    <span class="n">idx_in</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">shift</span><span class="p">)</span>
    <span class="n">idx_out</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">x_r</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx_out</span><span class="p">)]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx_in</span><span class="p">)]</span>

    <span class="n">idx_out</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>
    <span class="n">idx_in</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="n">shift</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">x_r</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx_out</span><span class="p">)]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx_in</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">x_r</span><span class="o">.</span><span class="n">asformat</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span></div>


<div class="viewcode-block" id="buf_to_float"><a class="viewcode-back" href="../../../generated/librosa.util.buf_to_float.html#librosa.util.buf_to_float">[docs]</a><span class="k">def</span> <span class="nf">buf_to_float</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_bytes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert an integer buffer to floating point values.</span>
<span class="sd">    This is primarily useful when loading integer-valued wav data</span>
<span class="sd">    into numpy arrays.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    buf_to_float</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray [dtype=int]</span>
<span class="sd">        The integer-valued data buffer</span>

<span class="sd">    n_bytes : int [1, 2, 4]</span>
<span class="sd">        The number of bytes per sample in `x`</span>

<span class="sd">    dtype : numeric type</span>
<span class="sd">        The target output type (default: 32-bit float)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_float : np.ndarray [dtype=float]</span>
<span class="sd">        The input data buffer cast to floating point</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Invert the scale of the data</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="mi">8</span> <span class="o">*</span> <span class="n">n_bytes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Construct the format string</span>
    <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;&lt;i</span><span class="si">{:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_bytes</span><span class="p">)</span>

    <span class="c1"># Rescale and format the data buffer</span>
    <span class="k">return</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="index_to_slice"><a class="viewcode-back" href="../../../generated/librosa.util.index_to_slice.html#librosa.util.index_to_slice">[docs]</a><span class="k">def</span> <span class="nf">index_to_slice</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx_min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idx_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Generate a slice array from an index array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    idx : list-like</span>
<span class="sd">        Array of index boundaries</span>

<span class="sd">    idx_min : None or int</span>
<span class="sd">    idx_max : None or int</span>
<span class="sd">        Minimum and maximum allowed indices</span>

<span class="sd">    step : None or int</span>
<span class="sd">        Step size for each slice.  If `None`, then the default</span>
<span class="sd">        step of 1 is used.</span>

<span class="sd">    pad : boolean</span>
<span class="sd">        If `True`, pad `idx` to span the range `idx_min:idx_max`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    slices : list of slice</span>
<span class="sd">        ``slices[i] = slice(idx[i], idx[i+1], step)``</span>
<span class="sd">        Additional slice objects may be added at the beginning or end,</span>
<span class="sd">        depending on whether ``pad==True`` and the supplied values for</span>
<span class="sd">        `idx_min` and `idx_max`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    fix_frames</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Generate slices from spaced indices</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.index_to_slice(np.arange(20, 100, 15))</span>
<span class="sd">    [slice(20, 35, None), slice(35, 50, None), slice(50, 65, None), slice(65, 80, None),</span>
<span class="sd">     slice(80, 95, None)]</span>
<span class="sd">    &gt;&gt;&gt; # Pad to span the range (0, 100)</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.index_to_slice(np.arange(20, 100, 15),</span>
<span class="sd">    ...                             idx_min=0, idx_max=100)</span>
<span class="sd">    [slice(0, 20, None), slice(20, 35, None), slice(35, 50, None), slice(50, 65, None),</span>
<span class="sd">     slice(65, 80, None), slice(80, 95, None), slice(95, 100, None)]</span>
<span class="sd">    &gt;&gt;&gt; # Use a step of 5 for each slice</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.index_to_slice(np.arange(20, 100, 15),</span>
<span class="sd">    ...                             idx_min=0, idx_max=100, step=5)</span>
<span class="sd">    [slice(0, 20, 5), slice(20, 35, 5), slice(35, 50, 5), slice(50, 65, 5), slice(65, 80, 5),</span>
<span class="sd">     slice(80, 95, 5), slice(95, 100, 5)]</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># First, normalize the index set</span>
    <span class="n">idx_fixed</span> <span class="o">=</span> <span class="n">fix_frames</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx_min</span><span class="p">,</span> <span class="n">idx_max</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">)</span>

    <span class="c1"># Now convert the indices to slices</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idx_fixed</span><span class="p">,</span> <span class="n">idx_fixed</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span></div>


<span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<div class="viewcode-block" id="sync"><a class="viewcode-back" href="../../../generated/librosa.util.sync.html#librosa.util.sync">[docs]</a><span class="k">def</span> <span class="nf">sync</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">aggregate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Synchronous aggregation of a multi-dimensional array between boundaries</span>

<span class="sd">    .. note::</span>
<span class="sd">        In order to ensure total coverage, boundary points may be added</span>
<span class="sd">        to `idx`.</span>

<span class="sd">        If synchronizing a feature matrix against beat tracker output, ensure</span>
<span class="sd">        that frame index numbers are properly aligned and use the same hop length.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data      : np.ndarray</span>
<span class="sd">        multi-dimensional array of features</span>

<span class="sd">    idx : iterable of ints or slices</span>
<span class="sd">        Either an ordered array of boundary indices, or</span>
<span class="sd">        an iterable collection of slice objects.</span>


<span class="sd">    aggregate : function</span>
<span class="sd">        aggregation function (default: `np.mean`)</span>

<span class="sd">    pad : boolean</span>
<span class="sd">        If `True`, `idx` is padded to span the full range `[0, data.shape[axis]]`</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to aggregate data</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data_sync : ndarray</span>
<span class="sd">        `data_sync` will have the same dimension as `data`, except that the `axis`</span>
<span class="sd">        coordinate will be reduced according to `idx`.</span>

<span class="sd">        For example, a 2-dimensional `data` with `axis=-1` should satisfy</span>

<span class="sd">        `data_sync[:, i] = aggregate(data[:, idx[i-1]:idx[i]], axis=-1)`</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If the index set is not of consistent type (all slices or all integers)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 40.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Beat-synchronous CQT spectra</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; tempo, beats = librosa.beat.beat_track(y=y, sr=sr, trim=False)</span>
<span class="sd">    &gt;&gt;&gt; cqt = librosa.cqt(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; beats = librosa.util.fix_frames(beats, x_max=cqt.shape[1])</span>

<span class="sd">    By default, use mean aggregation</span>

<span class="sd">    &gt;&gt;&gt; cqt_avg = librosa.util.sync(cqt, beats)</span>

<span class="sd">    Use median-aggregation instead of mean</span>

<span class="sd">    &gt;&gt;&gt; cqt_med = librosa.util.sync(cqt, beats,</span>
<span class="sd">    ...                             aggregate=np.median)</span>

<span class="sd">    Or sub-beat synchronization</span>

<span class="sd">    &gt;&gt;&gt; sub_beats = librosa.segment.subsegment(cqt, beats)</span>
<span class="sd">    &gt;&gt;&gt; sub_beats = librosa.util.fix_frames(sub_beats, x_max=cqt.shape[1])</span>
<span class="sd">    &gt;&gt;&gt; cqt_med_sub = librosa.util.sync(cqt, sub_beats, aggregate=np.median)</span>


<span class="sd">    Plot the results</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; beat_t = librosa.frames_to_time(beats, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; subbeat_t = librosa.frames_to_time(sub_beats, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(cqt,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;CQT power, shape={}&#39;.format(cqt.shape))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(cqt_med,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          x_coords=beat_t, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Beat synchronous CQT power, &#39;</span>
<span class="sd">    ...           &#39;shape={}&#39;.format(cqt_med.shape))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 1, 3)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(cqt_med_sub,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          x_coords=subbeat_t, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Sub-beat synchronous CQT power, &#39;</span>
<span class="sd">    ...           &#39;shape={}&#39;.format(cqt_med_sub.shape))</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">aggregate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">aggregate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]):</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="n">idx</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">_</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]):</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="n">index_to_slice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid index set: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

    <span class="n">agg_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">agg_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>

    <span class="n">data_agg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">agg_shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfortran</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">idx_in</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">idx_agg</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">data_agg</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">segment</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
        <span class="n">idx_in</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">segment</span>
        <span class="n">idx_agg</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">data_agg</span><span class="p">[</span><span class="n">idx_agg</span><span class="p">]</span> <span class="o">=</span> <span class="n">aggregate</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">idx_in</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data_agg</span></div>


<div class="viewcode-block" id="softmask"><a class="viewcode-back" href="../../../generated/librosa.util.softmask.html#librosa.util.softmask">[docs]</a><span class="k">def</span> <span class="nf">softmask</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X_ref</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">split_zeros</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Robustly compute a softmask operation.</span>

<span class="sd">        `M = X**power / (X**power + X_ref**power)`</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : np.ndarray</span>
<span class="sd">        The (non-negative) input array corresponding to the positive mask elements</span>

<span class="sd">    X_ref : np.ndarray</span>
<span class="sd">        The (non-negative) array of reference or background elements.</span>
<span class="sd">        Must have the same shape as `X`.</span>

<span class="sd">    power : number &gt; 0 or np.inf</span>
<span class="sd">        If finite, returns the soft mask computed in a numerically stable way</span>

<span class="sd">        If infinite, returns a hard (binary) mask equivalent to `X &gt; X_ref`.</span>
<span class="sd">        Note: for hard masks, ties are always broken in favor of `X_ref` (`mask=0`).</span>


<span class="sd">    split_zeros : bool</span>
<span class="sd">        If `True`, entries where `X` and X`_ref` are both small (close to 0)</span>
<span class="sd">        will receive mask values of 0.5.</span>

<span class="sd">        Otherwise, the mask is set to 0 for these entries.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask : np.ndarray, shape=`X.shape`</span>
<span class="sd">        The output mask array</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        If `X` and `X_ref` have different shapes.</span>

<span class="sd">        If `X` or `X_ref` are negative anywhere</span>

<span class="sd">        If `power &lt;= 0`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; X = 2 * np.ones((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; X_ref = np.vander(np.arange(3.0))</span>
<span class="sd">    &gt;&gt;&gt; X</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 2.,  2.,  2.],</span>
<span class="sd">           [ 2.,  2.,  2.]])</span>
<span class="sd">    &gt;&gt;&gt; X_ref</span>
<span class="sd">    array([[ 0.,  0.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.],</span>
<span class="sd">           [ 4.,  2.,  1.]])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.softmask(X, X_ref, power=1)</span>
<span class="sd">    array([[ 1.   ,  1.   ,  0.667],</span>
<span class="sd">           [ 0.667,  0.667,  0.667],</span>
<span class="sd">           [ 0.333,  0.5  ,  0.667]])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.softmask(X_ref, X, power=1)</span>
<span class="sd">    array([[ 0.   ,  0.   ,  0.333],</span>
<span class="sd">           [ 0.333,  0.333,  0.333],</span>
<span class="sd">           [ 0.667,  0.5  ,  0.333]])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.softmask(X, X_ref, power=2)</span>
<span class="sd">    array([[ 1. ,  1. ,  0.8],</span>
<span class="sd">           [ 0.8,  0.8,  0.8],</span>
<span class="sd">           [ 0.2,  0.5,  0.8]])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.softmask(X, X_ref, power=4)</span>
<span class="sd">    array([[ 1.   ,  1.   ,  0.941],</span>
<span class="sd">           [ 0.941,  0.941,  0.941],</span>
<span class="sd">           [ 0.059,  0.5  ,  0.941]])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.softmask(X, X_ref, power=100)</span>
<span class="sd">    array([[  1.000e+00,   1.000e+00,   1.000e+00],</span>
<span class="sd">           [  1.000e+00,   1.000e+00,   1.000e+00],</span>
<span class="sd">           [  7.889e-31,   5.000e-01,   1.000e+00]])</span>
<span class="sd">    &gt;&gt;&gt; librosa.util.softmask(X, X_ref, power=np.inf)</span>
<span class="sd">    array([[ True,  True,  True],</span>
<span class="sd">           [ True,  True,  True],</span>
<span class="sd">           [False, False,  True]], dtype=bool)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">X_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Shape mismatch: </span><span class="si">{}</span><span class="s1">!=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                             <span class="n">X_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">X</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">X_ref</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;X and X_ref must be non-negative&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">power</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;power must be strictly positive&#39;</span><span class="p">)</span>

    <span class="c1"># We&#39;re working with ints, cast to float.</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>

    <span class="c1"># Re-scale the input arrays relative to the larger value</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X_ref</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">bad_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">Z</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span><span class="p">)</span>
    <span class="n">Z</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># For finite power, compute the softmask</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">power</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">/</span> <span class="n">Z</span><span class="p">)</span><span class="o">**</span><span class="n">power</span>
        <span class="n">ref_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_ref</span> <span class="o">/</span> <span class="n">Z</span><span class="p">)</span><span class="o">**</span><span class="n">power</span>
        <span class="n">good_idx</span> <span class="o">=</span> <span class="o">~</span><span class="n">bad_idx</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">good_idx</span><span class="p">]</span> <span class="o">/=</span> <span class="n">mask</span><span class="p">[</span><span class="n">good_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">ref_mask</span><span class="p">[</span><span class="n">good_idx</span><span class="p">]</span>
        <span class="c1"># Wherever energy is below energy in both inputs, split the mask</span>
        <span class="k">if</span> <span class="n">split_zeros</span><span class="p">:</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Otherwise, compute the hard mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">X</span> <span class="o">&gt;</span> <span class="n">X_ref</span>

    <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="tiny"><a class="viewcode-back" href="../../../generated/librosa.util.tiny.html#librosa.util.tiny">[docs]</a><span class="k">def</span> <span class="nf">tiny</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute the tiny-value corresponding to an input&#39;s data type.</span>

<span class="sd">    This is the smallest &quot;usable&quot; number representable in `x`&#39;s</span>
<span class="sd">    data type (e.g., float32).</span>

<span class="sd">    This is primarily useful for determining a threshold for</span>
<span class="sd">    numerical underflow in division or multiplication operations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : number or np.ndarray</span>
<span class="sd">        The array to compute the tiny-value for.</span>
<span class="sd">        All that matters here is `x.dtype`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tiny_value : float</span>
<span class="sd">        The smallest positive usable number for the type of `x`.</span>
<span class="sd">        If `x` is integer-typed, then the tiny value for `np.float32`</span>
<span class="sd">        is returned instead.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.finfo</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    For a standard double-precision floating point number:</span>

<span class="sd">    &gt;&gt;&gt; librosa.util.tiny(1.0)</span>
<span class="sd">    2.2250738585072014e-308</span>

<span class="sd">    Or explicitly as double-precision</span>

<span class="sd">    &gt;&gt;&gt; librosa.util.tiny(np.asarray(1e-5, dtype=np.float64))</span>
<span class="sd">    2.2250738585072014e-308</span>

<span class="sd">    Or complex numbers</span>

<span class="sd">    &gt;&gt;&gt; librosa.util.tiny(1j)</span>
<span class="sd">    2.2250738585072014e-308</span>

<span class="sd">    Single-precision floating point:</span>

<span class="sd">    &gt;&gt;&gt; librosa.util.tiny(np.asarray(1e-5, dtype=np.float32))</span>
<span class="sd">    1.1754944e-38</span>

<span class="sd">    Integer</span>

<span class="sd">    &gt;&gt;&gt; librosa.util.tiny(5)</span>
<span class="sd">    1.1754944e-38</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Make sure we have an array view</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Only floating types generate a tiny</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">complex</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2013--2017, librosa development team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
        <span class="fa fa-book"> Other Versions</span>
        v: 0.5.0
        <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
        <dl>
            <dt>Tags</dt>
            <dd><a href="../../../../0.4.0rc1/index.html">0.4.0rc1</a></dd>
            <dd><a href="../../../../0.4.0rc2/index.html">0.4.0rc2</a></dd>
            <dd><a href="../../../../0.4.1/index.html">0.4.1</a></dd>
            <dd><a href="../../../../0.4.1rc0/index.html">0.4.1rc0</a></dd>
            <dd><a href="../../../../0.4.2/index.html">0.4.2</a></dd>
            <dd><a href="../../../../0.4.3/index.html">0.4.3</a></dd>
            <dd><a href="../../../../0.4.3rc0/index.html">0.4.3rc0</a></dd>
            <dd><a href="utils.html">0.5.0</a></dd>
            <dd><a href="../../../../0.5.0rc0/index.html">0.5.0rc0</a></dd>
            <dd><a href="../../../../0.5.1/index.html">0.5.1</a></dd>
            <dd><a href="../../../../0.6.0rc0/index.html">0.6.0rc0</a></dd>
            <dd><a href="../../../../v0.1.0/index.html">v0.1.0</a></dd>
            <dd><a href="../../../../v0.4.0/index.html">v0.4.0</a></dd>
        </dl>
        <dl>
            <dt>Branches</dt>
            <dd><a href="../../../../display-bin-centering/index.html">display-bin-centering</a></dd>
            <dd><a href="../../../../master/index.html">master</a></dd>
        </dl>
    </div>
</div>


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.5.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>