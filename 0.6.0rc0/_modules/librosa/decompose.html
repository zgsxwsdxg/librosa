

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>librosa.decompose &mdash; librosa 0.6.0rc0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  
    <link rel="stylesheet" href="../../_static/banner.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="librosa 0.6.0rc0 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> librosa
          

          
          </a>

          
            
            
              <div class="version">
                0.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../core.html">Core IO and DSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../display.html">Display</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../feature.html">Feature extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../onset.html">Onset detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../beat.html">Beat and tempo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../decompose.html">Spectrogram decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../effects.html">Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../output.html">Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../segment.html">Temporal segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../util.html">Utilities</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filters.html">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cache.html">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ioformats.html">Advanced I/O Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../advanced.html">Advanced examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">librosa</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>librosa.decompose</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for librosa.decompose</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Spectrogram decomposition</span>
<span class="sd">=========================</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    decompose</span>
<span class="sd">    hpss</span>
<span class="sd">    nn_filter</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">scipy.sparse</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">median_filter</span>

<span class="kn">import</span> <span class="nn">sklearn.decomposition</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">segment</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">.util.exceptions</span> <span class="k">import</span> <span class="n">ParameterError</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;decompose&#39;</span><span class="p">,</span> <span class="s1">&#39;hpss&#39;</span><span class="p">,</span> <span class="s1">&#39;nn_filter&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="decompose"><a class="viewcode-back" href="../../generated/librosa.decompose.decompose.html#librosa.decompose.decompose">[docs]</a><span class="k">def</span> <span class="nf">decompose</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decompose a feature matrix.</span>

<span class="sd">    Given a spectrogram `S`, produce a decomposition into `components`</span>
<span class="sd">    and `activations` such that `S ~= components.dot(activations)`.</span>

<span class="sd">    By default, this is done with with non-negative matrix factorization (NMF),</span>
<span class="sd">    but any `sklearn.decomposition`-type object will work.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray [shape=(n_features, n_samples), dtype=float]</span>
<span class="sd">        The input feature matrix (e.g., magnitude spectrogram)</span>

<span class="sd">    n_components : int &gt; 0 [scalar] or None</span>
<span class="sd">        number of desired components</span>

<span class="sd">        if None, then `n_features` components are used</span>

<span class="sd">    transformer : None or object</span>
<span class="sd">        If None, use `sklearn.decomposition.NMF`</span>

<span class="sd">        Otherwise, any object with a similar interface to NMF should work.</span>
<span class="sd">        `transformer` must follow the scikit-learn convention, where</span>
<span class="sd">        input data is `(n_samples, n_features)`.</span>

<span class="sd">        `transformer.fit_transform()` will be run on `S.T` (not `S`),</span>
<span class="sd">        the return value of which is stored (transposed) as `activations`</span>

<span class="sd">        The components will be retrieved as `transformer.components_.T`</span>

<span class="sd">        `S ~= np.dot(activations, transformer.components_).T`</span>

<span class="sd">        or equivalently:</span>
<span class="sd">        `S ~= np.dot(transformer.components_.T, activations.T)`</span>

<span class="sd">    sort : bool</span>
<span class="sd">        If `True`, components are sorted by ascending peak frequency.</span>

<span class="sd">        .. note:: If used with `transformer`, sorting is applied to copies</span>
<span class="sd">            of the decomposition parameters, and not to `transformer`&#39;s</span>
<span class="sd">            internal parameters.</span>

<span class="sd">    fit : bool</span>
<span class="sd">        If `True`, components are estimated from the input ``S``.</span>

<span class="sd">        If `False`, components are assumed to be pre-computed and stored</span>
<span class="sd">        in ``transformer``, and are not changed.</span>

<span class="sd">    kwargs : Additional keyword arguments to the default transformer</span>
<span class="sd">        `sklearn.decomposition.NMF`</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    components: np.ndarray [shape=(n_features, n_components)]</span>
<span class="sd">        matrix of components (basis elements).</span>

<span class="sd">    activations: np.ndarray [shape=(n_components, n_samples)]</span>
<span class="sd">        transformed matrix/activation matrix</span>


<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        if `fit` is False and no `transformer` object is provided.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sklearn.decomposition : SciKit-Learn matrix decomposition modules</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Decompose a magnitude spectrogram into 32 components with NMF</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; comps, acts = librosa.decompose.decompose(S, n_components=8)</span>
<span class="sd">    &gt;&gt;&gt; comps</span>
<span class="sd">    array([[  1.876e-01,   5.559e-02, ...,   1.687e-01,   4.907e-02],</span>
<span class="sd">           [  3.148e-01,   1.719e-01, ...,   2.314e-01,   9.493e-02],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  1.561e-07,   8.564e-08, ...,   7.167e-08,   4.997e-08],</span>
<span class="sd">           [  1.531e-07,   7.880e-08, ...,   5.632e-08,   4.028e-08]])</span>
<span class="sd">    &gt;&gt;&gt; acts</span>
<span class="sd">    array([[  4.197e-05,   8.512e-03, ...,   3.056e-05,   9.159e-06],</span>
<span class="sd">           [  9.568e-06,   1.718e-02, ...,   3.322e-05,   7.869e-06],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  5.982e-05,   1.311e-02, ...,  -0.000e+00,   6.323e-06],</span>
<span class="sd">           [  3.782e-05,   7.056e-03, ...,   3.290e-05,  -0.000e+00]])</span>


<span class="sd">    Sort components by ascending peak frequency</span>

<span class="sd">    &gt;&gt;&gt; comps, acts = librosa.decompose.decompose(S, n_components=16,</span>
<span class="sd">    ...                                           sort=True)</span>


<span class="sd">    Or with sparse dictionary learning</span>

<span class="sd">    &gt;&gt;&gt; import sklearn.decomposition</span>
<span class="sd">    &gt;&gt;&gt; T = sklearn.decomposition.MiniBatchDictionaryLearning(n_components=16)</span>
<span class="sd">    &gt;&gt;&gt; scomps, sacts = librosa.decompose.decompose(S, transformer=T, sort=True)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(10,8))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Input spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 2, 3)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(comps,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Components&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 2, 4)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(acts, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Components&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Activations&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 1, 3)</span>
<span class="sd">    &gt;&gt;&gt; S_approx = comps.dot(acts)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S_approx,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Reconstructed spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">transformer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fit</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;fit must be True if transformer is None&#39;</span><span class="p">)</span>

        <span class="n">transformer</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">decomposition</span><span class="o">.</span><span class="n">NMF</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_components</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_components</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">fit</span><span class="p">:</span>
        <span class="n">activations</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">activations</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="n">components</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">components_</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
        <span class="n">components</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">axis_sort</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">activations</span> <span class="o">=</span> <span class="n">activations</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">components</span><span class="p">,</span> <span class="n">activations</span></div>


<span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<div class="viewcode-block" id="hpss"><a class="viewcode-back" href="../../generated/librosa.decompose.hpss.html#librosa.decompose.hpss">[docs]</a><span class="k">def</span> <span class="nf">hpss</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">31</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Median-filtering harmonic percussive source separation (HPSS).</span>

<span class="sd">    If `margin = 1.0`, decomposes an input spectrogram `S = H + P`</span>
<span class="sd">    where `H` contains the harmonic components,</span>
<span class="sd">    and `P` contains the percussive components.</span>

<span class="sd">    If `margin &gt; 1.0`, decomposes an input spectrogram `S = H + P + R`</span>
<span class="sd">    where `R` contains residual components not included in `H` or `P`.</span>

<span class="sd">    This implementation is based upon the algorithm described by [1]_ and [2]_.</span>

<span class="sd">    .. [1] Fitzgerald, Derry.</span>
<span class="sd">        &quot;Harmonic/percussive separation using median filtering.&quot;</span>
<span class="sd">        13th International Conference on Digital Audio Effects (DAFX10),</span>
<span class="sd">        Graz, Austria, 2010.</span>

<span class="sd">    .. [2] Driedger, MÃ¼ller, Disch.</span>
<span class="sd">        &quot;Extending harmonic-percussive separation of audio.&quot;</span>
<span class="sd">        15th International Society for Music Information Retrieval Conference (ISMIR 2014),</span>
<span class="sd">        Taipei, Taiwan, 2014.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray [shape=(d, n)]</span>
<span class="sd">        input spectrogram. May be real (magnitude) or complex.</span>

<span class="sd">    kernel_size : int or tuple (kernel_harmonic, kernel_percussive)</span>
<span class="sd">        kernel size(s) for the median filters.</span>

<span class="sd">        - If scalar, the same size is used for both harmonic and percussive.</span>
<span class="sd">        - If tuple, the first value specifies the width of the</span>
<span class="sd">          harmonic filter, and the second value specifies the width</span>
<span class="sd">          of the percussive filter.</span>

<span class="sd">    power : float &gt; 0 [scalar]</span>
<span class="sd">        Exponent for the Wiener filter when constructing soft mask matrices.</span>

<span class="sd">    mask : bool</span>
<span class="sd">        Return the masking matrices instead of components.</span>

<span class="sd">        Masking matrices contain non-negative real values that</span>
<span class="sd">        can be used to measure the assignment of energy from `S`</span>
<span class="sd">        into harmonic or percussive components.</span>

<span class="sd">        Components can be recovered by multiplying `S * mask_H`</span>
<span class="sd">        or `S * mask_P`.</span>


<span class="sd">    margin : float or tuple (margin_harmonic, margin_percussive)</span>
<span class="sd">        margin size(s) for the masks (as described in [2]_)</span>

<span class="sd">        - If scalar, the same size is used for both harmonic and percussive.</span>
<span class="sd">        - If tuple, the first value specifies the margin of the</span>
<span class="sd">          harmonic mask, and the second value specifies the margin</span>
<span class="sd">          of the percussive mask.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    harmonic : np.ndarray [shape=(d, n)]</span>
<span class="sd">        harmonic component (or mask)</span>

<span class="sd">    percussive : np.ndarray [shape=(d, n)]</span>
<span class="sd">        percussive component (or mask)</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    util.softmask</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Separate into harmonic and percussive</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(), duration=15)</span>
<span class="sd">    &gt;&gt;&gt; D = librosa.stft(y)</span>
<span class="sd">    &gt;&gt;&gt; H, P = librosa.decompose.hpss(D)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(D,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Full power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(H,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Harmonic power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(3, 1, 3)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(P,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Percussive power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>


<span class="sd">    Or with a narrower horizontal filter</span>

<span class="sd">    &gt;&gt;&gt; H, P = librosa.decompose.hpss(D, kernel_size=(13, 31))</span>

<span class="sd">    Just get harmonic/percussive masks, not the spectra</span>

<span class="sd">    &gt;&gt;&gt; mask_H, mask_P = librosa.decompose.hpss(D, mask=True)</span>
<span class="sd">    &gt;&gt;&gt; mask_H</span>
<span class="sd">    array([[  1.000e+00,   1.469e-01, ...,   2.648e-03,   2.164e-03],</span>
<span class="sd">           [  1.000e+00,   2.368e-01, ...,   9.413e-03,   7.703e-03],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  8.869e-01,   5.673e-02, ...,   4.603e-02,   1.247e-05],</span>
<span class="sd">           [  7.068e-01,   2.194e-02, ...,   4.453e-02,   1.205e-05]], dtype=float32)</span>
<span class="sd">    &gt;&gt;&gt; mask_P</span>
<span class="sd">    array([[  2.858e-05,   8.531e-01, ...,   9.974e-01,   9.978e-01],</span>
<span class="sd">           [  1.586e-05,   7.632e-01, ...,   9.906e-01,   9.923e-01],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  1.131e-01,   9.433e-01, ...,   9.540e-01,   1.000e+00],</span>
<span class="sd">           [  2.932e-01,   9.781e-01, ...,   9.555e-01,   1.000e+00]], dtype=float32)</span>

<span class="sd">    Separate into harmonic/percussive/residual components by using a margin &gt; 1.0</span>

<span class="sd">    &gt;&gt;&gt; H, P = librosa.decompose.hpss(D, margin=3.0)</span>
<span class="sd">    &gt;&gt;&gt; R = D - (H+P)</span>
<span class="sd">    &gt;&gt;&gt; y_harm = librosa.core.istft(H)</span>
<span class="sd">    &gt;&gt;&gt; y_perc = librosa.core.istft(P)</span>
<span class="sd">    &gt;&gt;&gt; y_resi = librosa.core.istft(R)</span>


<span class="sd">    Get a more isolated percussive component by widening its margin</span>

<span class="sd">    &gt;&gt;&gt; H, P = librosa.decompose.hpss(D, margin=(1.0,5.0))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="n">S</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">magphase</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">):</span>
        <span class="n">win_harm</span> <span class="o">=</span> <span class="n">kernel_size</span>
        <span class="n">win_perc</span> <span class="o">=</span> <span class="n">kernel_size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">win_harm</span> <span class="o">=</span> <span class="n">kernel_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">win_perc</span> <span class="o">=</span> <span class="n">kernel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">margin</span><span class="p">):</span>
        <span class="n">margin_harm</span> <span class="o">=</span> <span class="n">margin</span>
        <span class="n">margin_perc</span> <span class="o">=</span> <span class="n">margin</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">margin_harm</span> <span class="o">=</span> <span class="n">margin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">margin_perc</span> <span class="o">=</span> <span class="n">margin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># margin minimum is 1.0</span>
    <span class="k">if</span> <span class="n">margin_harm</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">margin_perc</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s2">&quot;Margins must be &gt;= 1.0. &quot;</span>
                             <span class="s2">&quot;A typical range is between 1 and 10.&quot;</span><span class="p">)</span>

    <span class="c1"># Compute median filters. Pre-allocation here preserves memory layout.</span>
    <span class="n">harm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">harm</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">median_filter</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">win_harm</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">)</span>

    <span class="n">perc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">perc</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">median_filter</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">win_perc</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">)</span>

    <span class="n">split_zeros</span> <span class="o">=</span> <span class="p">(</span><span class="n">margin_harm</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">margin_perc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">mask_harm</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">softmask</span><span class="p">(</span><span class="n">harm</span><span class="p">,</span> <span class="n">perc</span> <span class="o">*</span> <span class="n">margin_harm</span><span class="p">,</span>
                              <span class="n">power</span><span class="o">=</span><span class="n">power</span><span class="p">,</span>
                              <span class="n">split_zeros</span><span class="o">=</span><span class="n">split_zeros</span><span class="p">)</span>

    <span class="n">mask_perc</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">softmask</span><span class="p">(</span><span class="n">perc</span><span class="p">,</span> <span class="n">harm</span> <span class="o">*</span> <span class="n">margin_perc</span><span class="p">,</span>
                              <span class="n">power</span><span class="o">=</span><span class="n">power</span><span class="p">,</span>
                              <span class="n">split_zeros</span><span class="o">=</span><span class="n">split_zeros</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mask_harm</span><span class="p">,</span> <span class="n">mask_perc</span>

    <span class="k">return</span> <span class="p">((</span><span class="n">S</span> <span class="o">*</span> <span class="n">mask_harm</span><span class="p">)</span> <span class="o">*</span> <span class="n">phase</span><span class="p">,</span> <span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="n">mask_perc</span><span class="p">)</span> <span class="o">*</span> <span class="n">phase</span><span class="p">)</span></div>


<span class="nd">@cache</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<div class="viewcode-block" id="nn_filter"><a class="viewcode-back" href="../../generated/librosa.decompose.nn_filter.html#librosa.decompose.nn_filter">[docs]</a><span class="k">def</span> <span class="nf">nn_filter</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">rec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aggregate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Filtering by nearest-neighbors.</span>

<span class="sd">    Each data point (e.g, spectrogram column) is replaced</span>
<span class="sd">    by aggregating its nearest neighbors in feature space.</span>

<span class="sd">    This can be useful for de-noising a spectrogram or feature matrix.</span>

<span class="sd">    The non-local means method [1]_ can be recovered by providing a</span>
<span class="sd">    weighted recurrence matrix as input and specifying `aggregate=np.average`.</span>

<span class="sd">    Similarly, setting `aggregate=np.median` produces sparse de-noising</span>
<span class="sd">    as in REPET-SIM [2]_.</span>

<span class="sd">    .. [1] Buades, A., Coll, B., &amp; Morel, J. M.</span>
<span class="sd">        (2005, June). A non-local algorithm for image denoising.</span>
<span class="sd">        In Computer Vision and Pattern Recognition, 2005.</span>
<span class="sd">        CVPR 2005. IEEE Computer Society Conference on (Vol. 2, pp. 60-65). IEEE.</span>

<span class="sd">    .. [2] Rafii, Z., &amp; Pardo, B.</span>
<span class="sd">        (2012, October).  &quot;Music/Voice Separation Using the Similarity Matrix.&quot;</span>
<span class="sd">        International Society for Music Information Retrieval Conference, 2012.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        The input data (spectrogram) to filter</span>

<span class="sd">    rec : (optional) scipy.sparse.spmatrix or np.ndarray</span>
<span class="sd">        Optionally, a pre-computed nearest-neighbor matrix</span>
<span class="sd">        as provided by `librosa.segment.recurrence_matrix`</span>

<span class="sd">    aggregate : function</span>
<span class="sd">        aggregation function (default: `np.mean`)</span>

<span class="sd">        If `aggregate=np.average`, then a weighted average is</span>
<span class="sd">        computed according to the (per-row) weights in `rec`.</span>

<span class="sd">        For all other aggregation functions, all neighbors</span>
<span class="sd">        are treated equally.</span>


<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to filter (by default, columns)</span>

<span class="sd">    kwargs</span>
<span class="sd">        Additional keyword arguments provided to</span>
<span class="sd">        `librosa.segment.recurrence_matrix` if `rec` is not provided</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_filtered : np.ndarray</span>
<span class="sd">        The filtered data</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError</span>
<span class="sd">        if `rec` is provided and its shape is incompatible with `S`.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    decompose</span>
<span class="sd">    hpss</span>
<span class="sd">    librosa.segment.recurrence_matrix</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function caches at level 30.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    De-noise a chromagram by non-local median filtering.</span>
<span class="sd">    By default this would use euclidean distance to select neighbors,</span>
<span class="sd">    but this can be overridden directly by setting the `metric` parameter.</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(),</span>
<span class="sd">    ...                      offset=30, duration=10)</span>
<span class="sd">    &gt;&gt;&gt; chroma = librosa.feature.chroma_cqt(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; chroma_med = librosa.decompose.nn_filter(chroma,</span>
<span class="sd">    ...                                          aggregate=np.median,</span>
<span class="sd">    ...                                          metric=&#39;cosine&#39;)</span>

<span class="sd">    To use non-local means, provide an affinity matrix and `aggregate=np.average`.</span>

<span class="sd">    &gt;&gt;&gt; rec = librosa.segment.recurrence_matrix(chroma, mode=&#39;affinity&#39;,</span>
<span class="sd">    ...                                         metric=&#39;cosine&#39;, sparse=True)</span>
<span class="sd">    &gt;&gt;&gt; chroma_nlm = librosa.decompose.nn_filter(chroma, rec=rec,</span>
<span class="sd">    ...                                          aggregate=np.average)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(10, 8))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(5, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma, y_axis=&#39;chroma&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Unfiltered&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(5, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma_med, y_axis=&#39;chroma&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Median-filtered&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(5, 1, 3)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma_nlm, y_axis=&#39;chroma&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Non-local means&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(5, 1, 4)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma - chroma_med,</span>
<span class="sd">    ...                          y_axis=&#39;chroma&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Original - median&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(5, 1, 5)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma - chroma_nlm,</span>
<span class="sd">    ...                          y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Original - NLM&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">aggregate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">aggregate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span>

    <span class="k">if</span> <span class="n">rec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sparse&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">rec</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">recurrence_matrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">rec</span><span class="p">):</span>
        <span class="n">rec</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="ow">or</span> <span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid self-similarity matrix shape &#39;</span>
                             <span class="s1">&#39;rec.shape=</span><span class="si">{}</span><span class="s1"> for S.shape=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                                  <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">__nn_filter_helper</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rec</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">rec</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span>
                              <span class="n">S</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="n">aggregate</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">__nn_filter_helper</span><span class="p">(</span><span class="n">R_data</span><span class="p">,</span> <span class="n">R_indices</span><span class="p">,</span> <span class="n">R_ptr</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Nearest-neighbor filter helper function.</span>

<span class="sd">    This is an internal function, not for use outside of the decompose module.</span>

<span class="sd">    It applies the nearest-neighbor filter to S, assuming that the first index</span>
<span class="sd">    corresponds to observations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R_data, R_indices, R_ptr : np.ndarrays</span>
<span class="sd">        The `data`, `indices`, and `indptr` of a scipy.sparse matrix</span>

<span class="sd">    S : np.ndarray</span>
<span class="sd">        The observation data to filter</span>

<span class="sd">    aggregate : callable</span>
<span class="sd">        The aggregation operator</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_out : np.ndarray like S</span>
<span class="sd">        The filtered data array</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">s_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R_ptr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

        <span class="c1"># Get the non-zeros out of the recurrence matrix</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="n">R_indices</span><span class="p">[</span><span class="n">R_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">R_ptr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">):</span>
            <span class="n">s_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">continue</span>

        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">aggregate</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">R_data</span><span class="p">[</span><span class="n">R_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">R_ptr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">s_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">aggregate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">aggregate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">s_out</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2013--2017, librosa development team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
        <span class="fa fa-book"> Other Versions</span>
        v: 0.6.0rc0
        <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
        <dl>
            <dt>Tags</dt>
            <dd><a href="../../../0.4.0rc1/index.html">0.4.0rc1</a></dd>
            <dd><a href="../../../0.4.0rc2/index.html">0.4.0rc2</a></dd>
            <dd><a href="../../../0.4.1/index.html">0.4.1</a></dd>
            <dd><a href="../../../0.4.1rc0/index.html">0.4.1rc0</a></dd>
            <dd><a href="../../../0.4.2/index.html">0.4.2</a></dd>
            <dd><a href="../../../0.4.3/index.html">0.4.3</a></dd>
            <dd><a href="../../../0.4.3rc0/index.html">0.4.3rc0</a></dd>
            <dd><a href="../../../0.5.0/index.html">0.5.0</a></dd>
            <dd><a href="../../../0.5.0rc0/index.html">0.5.0rc0</a></dd>
            <dd><a href="../../../0.5.1/index.html">0.5.1</a></dd>
            <dd><a href="decompose.html">0.6.0rc0</a></dd>
            <dd><a href="../../../v0.1.0/index.html">v0.1.0</a></dd>
            <dd><a href="../../../v0.4.0/index.html">v0.4.0</a></dd>
        </dl>
        <dl>
            <dt>Branches</dt>
            <dd><a href="../../../display-bin-centering/index.html">display-bin-centering</a></dd>
            <dd><a href="../../../master/index.html">master</a></dd>
        </dl>
    </div>
</div>


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.6.0rc0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>