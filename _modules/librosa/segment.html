

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>librosa.segment &mdash; librosa 0.4.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="librosa 0.4.1 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="../../index.html" class="icon icon-home"> librosa
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation instructions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../install.html#additional-notes">Additional notes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial.html#quickstart">Quickstart</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial.html#advanced-usage">Advanced usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial.html#more-examples">More examples</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../core.html">Core IO and DSP</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../core.html#audio-processing">Audio processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.load.html">librosa.core.load</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.to_mono.html">librosa.core.to_mono</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.resample.html">librosa.core.resample</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.get_duration.html">librosa.core.get_duration</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.autocorrelate.html">librosa.core.autocorrelate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.zero_crossings.html">librosa.core.zero_crossings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.clicks.html">librosa.core.clicks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../core.html#spectral-representations">Spectral representations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.stft.html">librosa.core.stft</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.istft.html">librosa.core.istft</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.ifgram.html">librosa.core.ifgram</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.cqt.html">librosa.core.cqt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.hybrid_cqt.html">librosa.core.hybrid_cqt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.pseudo_cqt.html">librosa.core.pseudo_cqt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.fmt.html">librosa.core.fmt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.phase_vocoder.html">librosa.core.phase_vocoder</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.magphase.html">librosa.core.magphase</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.logamplitude.html">librosa.core.logamplitude</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.perceptual_weighting.html">librosa.core.perceptual_weighting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.A_weighting.html">librosa.core.A_weighting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../core.html#time-and-frequency-conversion">Time and frequency conversion</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.frames_to_samples.html">librosa.core.frames_to_samples</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.frames_to_time.html">librosa.core.frames_to_time</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.samples_to_frames.html">librosa.core.samples_to_frames</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.samples_to_time.html">librosa.core.samples_to_time</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.time_to_frames.html">librosa.core.time_to_frames</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.time_to_samples.html">librosa.core.time_to_samples</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.hz_to_note.html">librosa.core.hz_to_note</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.hz_to_midi.html">librosa.core.hz_to_midi</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.midi_to_hz.html">librosa.core.midi_to_hz</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.midi_to_note.html">librosa.core.midi_to_note</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.note_to_hz.html">librosa.core.note_to_hz</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.note_to_midi.html">librosa.core.note_to_midi</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.hz_to_mel.html">librosa.core.hz_to_mel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.hz_to_octs.html">librosa.core.hz_to_octs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.mel_to_hz.html">librosa.core.mel_to_hz</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.octs_to_hz.html">librosa.core.octs_to_hz</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.fft_frequencies.html">librosa.core.fft_frequencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.cqt_frequencies.html">librosa.core.cqt_frequencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.mel_frequencies.html">librosa.core.mel_frequencies</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../core.html#pitch-and-tuning">Pitch and tuning</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.estimate_tuning.html">librosa.core.estimate_tuning</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.pitch_tuning.html">librosa.core.pitch_tuning</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.piptrack.html">librosa.core.piptrack</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../core.html#deprecated">Deprecated</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.core.ifptrack.html">librosa.core.ifptrack</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../display.html">Display</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../generated/librosa.display.specshow.html">librosa.display.specshow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../generated/librosa.display.waveplot.html">librosa.display.waveplot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../generated/librosa.display.time_ticks.html">librosa.display.time_ticks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../generated/librosa.display.cmap.html">librosa.display.cmap</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../feature.html">Feature extraction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../feature.html#spectral-features">Spectral features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.feature.chroma_stft.html">librosa.feature.chroma_stft</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.feature.chroma_cqt.html">librosa.feature.chroma_cqt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.feature.melspectrogram.html">librosa.feature.melspectrogram</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.feature.mfcc.html">librosa.feature.mfcc</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.feature.rmse.html">librosa.feature.rmse</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.feature.spectral_centroid.html">librosa.feature.spectral_centroid</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.feature.spectral_bandwidth.html">librosa.feature.spectral_bandwidth</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.feature.spectral_contrast.html">librosa.feature.spectral_contrast</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.feature.spectral_rolloff.html">librosa.feature.spectral_rolloff</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.feature.poly_features.html">librosa.feature.poly_features</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.feature.tonnetz.html">librosa.feature.tonnetz</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.feature.zero_crossing_rate.html">librosa.feature.zero_crossing_rate</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../feature.html#rhythm-features">Rhythm features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.feature.tempogram.html">librosa.feature.tempogram</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../feature.html#feature-manipulation">Feature manipulation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.feature.delta.html">librosa.feature.delta</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.feature.stack_memory.html">librosa.feature.stack_memory</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../feature.html#deprecated">Deprecated</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.feature.logfsgram.html">librosa.feature.logfsgram</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.feature.sync.html">librosa.feature.sync</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../onset.html">Onset detection</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../generated/librosa.onset.onset_detect.html">librosa.onset.onset_detect</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../generated/librosa.onset.onset_strength.html">librosa.onset.onset_strength</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../generated/librosa.onset.onset_strength_multi.html">librosa.onset.onset_strength_multi</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../beat.html">Beat and tempo</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../generated/librosa.beat.beat_track.html">librosa.beat.beat_track</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../generated/librosa.beat.estimate_tempo.html">librosa.beat.estimate_tempo</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../decompose.html">Spectrogram decomposition</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../generated/librosa.decompose.decompose.html">librosa.decompose.decompose</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../generated/librosa.decompose.hpss.html">librosa.decompose.hpss</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../effects.html">Effects</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../effects.html#harmonic-percussive-source-separation">Harmonic-percussive source separation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.effects.hpss.html">librosa.effects.hpss</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.effects.harmonic.html">librosa.effects.harmonic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.effects.percussive.html">librosa.effects.percussive</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../effects.html#time-and-frequency">Time and frequency</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.effects.time_stretch.html">librosa.effects.time_stretch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.effects.pitch_shift.html">librosa.effects.pitch_shift</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../effects.html#miscellaneous">Miscellaneous</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.effects.remix.html">librosa.effects.remix</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../output.html">Output</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../output.html#text-output">Text output</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.output.annotation.html">librosa.output.annotation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.output.times_csv.html">librosa.output.times_csv</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../output.html#audio-output">Audio output</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.output.write_wav.html">librosa.output.write_wav</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../output.html#deprecated">Deprecated</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.output.frames_csv.html">librosa.output.frames_csv</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../segment.html">Temporal segmentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../segment.html#recurrence-and-self-similarity">Recurrence and self-similarity</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.segment.recurrence_matrix.html">librosa.segment.recurrence_matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.segment.recurrence_to_lag.html">librosa.segment.recurrence_to_lag</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.segment.lag_to_recurrence.html">librosa.segment.lag_to_recurrence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.segment.timelag_filter.html">librosa.segment.timelag_filter</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../segment.html#temporal-clustering">Temporal clustering</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.segment.agglomerative.html">librosa.segment.agglomerative</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.segment.subsegment.html">librosa.segment.subsegment</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../segment.html#deprecated">Deprecated</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.segment.structure_feature.html">librosa.segment.structure_feature</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../util.html">Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../util.html#array-operations">Array operations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.frame.html">librosa.util.frame</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.pad_center.html">librosa.util.pad_center</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.fix_length.html">librosa.util.fix_length</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.fix_frames.html">librosa.util.fix_frames</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.index_to_slice.html">librosa.util.index_to_slice</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.sync.html">librosa.util.sync</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.axis_sort.html">librosa.util.axis_sort</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.normalize.html">librosa.util.normalize</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.sparsify_rows.html">librosa.util.sparsify_rows</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.buf_to_float.html">librosa.util.buf_to_float</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../util.html#matching">Matching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.match_intervals.html">librosa.util.match_intervals</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.match_events.html">librosa.util.match_events</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../util.html#miscellaneous">Miscellaneous</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.localmax.html">librosa.util.localmax</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.peak_pick.html">librosa.util.peak_pick</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../util.html#input-validation">Input validation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.valid_audio.html">librosa.util.valid_audio</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.valid_int.html">librosa.util.valid_int</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.valid_intervals.html">librosa.util.valid_intervals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../util.html#file-operations">File operations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.example_audio_file.html">librosa.util.example_audio_file</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.find_files.html">librosa.util.find_files</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../util.html#sklearn-integration">sklearn integration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.FeatureExtractor.html">librosa.util.FeatureExtractor</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../util.html#deprecated">Deprecated</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.util.buf_to_int.html">librosa.util.buf_to_int</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filters.html">Filters</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../filters.html#filter-bank-construction">Filter bank construction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.filters.dct.html">librosa.filters.dct</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.filters.mel.html">librosa.filters.mel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.filters.chroma.html">librosa.filters.chroma</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.filters.constant_q.html">librosa.filters.constant_q</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../filters.html#miscellaneous">Miscellaneous</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.filters.constant_q_lengths.html">librosa.filters.constant_q_lengths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.filters.cq_to_chroma.html">librosa.filters.cq_to_chroma</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.filters.window_bandwidth.html">librosa.filters.window_bandwidth</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../filters.html#deprecated">Deprecated</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../generated/librosa.filters.logfrequency.html">librosa.filters.logfrequency</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../cache.html">Caching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../cache.html#enabling-the-cache">Enabling the cache</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cache.html#cache-configuration">Cache configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cache.html#example">Example</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v0-4-1">v0.4.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v0-4-0">v0.4.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v0-3-1">v0.3.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v0-3-0">v0.3.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v0-2-1">v0.2.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v0-2-0">v0.2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#v0-1-0">v0.1.0</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">librosa</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>librosa.segment</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for librosa.segment</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/env python</span>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Temporal segmentation</span>
<span class="sd">=====================</span>

<span class="sd">Recurrence and self-similarity</span>
<span class="sd">------------------------------</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    recurrence_matrix</span>
<span class="sd">    recurrence_to_lag</span>
<span class="sd">    lag_to_recurrence</span>
<span class="sd">    timelag_filter</span>

<span class="sd">Temporal clustering</span>
<span class="sd">-------------------</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    agglomerative</span>
<span class="sd">    subsegment</span>

<span class="sd">Deprecated</span>
<span class="sd">----------</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    structure_feature</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">decorator</span> <span class="kn">import</span> <span class="n">decorator</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span>

<span class="kn">import</span> <span class="nn">sklearn</span>
<span class="kn">import</span> <span class="nn">sklearn.cluster</span>
<span class="kn">import</span> <span class="nn">sklearn.feature_extraction</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">.util.exceptions</span> <span class="kn">import</span> <span class="n">ParameterError</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;recurrence_matrix&#39;</span><span class="p">,</span>
           <span class="s">&#39;recurrence_to_lag&#39;</span><span class="p">,</span>
           <span class="s">&#39;lag_to_recurrence&#39;</span><span class="p">,</span>
           <span class="s">&#39;timelag_filter&#39;</span><span class="p">,</span>
           <span class="s">&#39;agglomerative&#39;</span><span class="p">,</span>
           <span class="s">&#39;subsegment&#39;</span><span class="p">,</span>
           <span class="c"># Deprecated functions</span>
           <span class="s">&#39;structure_feature&#39;</span><span class="p">]</span>


<span class="nd">@cache</span>
<span class="k">def</span> <span class="nf">__band_infinite</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">v_in</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">v_out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Construct a square, banded matrix `X` where</span>
<span class="sd">    `X[i, j] == v_in` if `|i - j| &lt;= width`</span>
<span class="sd">    `X[i, j] == v_out` if `|i - j| &gt; width`</span>

<span class="sd">    This is used to suppress nearby links in `recurrence_matrix`.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s">&#39;width cannot exceed n&#39;</span><span class="p">)</span>

    <span class="c"># Instantiate the matrix</span>
    <span class="n">band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c"># Fill the out-of-band values</span>
    <span class="n">band</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">v_out</span><span class="p">)</span>

    <span class="c"># Fill the in-band values</span>
    <span class="n">band</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices_from</span><span class="p">(</span><span class="n">band</span><span class="p">,</span> <span class="n">width</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v_in</span>
    <span class="n">band</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices_from</span><span class="p">(</span><span class="n">band</span><span class="p">,</span> <span class="o">-</span><span class="n">width</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v_in</span>

    <span class="k">return</span> <span class="n">band</span>


<span class="nd">@cache</span>
<div class="viewcode-block" id="recurrence_matrix"><a class="viewcode-back" href="../../generated/librosa.segment.recurrence_matrix.html#librosa.segment.recurrence_matrix">[docs]</a><span class="k">def</span> <span class="nf">recurrence_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s">&#39;sqeuclidean&#39;</span><span class="p">,</span>
                      <span class="n">sym</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute the binary recurrence matrix from a time-series.</span>

<span class="sd">    `rec[i,j] == True` if (and only if) (`data[:,i]`, `data[:,j]`) are</span>
<span class="sd">    k-nearest-neighbors and `|i-j| &gt;= width`</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        A feature matrix</span>

<span class="sd">    k : int &gt; 0 [scalar] or None</span>
<span class="sd">        the number of nearest-neighbors for each sample</span>

<span class="sd">        Default: `k = 2 * ceil(sqrt(t - 2 * width + 1))`,</span>
<span class="sd">        or `k = 2` if `t &lt;= 2 * width + 1`</span>

<span class="sd">    width : int &gt;= 1 [scalar]</span>
<span class="sd">        only link neighbors `(data[:, i], data[:, j])`</span>
<span class="sd">        if `|i-j| &gt;= width`</span>

<span class="sd">    metric : str</span>
<span class="sd">        Distance metric to use for nearest-neighbor calculation.</span>

<span class="sd">        See `scipy.spatial.distance.cdist()` for details.</span>

<span class="sd">    sym : bool [scalar]</span>
<span class="sd">        set `sym=True` to only link mutual nearest-neighbors</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to compute recurrence.</span>
<span class="sd">        By default, the last index (-1) is taken.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rec : np.ndarray [shape=(t,t), dtype=bool]</span>
<span class="sd">        Binary recurrence matrix</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.spatial.distance.cdist</span>
<span class="sd">    librosa.feature.stack_memory</span>
<span class="sd">    structure_feature</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Find nearest neighbors in MFCC space</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; mfcc = librosa.feature.mfcc(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; R = librosa.segment.recurrence_matrix(mfcc)</span>

<span class="sd">    Or fix the number of nearest neighbors to 5</span>

<span class="sd">    &gt;&gt;&gt; R = librosa.segment.recurrence_matrix(mfcc, k=5)</span>

<span class="sd">    Suppress neighbors within +- 7 samples</span>

<span class="sd">    &gt;&gt;&gt; R = librosa.segment.recurrence_matrix(mfcc, width=7)</span>

<span class="sd">    Use cosine similarity instead of Euclidean distance</span>

<span class="sd">    &gt;&gt;&gt; R = librosa.segment.recurrence_matrix(mfcc, metric=&#39;cosine&#39;)</span>

<span class="sd">    Require mutual nearest neighbors</span>

<span class="sd">    &gt;&gt;&gt; R = librosa.segment.recurrence_matrix(mfcc, sym=True)</span>

<span class="sd">    Plot the feature and recurrence matrices</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(10, 6))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(mfcc, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;MFCC&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(R, x_axis=&#39;time&#39;, y_axis=&#39;time&#39;,</span>
<span class="sd">    ...                          aspect=&#39;equal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;MFCC recurrence (symmetric)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c"># Swap observations to the first dimension and flatten the rest</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">width</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s">&#39;width must be at least 1&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="c"># Build the distance matrix</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>

    <span class="c"># Max out the diagonal band</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">__band_infinite</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>

    <span class="c"># build the recurrence plot</span>
    <span class="n">rec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="c"># get the k nearest neighbors for each point</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">])[:</span><span class="n">k</span><span class="p">]:</span>
            <span class="n">rec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="c"># symmetrize</span>
    <span class="k">if</span> <span class="n">sym</span><span class="p">:</span>
        <span class="n">rec</span> <span class="o">=</span> <span class="n">rec</span> <span class="o">*</span> <span class="n">rec</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">rec</span>

</div>
<div class="viewcode-block" id="recurrence_to_lag"><a class="viewcode-back" href="../../generated/librosa.segment.recurrence_to_lag.html#librosa.segment.recurrence_to_lag">[docs]</a><span class="k">def</span> <span class="nf">recurrence_to_lag</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Convert a recurrence matrix into a lag matrix.</span>

<span class="sd">        `lag[i, j] == rec[i+j, j]`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rec : np.ndarray, [shape=(n, n)]</span>
<span class="sd">        A (binary) recurrence matrix, as returned by `recurrence_matrix`</span>

<span class="sd">    pad : bool</span>
<span class="sd">        If False, `lag` matrix is square, which is equivalent to</span>
<span class="sd">        assuming that the signal repeats itself indefinitely.</span>

<span class="sd">        If True, `lag` is padded with `n` zeros, which eliminates</span>
<span class="sd">        the assumption of repetition.</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to apply the recurrence-to-lag conversion</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lag : np.ndarray [shape=(2*n, n) or (n, n)]</span>
<span class="sd">        The recurrence matrix in (lag, time) coordinates</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError : if `rec` is non-square</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    recurrence_matrix</span>
<span class="sd">    lag_to_recurrence</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; mfccs = librosa.feature.mfcc(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; recurrence = librosa.segment.recurrence_matrix(mfccs)</span>
<span class="sd">    &gt;&gt;&gt; lag_pad = librosa.segment.recurrence_to_lag(recurrence, pad=True)</span>
<span class="sd">    &gt;&gt;&gt; lag_nopad = librosa.segment.recurrence_to_lag(recurrence, pad=False)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(8, 4))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(lag_pad, x_axis=&#39;time&#39;, y_axis=&#39;lag&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Lag (zero-padded)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(lag_nopad, x_axis=&#39;time&#39;, y_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Lag (no padding)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rec</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s">&#39;non-square recurrence matrix shape: &#39;</span>
                             <span class="s">&#39;{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">pad</span><span class="p">:</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="n">padding</span><span class="p">[(</span><span class="mi">1</span><span class="o">-</span><span class="n">axis</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">lag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;constant&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lag</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">idx_slice</span> <span class="o">=</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">]</span> <span class="o">*</span> <span class="n">lag</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">idx_slice</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">lag</span><span class="p">[</span><span class="n">idx_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">lag</span><span class="p">[</span><span class="n">idx_slice</span><span class="p">],</span> <span class="o">-</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">lag</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

</div>
<div class="viewcode-block" id="lag_to_recurrence"><a class="viewcode-back" href="../../generated/librosa.segment.lag_to_recurrence.html#librosa.segment.lag_to_recurrence">[docs]</a><span class="k">def</span> <span class="nf">lag_to_recurrence</span><span class="p">(</span><span class="n">lag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Convert a lag matrix into a recurrence matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lag : np.ndarray [shape=(2*n, n) or (n, n)]</span>
<span class="sd">        A lag matrix, as produced by `recurrence_to_lag`</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to apply the recurrence-to-lag conversion</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rec : np.ndarray [shape=(n, n)]</span>
<span class="sd">        A recurrence matrix in (time, time) coordinates</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError : if `lag` does not have the correct shape</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    recurrence_to_lag</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; mfccs = librosa.feature.mfcc(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; recurrence = librosa.segment.recurrence_matrix(mfccs)</span>
<span class="sd">    &gt;&gt;&gt; lag_pad = librosa.segment.recurrence_to_lag(recurrence, pad=True)</span>
<span class="sd">    &gt;&gt;&gt; lag_nopad = librosa.segment.recurrence_to_lag(recurrence, pad=False)</span>
<span class="sd">    &gt;&gt;&gt; rec_pad = librosa.segment.lag_to_recurrence(lag_pad)</span>
<span class="sd">    &gt;&gt;&gt; rec_nopad = librosa.segment.lag_to_recurrence(lag_nopad)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(8, 4))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 2, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(lag_pad, x_axis=&#39;time&#39;, y_axis=&#39;lag&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Lag (zero-padded)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(lag_nopad, x_axis=&#39;time&#39;, y_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Lag (no padding)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 2, 3)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(rec_pad, x_axis=&#39;time&#39;, y_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Recurrence (with padding)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 2, 4)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(rec_nopad, x_axis=&#39;time&#39;, y_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Recurrence (without padding)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lag</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="p">(</span><span class="n">lag</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">lag</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span>
                         <span class="n">lag</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lag</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s">&#39;Invalid lag matrix shape: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lag</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c"># Since lag must be 2-dimensional, abs(axis) = axis</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">lag</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">lag</span> <span class="o">=</span> <span class="n">lag</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">idx_slice</span> <span class="o">=</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">]</span> <span class="o">*</span> <span class="n">lag</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">idx_slice</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">lag</span><span class="p">[</span><span class="n">idx_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">lag</span><span class="p">[</span><span class="n">idx_slice</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>

    <span class="n">sub_slice</span> <span class="o">=</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">]</span> <span class="o">*</span> <span class="n">lag</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">sub_slice</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">lag</span><span class="p">[</span><span class="n">sub_slice</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

</div>
<div class="viewcode-block" id="timelag_filter"><a class="viewcode-back" href="../../generated/librosa.segment.timelag_filter.html#librosa.segment.timelag_filter">[docs]</a><span class="k">def</span> <span class="nf">timelag_filter</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Filtering in the time-lag domain.</span>

<span class="sd">    This is primarily useful for adapting image filters to operate on</span>
<span class="sd">    `structure_feature` output.</span>

<span class="sd">    Using `timelag_filter` is equivalent to the following sequence of</span>
<span class="sd">    operations:</span>

<span class="sd">    &gt;&gt;&gt; data_tl = librosa.segment.recurrence_to_lag(data)</span>
<span class="sd">    &gt;&gt;&gt; data_filtered_tl = function(data_tl)</span>
<span class="sd">    &gt;&gt;&gt; data_filtered = librosa.segment.lag_to_recurrence(data_filtered_tl)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    function : callable</span>
<span class="sd">        The filtering function to wrap, e.g., `scipy.ndimage.median_filter`</span>

<span class="sd">    pad : bool</span>
<span class="sd">        Whether to zero-pad the structure feature matrix</span>

<span class="sd">    index : int &gt;= 0</span>
<span class="sd">        If `function` accepts input data as a positional argument, it should be</span>
<span class="sd">        indexed by `index`</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    wrapped_function : callable</span>
<span class="sd">        A new filter function which applies in time-lag space rather than</span>
<span class="sd">        time-time space.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    structure_feature</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Apply a 5-bin median filter to the diagonal of a recurrence matrix</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; mfcc = librosa.feature.mfcc(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; rec = librosa.segment.recurrence_matrix(mfcc, sym=True)</span>
<span class="sd">    &gt;&gt;&gt; from scipy.ndimage import median_filter</span>
<span class="sd">    &gt;&gt;&gt; diagonal_median = librosa.segment.timelag_filter(median_filter)</span>
<span class="sd">    &gt;&gt;&gt; rec_filtered = diagonal_median(rec, size=(1, 5), mode=&#39;mirror&#39;)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(rec, x_axis=&#39;time&#39;, y_axis=&#39;time&#39;,</span>
<span class="sd">    ...                          aspect=&#39;equal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Raw recurrence matrix&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(rec_filtered, x_axis=&#39;time&#39;, y_axis=&#39;time&#39;,</span>
<span class="sd">    ...                          aspect=&#39;equal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Filtered recurrence matrix&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="nd">@cache</span>
    <span class="k">def</span> <span class="nf">__my_filter</span><span class="p">(</span><span class="n">wrapped_f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Decorator to wrap the filter&#39;&#39;&#39;</span>
        <span class="c"># Map the input data into time-lag space</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="n">args</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">recurrence_to_lag</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">)</span>

        <span class="c"># Apply the filtering function</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">wrapped_f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Map back into time-time and return</span>
        <span class="k">return</span> <span class="n">lag_to_recurrence</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">decorator</span><span class="p">(</span><span class="n">__my_filter</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>

</div>
<span class="nd">@cache</span>
<div class="viewcode-block" id="subsegment"><a class="viewcode-back" href="../../generated/librosa.segment.subsegment.html#librosa.segment.subsegment">[docs]</a><span class="k">def</span> <span class="nf">subsegment</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">frames</span><span class="p">,</span> <span class="n">n_segments</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Sub-divide a segmentation by feature clustering.</span>

<span class="sd">    Given a set of frame boundaries (`frames`), and a data matrix (`data`),</span>
<span class="sd">    each successive interval defined by `frames` is partitioned into</span>
<span class="sd">    `n_segments` by constrained agglomerative clustering.</span>

<span class="sd">    .. note::</span>
<span class="sd">        If an interval spans fewer than `n_segments` frames, then each</span>
<span class="sd">        frame becomes a sub-segment.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        Data matrix to use in clustering</span>

<span class="sd">    frames : np.ndarray [shape=(n_boundaries,)], dtype=int, non-negative]</span>
<span class="sd">        Array of beat or segment boundaries, as provided by</span>
<span class="sd">        `librosa.beat.beat_track`,</span>
<span class="sd">        `librosa.onset.onset_detect`,</span>
<span class="sd">        or `agglomerative`.</span>

<span class="sd">    n_segments : int &gt; 0</span>
<span class="sd">        Maximum number of frames to sub-divide each interval.</span>

<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to apply the segmentation.</span>
<span class="sd">        By default, the last index (-1) is taken.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    boundaries : np.ndarray [shape=(n_subboundaries,)]</span>
<span class="sd">        List of sub-divided segment boundaries</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    agglomerative : Temporal segmentation</span>
<span class="sd">    librosa.onset.onset_detect : Onset detection</span>
<span class="sd">    librosa.beat.beat_track : Beat tracking</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Load audio, detect beat frames, and subdivide in twos by CQT</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(), duration=15)</span>
<span class="sd">    &gt;&gt;&gt; tempo, beats = librosa.beat.beat_track(y=y, sr=sr, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; cqt = librosa.cqt(y, sr=sr, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; subseg = librosa.segment.subsegment(cqt, beats, n_segments=2)</span>
<span class="sd">    &gt;&gt;&gt; subseg</span>
<span class="sd">    array([  0,   2,   4,  21,  23,  26,  43,  55,  63,  72,  83,</span>
<span class="sd">            97, 102, 111, 122, 137, 142, 153, 162, 180, 182, 185,</span>
<span class="sd">           202, 210, 221, 231, 241, 256, 261, 271, 281, 296, 301,</span>
<span class="sd">           310, 320, 339, 341, 344, 361, 368, 382, 389, 401, 416,</span>
<span class="sd">           420, 430, 436, 451, 456, 465, 476, 489, 496, 503, 515,</span>
<span class="sd">           527, 535, 544, 553, 558, 571, 578, 590, 607, 609, 638])</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.logamplitude(cqt**2,</span>
<span class="sd">    ...                                               ref_power=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;cqt_hz&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.vlines(beats, 0, cqt.shape[0], color=&#39;r&#39;, alpha=0.5,</span>
<span class="sd">    ...            label=&#39;Beats&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.vlines(subseg, 0, cqt.shape[0], color=&#39;b&#39;, linestyle=&#39;--&#39;,</span>
<span class="sd">    ...            alpha=0.5, label=&#39;Sub-beats&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True, shadow=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;CQT + Beat and sub-beat markers&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">frames</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">fix_frames</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">pad</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_segments</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s">&#39;n_segments must be a positive integer&#39;</span><span class="p">)</span>

    <span class="n">boundaries</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">idx_slices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">for</span> <span class="n">seg_start</span><span class="p">,</span> <span class="n">seg_end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">frames</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">idx_slices</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">seg_start</span><span class="p">,</span> <span class="n">seg_end</span><span class="p">)</span>
        <span class="n">boundaries</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">seg_start</span> <span class="o">+</span> <span class="n">agglomerative</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">idx_slices</span><span class="p">],</span>
                                                    <span class="nb">min</span><span class="p">(</span><span class="n">seg_end</span> <span class="o">-</span> <span class="n">seg_start</span><span class="p">,</span> <span class="n">n_segments</span><span class="p">),</span>
                                                    <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="agglomerative"><a class="viewcode-back" href="../../generated/librosa.segment.agglomerative.html#librosa.segment.agglomerative">[docs]</a><span class="k">def</span> <span class="nf">agglomerative</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">clusterer</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bottom-up temporal segmentation.</span>

<span class="sd">    Use a temporally-constrained agglomerative clustering routine to partition</span>
<span class="sd">    `data` into `k` contiguous segments.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data     : np.ndarray</span>
<span class="sd">        data to cluster</span>

<span class="sd">    k        : int &gt; 0 [scalar]</span>
<span class="sd">        number of segments to produce</span>

<span class="sd">    clusterer : sklearn.cluster.AgglomerativeClustering, optional</span>
<span class="sd">        An optional AgglomerativeClustering object.</span>
<span class="sd">        If `None`, a constrained Ward object is instantiated.</span>

<span class="sd">    axis : int</span>
<span class="sd">        axis along which to cluster.</span>
<span class="sd">        By default, the last axis (-1) is chosen.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    boundaries : np.ndarray [shape=(k,)]</span>
<span class="sd">        left-boundaries (frame numbers) of detected segments. This</span>
<span class="sd">        will always include `0` as the first left-boundary.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sklearn.cluster.AgglomerativeClustering</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Cluster by chroma similarity, break into 20 segments</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(), duration=15)</span>
<span class="sd">    &gt;&gt;&gt; chroma = librosa.feature.chroma_cqt(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; boundary_frames = librosa.segment.agglomerative(chroma, 20)</span>
<span class="sd">    &gt;&gt;&gt; librosa.frames_to_time(boundary_frames, sr=sr)</span>
<span class="sd">    array([  0.   ,   1.672,   2.322,   2.624,   3.251,   3.506,</span>
<span class="sd">             4.18 ,   5.387,   6.014,   6.293,   6.943,   7.198,</span>
<span class="sd">             7.848,   9.033,   9.706,   9.961,  10.635,  10.89 ,</span>
<span class="sd">            11.54 ,  12.539])</span>

<span class="sd">    Plot the segmentation against the spectrogram</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))**2</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.logamplitude(S, ref_power=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.vlines(boundary_frames, 0, S.shape[0], color=&#39;r&#39;, alpha=0.9,</span>
<span class="sd">    ...            label=&#39;Segment boundaries&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True, shadow=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Make sure we have at least two dimensions</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c"># Swap data index to position 0</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c"># Flatten the features</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">clusterer</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># Connect the temporal connectivity graph</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">feature_extraction</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">grid_to_graph</span><span class="p">(</span><span class="n">n_x</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                                                              <span class="n">n_y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_z</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># Instantiate the clustering object</span>
        <span class="n">clusterer</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">AgglomerativeClustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
                                                            <span class="n">connectivity</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span>
                                                            <span class="n">memory</span><span class="o">=</span><span class="n">cache</span><span class="p">)</span>

    <span class="c"># Fit the model</span>
    <span class="n">clusterer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c"># Find the change points from the labels</span>
    <span class="n">boundaries</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">boundaries</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">clusterer</span><span class="o">.</span><span class="n">labels_</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)</span>


<span class="c"># Deprecated functions</span>
</div>
<span class="nd">@util.decorators.deprecated</span><span class="p">(</span><span class="s">&#39;0.4&#39;</span><span class="p">,</span> <span class="s">&#39;0.5&#39;</span><span class="p">)</span>
<span class="nd">@cache</span>
<div class="viewcode-block" id="structure_feature"><a class="viewcode-back" href="../../generated/librosa.segment.structure_feature.html#librosa.segment.structure_feature">[docs]</a><span class="k">def</span> <span class="nf">structure_feature</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute the structure feature from a recurrence matrix.</span>

<span class="sd">    The i&#39;th column of the recurrence matrix is shifted up by i.</span>
<span class="sd">    The resulting matrix is indexed horizontally by time,</span>
<span class="sd">    and vertically by lag.</span>

<span class="sd">    .. warning:: Deprected in librosa 0.4</span>
<span class="sd">                 Functionality is superseded by</span>
<span class="sd">                 `librosa.segment.recurrence_to_lag` and</span>
<span class="sd">                 `librosa.segment.lag_to_recurrence`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rec   : np.ndarray [shape=(t,t) or shape=(2*t, t)]</span>
<span class="sd">        recurrence matrix or pre-computed structure feature</span>

<span class="sd">    pad : bool [scalar]</span>
<span class="sd">        Pad the matrix with `t` rows of zeros to avoid looping.</span>

<span class="sd">    inverse : bool [scalar]</span>
<span class="sd">        Unroll the opposite direction. This is useful for converting</span>
<span class="sd">        structure features back into recurrence plots.</span>

<span class="sd">        .. note: Reversing with `pad==True` will truncate the</span>
<span class="sd">            inferred padding.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    struct : np.ndarray [shape=(2*t, t) or shape=(t, t)]</span>
<span class="sd">        `struct[i, t]` = the recurrence at time `t` with lag `i`.</span>

<span class="sd">        .. note:: negative lag values are supported by wrapping to the</span>
<span class="sd">            end of the array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    recurrence_matrix : build a recurrence matrix from feature vectors</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Build the structure feature over mfcc similarity</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; mfccs = librosa.feature.mfcc(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; recurrence = librosa.segment.recurrence_matrix(mfccs)</span>
<span class="sd">    &gt;&gt;&gt; struct = librosa.segment.structure_feature(recurrence)</span>


<span class="sd">    Invert the structure feature to get a recurrence matrix</span>

<span class="sd">    &gt;&gt;&gt; recurrence_2 = librosa.segment.structure_feature(struct,</span>
<span class="sd">    ...                                                  inverse=True)</span>

<span class="sd">    Display recurrence in time-time and time-lag space</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(10, 5))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(recurrence, aspect=&#39;equal&#39;, x_axis=&#39;time&#39;,</span>
<span class="sd">    ...                          y_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Recurrence (time-time)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(struct, aspect=&#39;auto&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Lag&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Structure feature&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lag_to_recurrence</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">recurrence_to_lag</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">)</span></div>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, librosa development team.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.4.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>