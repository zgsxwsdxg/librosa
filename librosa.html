<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Package reference &mdash; librosa 0.3.1 documentation</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootswatch-3.2.0/yeti/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.3.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.2.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="librosa 0.3.1 documentation" href="index.html" />
    <link rel="next" title="Glossary" href="glossary.html" />
    <link rel="prev" title="Tutorial" href="tutorial.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          LibROSA</a>
        <span class="navbar-text navbar-version pull-left"><b>0.3</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Package reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Package reference</a><ul>
<li><a class="reference internal" href="#module-librosa.beat"><tt class="docutils literal"><span class="pre">Beat</span> <span class="pre">tracking</span></tt></a></li>
<li><a class="reference internal" href="#module-librosa.chord"><tt class="docutils literal"><span class="pre">Chord</span> <span class="pre">models</span></tt></a></li>
<li><a class="reference internal" href="#module-librosa.core"><tt class="docutils literal"><span class="pre">Core</span> <span class="pre">functionality</span></tt></a></li>
<li><a class="reference internal" href="#module-librosa.decompose"><tt class="docutils literal"><span class="pre">Spectrogram</span> <span class="pre">decomposition</span></tt></a></li>
<li><a class="reference internal" href="#display"><tt class="docutils literal"><span class="pre">Display</span></tt></a></li>
<li><a class="reference internal" href="#effects"><tt class="docutils literal"><span class="pre">Effects</span></tt></a></li>
<li><a class="reference internal" href="#module-librosa.feature"><tt class="docutils literal"><span class="pre">Feature</span> <span class="pre">extraction</span></tt></a></li>
<li><a class="reference internal" href="#module-librosa.filters"><tt class="docutils literal"><span class="pre">Filter</span> <span class="pre">banks</span></tt></a></li>
<li><a class="reference internal" href="#module-librosa.onset"><tt class="docutils literal"><span class="pre">Onset</span> <span class="pre">detection</span></tt></a></li>
<li><a class="reference internal" href="#output"><tt class="docutils literal"><span class="pre">Output</span></tt></a></li>
<li><a class="reference internal" href="#module-librosa.segment"><tt class="docutils literal"><span class="pre">Segmentation</span></tt></a></li>
<li><a class="reference internal" href="#module-librosa.util"><tt class="docutils literal"><span class="pre">Utilities</span></tt></a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="tutorial.html" title="Previous Chapter: Tutorial"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm">&laquo; Tutorial</span>
    </a>
  </li>
  <li>
    <a href="glossary.html" title="Next Chapter: Glossary"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm">Glossary &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="package-reference">
<h1>Package reference<a class="headerlink" href="#package-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-librosa.beat">
<span id="beat-tracking"></span><span id="beat"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">Beat</span> <span class="pre">tracking</span></tt><a class="headerlink" href="#module-librosa.beat" title="Permalink to this headline">¶</a></h2>
<p>Beat tracking and tempo estimation</p>
<dl class="function">
<dt id="librosa.beat.beat_track">
<tt class="descclassname">librosa.beat.</tt><tt class="descname">beat_track</tt><big>(</big><em>y=None</em>, <em>sr=22050</em>, <em>onset_envelope=None</em>, <em>hop_length=64</em>, <em>start_bpm=120.0</em>, <em>tightness=400</em>, <em>trim=True</em>, <em>bpm=None</em><big>)</big><a class="headerlink" href="#librosa.beat.beat_track" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic programming beat tracker.</p>
<dl class="docutils">
<dt>Beats are detected in three stages:</dt>
<dd><ol class="first last arabic simple">
<li>Measure onset strength</li>
<li>Estimate tempo from onset correlation</li>
<li>Pick peaks in onset strength approximately consistent with estimated
tempo</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Track beats using time series input</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span><span class="p">,</span> <span class="n">beats</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">beat_track</span><span class="p">(</span> <span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Track beats using a pre-computed onset envelope</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">onset_env</span>    <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">onset_strength</span><span class="p">(</span><span class="n">y</span><span class="p">,</span>
<span class="go">                                                sr=sr,</span>
<span class="go">                                                hop_length=hop_length)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span><span class="p">,</span> <span class="n">beats</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">beat_track</span><span class="p">(</span><span class="n">onset_envelope</span><span class="o">=</span><span class="n">onset_env</span><span class="p">,</span>
<span class="go">                                           sr=sr,</span>
<span class="go">                                           hop_length=hop_length)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd><p class="first last">audio time series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">sampling rate of <tt class="docutils literal"><span class="pre">y</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>onset_envelope <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd><p class="first last">(optional) pre-computed onset strength envelope
See <a class="reference internal" href="#librosa.onset.onset_strength" title="librosa.onset.onset_strength"><tt class="xref py py-func docutils literal"><span class="pre">librosa.onset.onset_strength()</span></tt></a></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">number of audio samples between successive <tt class="docutils literal"><span class="pre">onset_envelope</span></tt> values</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>start_bpm <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd><p class="first last">initial guess for the tempo estimator (in beats per minute)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>tightness <span class="classifier-delimiter">:</span> <span class="classifier">float [scalar]</span></dt>
<dd><p class="first last">tightness of beat distribution around tempo</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>trim <span class="classifier-delimiter">:</span> <span class="classifier">bool [scalar]</span></dt>
<dd><p class="first last">trim leading/trailing beats with weak onsets</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bpm <span class="classifier-delimiter">:</span> <span class="classifier">float [scalar]</span></dt>
<dd><p class="first last">(optional) If provided, use <tt class="docutils literal"><span class="pre">bpm</span></tt> as the tempo instead of
estimating it from <tt class="docutils literal"><span class="pre">onsets</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>tempo <span class="classifier-delimiter">:</span> <span class="classifier">float [scalar]</span></dt>
<dd><p class="first last">estimated global tempo (in beats per minute)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(m,)]</span></dt>
<dd><p class="first last">frame numbers of estimated beat events</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">if neither <tt class="docutils literal"><span class="pre">y</span></tt> nor <tt class="docutils literal"><span class="pre">onset_envelope</span></tt> are provided</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If no onset strength could be detected, beat_tracker estimates 0 BPM
and returns an empty list.</p>
<ul class="last simple">
<li><a class="reference external" href="http://labrosa.ee.columbia.edu/projects/beattrack/">http://labrosa.ee.columbia.edu/projects/beattrack/</a></li>
<li>Ellis, Daniel PW. &#8220;Beat tracking by dynamic programming.&#8221;
Journal of New Music Research 36.1 (2007): 51-60.</li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.beat.estimate_tempo">
<tt class="descclassname">librosa.beat.</tt><tt class="descname">estimate_tempo</tt><big>(</big><em>onset_envelope</em>, <em>sr=22050</em>, <em>hop_length=64</em>, <em>start_bpm=120</em>, <em>std_bpm=1.0</em>, <em>ac_size=4.0</em>, <em>duration=90.0</em>, <em>offset=0.0</em><big>)</big><a class="headerlink" href="#librosa.beat.estimate_tempo" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the tempo (beats per minute) from an onset envelope</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">estimate_tempo</span><span class="p">(</span><span class="n">onset_envelope</span><span class="p">,</span>
<span class="go">                                        sr=sr,</span>
<span class="go">                                        hop_length=hop_length)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>onset_envelope <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">onset strength envelope
See <a class="reference internal" href="#librosa.onset.onset_strength" title="librosa.onset.onset_strength"><tt class="xref py py-func docutils literal"><span class="pre">librosa.onset.onset_strength()</span></tt></a> for details.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr: <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">sampling rate of the time series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">hop length of the time series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>start_bpm <span class="classifier-delimiter">:</span> <span class="classifier">float [scalar]</span></dt>
<dd><p class="first last">initial guess of the BPM</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>std_bpm <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd><p class="first last">standard deviation of tempo distribution</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ac_size <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd><p class="first last">length (in seconds) of the auto-correlation window</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>duration <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd><p class="first last">length of signal (in seconds) to use in estimating tempo</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd><p class="first last">offset (in seconds) of signal sample to use in estimating tempo</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>tempo <span class="classifier-delimiter">:</span> <span class="classifier">float [scalar]</span></dt>
<dd><p class="first last">estimated tempo (beats per minute)</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-librosa.chord">
<span id="chord-models"></span><span id="chord"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">Chord</span> <span class="pre">models</span></tt><a class="headerlink" href="#module-librosa.chord" title="Permalink to this headline">¶</a></h2>
<p>Chord model and helper utilities</p>
<dl class="function">
<dt id="librosa.chord.beats_to_chords">
<tt class="descclassname">librosa.chord.</tt><tt class="descname">beats_to_chords</tt><big>(</big><em>beat_times</em>, <em>chord_times</em>, <em>chord_labels</em><big>)</big><a class="headerlink" href="#librosa.chord.beats_to_chords" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate lab-style annotations to a list of beat timings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>beat_times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n, 2)]</span></dt>
<dd><p class="first last">The time range (in seconds) for beat intervals.
The <tt class="docutils literal"><span class="pre">i</span></tt> th beat spans time <tt class="docutils literal"><span class="pre">beat_times[i,</span> <span class="pre">0]</span></tt>
to <tt class="docutils literal"><span class="pre">beat_times[i,</span> <span class="pre">1]</span></tt>.
<tt class="docutils literal"><span class="pre">beat_times[0,</span> <span class="pre">0]</span></tt> should be 0, <tt class="docutils literal"><span class="pre">beat_times[-1,</span> <span class="pre">1]</span></tt> should
be the track duration.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>chord_times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(m, 2)]</span></dt>
<dd><p class="first last">The time range (in seconds) for the <tt class="docutils literal"><span class="pre">i</span></tt> th annotation is
<tt class="docutils literal"><span class="pre">chord_times[i,</span> <span class="pre">0]</span></tt> to <tt class="docutils literal"><span class="pre">chord_times[i,</span> <span class="pre">1]</span></tt>.
<tt class="docutils literal"><span class="pre">chord_times[0,</span> <span class="pre">0]</span></tt> should be 0, <tt class="docutils literal"><span class="pre">chord_times[-1,</span> <span class="pre">1]</span></tt> should
be the track duration.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>chord_labels <span class="classifier-delimiter">:</span> <span class="classifier">list of str [shape=(m,)]</span></dt>
<dd><p class="first last">List of annotation strings associated with <tt class="docutils literal"><span class="pre">chord_times</span></tt></p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>beat_labels <span class="classifier-delimiter">:</span> <span class="classifier">list of str [shape=(n,)]</span></dt>
<dd><p class="first last">Chord annotations at the beat level.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="librosa.chord.ChordHMM">
<em class="property">class </em><tt class="descclassname">librosa.chord.</tt><tt class="descname">ChordHMM</tt><big>(</big><em>chord_names</em>, <em>covariance_type='full'</em>, <em>startprob=None</em>, <em>transmat=None</em>, <em>startprob_prior=None</em>, <em>transmat_prior=None</em>, <em>algorithm='viterbi'</em>, <em>means_prior=None</em>, <em>means_weight=0</em>, <em>covars_prior=0.01</em>, <em>covars_weight=1</em>, <em>random_state=None</em><big>)</big><a class="headerlink" href="#librosa.chord.ChordHMM" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">sklearn.hmm.GaussianHMM</span></tt></p>
<p>Gaussian-HMM chord model</p>
<dl class="method">
<dt id="librosa.chord.ChordHMM.predict_chords">
<tt class="descname">predict_chords</tt><big>(</big><em>obs</em><big>)</big><a class="headerlink" href="#librosa.chord.ChordHMM.predict_chords" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict chords from an observation sequence</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>obs <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n, d)]</span></dt>
<dd><p class="first last">Observation sequence, e.g., transposed beat-synchronous
chromagram.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">list of str [shape=(n,)]</span></dt>
<dd><p class="first last">For each row of <tt class="docutils literal"><span class="pre">obs</span></tt>, the most likely chord label.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="librosa.chord.ChordHMM.fit">
<tt class="descname">fit</tt><big>(</big><em>obs</em>, <em>labels</em><big>)</big><a class="headerlink" href="#librosa.chord.ChordHMM.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Supervised training.</p>
<ul>
<li><dl class="first docutils">
<dt>obs <span class="classifier-delimiter">:</span> <span class="classifier">list, obs[i]</span> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_beats, n_features)]</span></dt>
<dd><p class="first last">A collection of observation sequences, e.g., <tt class="docutils literal"><span class="pre">obs[i]</span></tt> is a
chromagram</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">list-like (n_songs)</span></dt>
<dd><ul class="first simple">
<li><tt class="docutils literal"><span class="pre">labels[i]</span></tt> is list-like, (n_beats)</li>
<li><tt class="docutils literal"><span class="pre">labels[i][t]</span></tt> is a str</li>
</ul>
<p class="last">list or array of labels for the observations</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-librosa.core">
<span id="core-functionality"></span><span id="core"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">Core</span> <span class="pre">functionality</span></tt><a class="headerlink" href="#module-librosa.core" title="Permalink to this headline">¶</a></h2>
<p>Core IO, DSP and utility functions.</p>
<dl class="function">
<dt id="librosa.core.load">
<tt class="descclassname">librosa.core.</tt><tt class="descname">load</tt><big>(</big><em>path</em>, <em>sr=22050</em>, <em>mono=True</em>, <em>offset=0.0</em>, <em>duration=None</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em><big>)</big><a class="headerlink" href="#librosa.core.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load an audio file as a floating point time series.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Load a wav file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.wav&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Load a wav file and resample to 11 KHz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.wav&#39;</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">11025</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Load 5 seconds of a wav file, starting 15 seconds in</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.wav&#39;</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mf">15.0</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>path <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">path to the input file.
Any format supported by <tt class="docutils literal"><span class="pre">audioread</span></tt> will work.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">target sampling rate
&#8216;None&#8217; uses the native sampling rate</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>mono <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">convert signal to mono</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">start reading after this time (in seconds)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>duration <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">only load up to this much audio (in seconds)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">numeric type</span></dt>
<dd><p class="first last">data type of <tt class="docutils literal"><span class="pre">y</span></tt></p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,) or (n, 2)]</span></dt>
<dd><p class="first last">audio time series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">sampling rate of <tt class="docutils literal"><span class="pre">y</span></tt></p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.resample">
<tt class="descclassname">librosa.core.</tt><tt class="descname">resample</tt><big>(</big><em>y</em>, <em>orig_sr</em>, <em>target_sr</em>, <em>res_type='sinc_fastest'</em>, <em>fix=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.core.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample a time series from orig_sr to target_sr</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Downsample from 22 KHz to 8 KHz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span>   <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.wav&#39;</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_8k</span>    <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">audio time series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>orig_sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">original sampling rate of <tt class="docutils literal"><span class="pre">y</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>target_sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">target sampling rate</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>res_type <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">resample type (see note)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fix <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">adjust the length of the resampled signal to be of size exactly
<tt class="docutils literal"><span class="pre">ceil(target_sr</span> <span class="pre">*</span> <span class="pre">len(y)</span> <span class="pre">/</span> <span class="pre">orig_sr)</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwargs</em></dt>
<dd><p class="first last">If <tt class="docutils literal"><span class="pre">fix==True</span></tt>, additional keyword arguments to pass to
<a class="reference internal" href="#librosa.util.fix_length" title="librosa.util.fix_length"><tt class="xref py py-func docutils literal"><span class="pre">librosa.util.fix_length()</span></tt></a>.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>y_hat <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n * target_sr / orig_sr,)]</span></dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">y</span></tt> resampled from <tt class="docutils literal"><span class="pre">orig_sr</span></tt> to <tt class="docutils literal"><span class="pre">target_sr</span></tt></p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <cite>scikits.samplerate</cite> is installed, <a class="reference internal" href="#librosa.core.resample" title="librosa.core.resample"><tt class="xref py py-func docutils literal"><span class="pre">librosa.core.resample()</span></tt></a>
will use <tt class="docutils literal"><span class="pre">res_type</span></tt>.
Otherwise, it will fall back on <cite>scipy.signal.resample</cite></p>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.get_duration">
<tt class="descclassname">librosa.core.</tt><tt class="descname">get_duration</tt><big>(</big><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>n_fft=2048</em>, <em>hop_length=512</em>, <em>center=True</em><big>)</big><a class="headerlink" href="#librosa.core.get_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the duration (in seconds) of an audio time series or STFT matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Load the example audio file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">get_duration</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">61.38775510204081</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or compute duration from an STFT matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">get_duration</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or a non-centered STFT matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S_left</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">get_duration</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S_left</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd><p class="first last">Audio time series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Audio sampling rate</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)] or None</span></dt>
<dd><p class="first last">STFT matrix, or any STFT-derived matrix (e.g., chromagram
or mel spectrogram).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">FFT window size for <tt class="docutils literal"><span class="pre">S</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [ scalar]</span></dt>
<dd><p class="first last">number of audio samples between columns of <tt class="docutils literal"><span class="pre">S</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <tt class="docutils literal"><span class="pre">True</span></tt>, <tt class="docutils literal"><span class="pre">S[:,</span> <span class="pre">t]</span></tt> is centered at <tt class="docutils literal"><span class="pre">y[t</span> <span class="pre">*</span> <span class="pre">hop_length]</span></tt>.</li>
<li>If <tt class="docutils literal"><span class="pre">False</span></tt>, then <tt class="docutils literal"><span class="pre">S[f,</span> <span class="pre">t]</span></tt> <em>begins</em> at <tt class="docutils literal"><span class="pre">y[t</span> <span class="pre">*</span> <span class="pre">hop_length]</span></tt></li>
</ul>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>d <span class="classifier-delimiter">:</span> <span class="classifier">float &gt;= 0</span></dt>
<dd><p class="first last">Duration (in seconds) of the input time series or spectrogram.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.stft">
<tt class="descclassname">librosa.core.</tt><tt class="descname">stft</tt><big>(</big><em>y</em>, <em>n_fft=2048</em>, <em>hop_length=None</em>, <em>win_length=None</em>, <em>window=None</em>, <em>center=True</em>, <em>dtype=&lt;type 'numpy.complex64'&gt;</em><big>)</big><a class="headerlink" href="#librosa.core.stft" title="Permalink to this definition">¶</a></dt>
<dd><p>Short-time Fourier transform (STFT)</p>
<dl class="docutils">
<dt>Returns a complex-valued matrix D such that</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">np.abs(D[f,</span> <span class="pre">t])</span></tt> is the magnitude of frequency bin <tt class="docutils literal"><span class="pre">f</span></tt>
at frame <tt class="docutils literal"><span class="pre">t</span></tt></li>
<li><tt class="docutils literal"><span class="pre">np.angle(D[f,</span> <span class="pre">t])</span></tt> is the phase of frequency bin <tt class="docutils literal"><span class="pre">f</span></tt>
at frame <tt class="docutils literal"><span class="pre">t</span></tt></li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.wav&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Use left-aligned frames</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D_left</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Use a shorter hop length</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D_short</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)], real-valued</span></dt>
<dd><p class="first last">the input signal (audio time series)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">FFT window size</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">number audio of frames between STFT columns.
If unspecified, defaults <tt class="docutils literal"><span class="pre">win_length</span> <span class="pre">/</span> <span class="pre">4</span></tt>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &lt;= n_fft [scalar]</span></dt>
<dd><p class="first">Each frame of audio is windowed by <tt class="docutils literal"><span class="pre">window()</span></tt>.
The window will be of length <tt class="docutils literal"><span class="pre">win_length</span></tt> and then padded
with zeros to match <tt class="docutils literal"><span class="pre">n_fft</span></tt>.</p>
<p class="last">If unspecified, defaults to <tt class="docutils literal"><span class="pre">win_length</span> <span class="pre">=</span> <span class="pre">n_fft</span></tt>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">None, function, np.ndarray [shape=(n_fft,)]</span></dt>
<dd><ul class="first last simple">
<li>None (default): use an asymmetric Hann window</li>
<li>a window function, such as <tt class="docutils literal"><span class="pre">scipy.signal.hanning</span></tt></li>
<li>a vector or array of length <tt class="docutils literal"><span class="pre">n_fft</span></tt></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <tt class="docutils literal"><span class="pre">True</span></tt>, the signal <tt class="docutils literal"><span class="pre">y</span></tt> is padded so that frame
<tt class="docutils literal"><span class="pre">D[f,</span> <span class="pre">t]</span></tt> is centered at <tt class="docutils literal"><span class="pre">y[t</span> <span class="pre">*</span> <span class="pre">hop_length]</span></tt>.</li>
<li>If <tt class="docutils literal"><span class="pre">False</span></tt>, then <tt class="docutils literal"><span class="pre">D[f,</span> <span class="pre">t]</span></tt> <em>begins</em> at <tt class="docutils literal"><span class="pre">y[t</span> <span class="pre">*</span> <span class="pre">hop_length]</span></tt></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">numeric type</span></dt>
<dd><p class="first last">Complex numeric type for <tt class="docutils literal"><span class="pre">D</span></tt>.  Default is 64-bit complex.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1 + n_fft/2, t), dtype=dtype]</span></dt>
<dd><p class="first last">STFT matrix</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.istft">
<tt class="descclassname">librosa.core.</tt><tt class="descname">istft</tt><big>(</big><em>stft_matrix</em>, <em>hop_length=None</em>, <em>win_length=None</em>, <em>window=None</em>, <em>center=True</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em><big>)</big><a class="headerlink" href="#librosa.core.istft" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse short-time Fourier transform.</p>
<p>Converts a complex-valued spectrogram <tt class="docutils literal"><span class="pre">stft_matrix</span></tt> to time-series <tt class="docutils literal"><span class="pre">y</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.wav&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stft_matrix</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_hat</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span><span class="n">stft_matrix</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>stft_matrix <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1 + n_fft/2, t)]</span></dt>
<dd><p class="first last">STFT matrix from <a class="reference internal" href="#librosa.core.stft" title="librosa.core.stft"><tt class="xref py py-func docutils literal"><span class="pre">librosa.core.stft()</span></tt></a></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Number of frames between STFT columns.
If unspecified, defaults to <tt class="docutils literal"><span class="pre">win_length</span> <span class="pre">/</span> <span class="pre">4</span></tt>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &lt;= n_fft = 2 * (stft_matrix.shape[0] - 1)</span></dt>
<dd><p class="first">When reconstructing the time series, each frame is windowed
according to the <tt class="docutils literal"><span class="pre">window</span></tt> function (see below).</p>
<p class="last">If unspecified, defaults to <tt class="docutils literal"><span class="pre">n_fft</span></tt>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">None, function, np.ndarray [shape=(n_fft,)]</span></dt>
<dd><ul class="first last simple">
<li>None (default): use an asymmetric Hann window * 2/3</li>
<li>a window function, such as <tt class="docutils literal"><span class="pre">scipy.signal.hanning</span></tt></li>
<li>a user-specified window vector of length <tt class="docutils literal"><span class="pre">n_fft</span></tt></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <cite>True</cite>, <cite>D</cite> is assumed to have centered frames.</li>
<li>If <cite>False</cite>, <cite>D</cite> is assumed to have left-aligned frames.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">numeric type</span></dt>
<dd><p class="first last">Real numeric type for <tt class="docutils literal"><span class="pre">y</span></tt>.  Default is 32-bit float.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">time domain signal reconstructed from <tt class="docutils literal"><span class="pre">stft_matrix</span></tt></p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.ifgram">
<tt class="descclassname">librosa.core.</tt><tt class="descname">ifgram</tt><big>(</big><em>y</em>, <em>sr=22050</em>, <em>n_fft=2048</em>, <em>hop_length=None</em>, <em>win_length=None</em>, <em>norm=False</em>, <em>center=True</em>, <em>dtype=&lt;type 'numpy.complex64'&gt;</em><big>)</big><a class="headerlink" href="#librosa.core.ifgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the instantaneous frequency (as a proportion of the sampling rate)
obtained as the time-derivative of the phase of the complex spectrum as
described by Toshihiro Abe et al. in ICASSP&#8216;95, Eurospeech&#8216;97.</p>
<p>Calculates regular STFT as a side effect.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.wav&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frequencies</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">ifgram</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">audio time series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">sampling rate of <tt class="docutils literal"><span class="pre">y</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">FFT window size</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">hop length, number samples between subsequent frames.
If not supplied, defaults to <tt class="docutils literal"><span class="pre">win_length</span> <span class="pre">/</span> <span class="pre">4</span></tt>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>win_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0, &lt;= n_fft</span></dt>
<dd><p class="first last">Window length. Defaults to <tt class="docutils literal"><span class="pre">n_fft</span></tt>.
See <a class="reference internal" href="#librosa.core.stft" title="librosa.core.stft"><tt class="xref py py-func docutils literal"><span class="pre">librosa.core.stft()</span></tt></a> for details.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Normalize the STFT.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><ul class="first last simple">
<li>If <tt class="docutils literal"><span class="pre">True</span></tt>, the signal <tt class="docutils literal"><span class="pre">y</span></tt> is padded so that frame
<tt class="docutils literal"><span class="pre">D[f,</span> <span class="pre">t]</span></tt> is centered at <tt class="docutils literal"><span class="pre">y[t</span> <span class="pre">*</span> <span class="pre">hop_length]</span></tt>.</li>
<li>If <tt class="docutils literal"><span class="pre">False</span></tt>, then <tt class="docutils literal"><span class="pre">D[f,</span> <span class="pre">t]</span></tt> <em>begins</em> at <tt class="docutils literal"><span class="pre">y[t</span> <span class="pre">*</span> <span class="pre">hop_length]</span></tt></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">numeric type</span></dt>
<dd><p class="first last">Complex numeric type for <tt class="docutils literal"><span class="pre">D</span></tt>.  Default is 64-bit complex.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>if_gram <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1 + n_fft/2, t), dtype=real]</span></dt>
<dd><p class="first last">Instantaneous frequency spectrogram:
<tt class="docutils literal"><span class="pre">if_gram[f,</span> <span class="pre">t]</span></tt> is the frequency at bin <tt class="docutils literal"><span class="pre">f</span></tt>, time <tt class="docutils literal"><span class="pre">t</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1 + n_fft/2, t), dtype=complex]</span></dt>
<dd><p class="first last">Short-time Fourier transform</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Abe, Toshihiko, Takao Kobayashi, and Satoshi Imai.
&#8220;Harmonics tracking and pitch extraction based on
instantaneous frequency.&#8221;
Acoustics, Speech, and Signal Processing, 1995. ICASSP-95.,
1995 International Conference on. Vol. 1. IEEE, 1995.</li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.magphase">
<tt class="descclassname">librosa.core.</tt><tt class="descname">magphase</tt><big>(</big><em>D</em><big>)</big><a class="headerlink" href="#librosa.core.magphase" title="Permalink to this definition">¶</a></dt>
<dd><p>Separate a complex-valued spectrogram D into its magnitude (S)
and phase (P) components, so that <tt class="docutils literal"><span class="pre">D</span> <span class="pre">=</span> <span class="pre">S</span> <span class="pre">*</span> <span class="pre">P</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">magphase</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">==</span> <span class="n">S</span> <span class="o">*</span> <span class="n">P</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t), dtype=complex]</span></dt>
<dd><p class="first last">complex-valued spectrogram</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>D_mag <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t), dtype=real]</span></dt>
<dd><p class="first last">magnitude of <tt class="docutils literal"><span class="pre">D</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>D_phase <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t), dtype=complex]</span></dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">exp(1.j</span> <span class="pre">*</span> <span class="pre">phi)</span></tt> where <tt class="docutils literal"><span class="pre">phi</span></tt> is the phase of <tt class="docutils literal"><span class="pre">D</span></tt></p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.cqt">
<tt class="descclassname">librosa.core.</tt><tt class="descname">cqt</tt><big>(</big><em>y</em>, <em>sr=22050</em>, <em>hop_length=512</em>, <em>fmin=None</em>, <em>n_bins=84</em>, <em>bins_per_octave=12</em>, <em>tuning=None</em>, <em>resolution=2</em>, <em>res_type='sinc_best'</em>, <em>aggregate=None</em><big>)</big><a class="headerlink" href="#librosa.core.cqt" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the constant-Q transform of an audio signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.wav&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">cqt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Limit the frequency range</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">cqt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_hz</span><span class="p">(</span><span class="mi">36</span><span class="p">),</span>
<span class="go">                    n_bins=60)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Use higher resolution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">cqt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_hz</span><span class="p">(</span><span class="mi">36</span><span class="p">),</span>
<span class="go">                    n_bins=60 * 2, bins_per_octave=12 * 2)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">audio time series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">sampling rate of <tt class="docutils literal"><span class="pre">y</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first">number of samples between successive CQT columns.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">hop_length</span></tt> must be at least
<tt class="docutils literal"><span class="pre">2**(n_bins</span> <span class="pre">/</span> <span class="pre">bins_per_octave)</span></tt></p>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Minimum frequency. Defaults to C2 ~= 32.70 Hz</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_bins <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Number of frequency bins, starting at <cite>fmin</cite></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Number of bins per octave</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">None or float in <tt class="docutils literal"><span class="pre">[-0.5,</span> <span class="pre">0.5)</span></tt></span></dt>
<dd><p class="first last">Tuning offset in fractions of a bin (cents)
If <tt class="docutils literal"><span class="pre">None</span></tt>, tuning will be automatically estimated.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>resolution <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">Filter resolution factor. Larger values use longer windows.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>res_type <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Resampling type, see <a class="reference internal" href="#librosa.core.resample" title="librosa.core.resample"><tt class="xref py py-func docutils literal"><span class="pre">librosa.core.resample()</span></tt></a> for details.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>aggregate <span class="classifier-delimiter">:</span> <span class="classifier">None or function</span></dt>
<dd><p class="first last">Aggregation function for time-oversampling energy aggregation.
By default, <tt class="docutils literal"><span class="pre">np.mean</span></tt>.  See <a class="reference internal" href="#librosa.feature.sync" title="librosa.feature.sync"><tt class="xref py py-func docutils literal"><span class="pre">librosa.feature.sync()</span></tt></a>.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>CQT <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t), dtype=np.float]</span></dt>
<dd><p class="first last">Constant-Q energy for each frequency at each time.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This implementation is based on the recursive sub-sampling method
described by Schoerkhuber and Klapuri, 2010.</p>
<ul class="last">
<li><dl class="first docutils">
<dt>Schoerkhuber, Christian, and Anssi Klapuri.</dt>
<dd><p class="first last">&#8220;Constant-Q transform toolbox for music processing.&#8221;
7th Sound and Music Computing Conference, Barcelona, Spain. 2010.</p>
</dd>
</dl>
</li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.phase_vocoder">
<tt class="descclassname">librosa.core.</tt><tt class="descname">phase_vocoder</tt><big>(</big><em>D</em>, <em>rate</em>, <em>hop_length=None</em><big>)</big><a class="headerlink" href="#librosa.core.phase_vocoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase vocoder.  Given an STFT matrix D, speed up by a factor of <tt class="docutils literal"><span class="pre">rate</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Play at double speed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span>   <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.wav&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D_fast</span>  <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">phase_vocoder</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_fast</span>  <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span><span class="n">D_fast</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or play at 1/3 speed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D_slow</span>  <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">phase_vocoder</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_slow</span>  <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span><span class="n">D_slow</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t), dtype=complex]</span></dt>
<dd><p class="first last">STFT matrix</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>rate <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Speed-up factor: <tt class="docutils literal"><span class="pre">rate</span> <span class="pre">&gt;</span> <span class="pre">1</span></tt> is faster, <tt class="docutils literal"><span class="pre">rate</span> <span class="pre">&lt;</span> <span class="pre">1</span></tt> is slower.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar] or None</span></dt>
<dd><p class="first last">The number of samples between successive columns of <tt class="docutils literal"><span class="pre">D</span></tt>.
If None, defaults to <tt class="docutils literal"><span class="pre">n_fft/4</span> <span class="pre">=</span> <span class="pre">(D.shape[0]-1)/2</span></tt></p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>D_stretched <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t / rate), dtype=complex]</span></dt>
<dd><p class="first last">time-stretched STFT</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Ellis, D. P. W. &#8220;A phase vocoder in Matlab.&#8221; Columbia University
(<a class="reference external" href="http://www.ee.columbia.edu/dpwe/resources/matlab/pvoc/">http://www.ee.columbia.edu/dpwe/resources/matlab/pvoc/</a>) (2002).</li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.core.note_to_midi">
<tt class="descclassname">librosa.core.</tt><tt class="descname">note_to_midi</tt><big>(</big><em>note</em><big>)</big><a class="headerlink" href="#librosa.core.note_to_midi" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert one or more spelled notes to MIDI number(s).</p>
<p>Notes may be spelled out with optional accidentals or octave numbers.</p>
<p>The leading note name is case-insensitive.</p>
<p>Sharps are indicated with <cite>#</cite>, flats may be indicated with <cite>!</cite> or <cite>b</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_midi</span><span class="p">(</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_midi</span><span class="p">(</span><span class="s">&#39;C#3&#39;</span><span class="p">)</span>
<span class="go">37</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_midi</span><span class="p">(</span><span class="s">&#39;f4&#39;</span><span class="p">)</span>
<span class="go">53</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_midi</span><span class="p">(</span><span class="s">&#39;Bb-1&#39;</span><span class="p">)</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_midi</span><span class="p">(</span><span class="s">&#39;A!8&#39;</span><span class="p">)</span>
<span class="go">104</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li>note : str or iterable of str
One or more note names.</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li>midi : int or np.array
Midi note numbers corresponding to inputs.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.midi_to_note">
<tt class="descclassname">librosa.core.</tt><tt class="descname">midi_to_note</tt><big>(</big><em>midi</em>, <em>octave=True</em>, <em>cents=False</em><big>)</big><a class="headerlink" href="#librosa.core.midi_to_note" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert one or more MIDI numbers to note strings.</p>
<p>MIDI numbers will be rounded to the nearest integer.</p>
<p>Notes will be of the format &#8216;C0&#8217;, &#8216;C#0&#8217;, &#8216;D0&#8217;, ...</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_note</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;C0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_note</span><span class="p">(</span><span class="mi">37</span><span class="p">)</span>
<span class="go">&#39;C#3&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_note</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;A#-1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_note</span><span class="p">(</span><span class="mf">104.7</span><span class="p">)</span>
<span class="go">&#39;A8&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_note</span><span class="p">(</span><span class="mf">104.7</span><span class="p">,</span> <span class="n">cents</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&#39;A8-30&#39;</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>midi <span class="classifier-delimiter">:</span> <span class="classifier">int or iterable of int</span></dt>
<dd><p class="first last">Midi numbers to convert.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>octave: bool</dt>
<dd><p class="first last">If True, include the octave number</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>cents: bool</dt>
<dd><p class="first last">If true, cent markers will be appended for fractional notes.
Eg, <tt class="docutils literal"><span class="pre">midi_to_note(69.3,</span> <span class="pre">cents=True)</span></tt> == <tt class="docutils literal"><span class="pre">A5+03</span></tt></p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>notes <span class="classifier-delimiter">:</span> <span class="classifier">str or iterable of str</span></dt>
<dd><p class="first last">Strings describing each midi note.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.midi_to_hz">
<tt class="descclassname">librosa.core.</tt><tt class="descname">midi_to_hz</tt><big>(</big><em>notes</em><big>)</big><a class="headerlink" href="#librosa.core.midi_to_hz" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the frequency (Hz) of MIDI note(s)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_hz</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span>
<span class="go">array([ 65.40639133])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_hz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">36</span><span class="p">,</span> <span class="mi">48</span><span class="p">))</span>
<span class="go">array([  65.40639133,   69.29565774,   73.41619198,   77.78174593,</span>
<span class="go">         82.40688923,   87.30705786,   92.49860568,   97.998859  ,</span>
<span class="go">        103.82617439,  110.        ,  116.54094038,  123.47082531])</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>notes <span class="classifier-delimiter">:</span> <span class="classifier">int or np.ndarray [shape=(n,), dtype=int]</span></dt>
<dd><p class="first last">midi number(s) of the note(s)</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>frequency <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,), dtype=float]</span></dt>
<dd><p class="first last">frequency (frequencies) of <tt class="docutils literal"><span class="pre">notes</span></tt> in Hz</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.hz_to_midi">
<tt class="descclassname">librosa.core.</tt><tt class="descname">hz_to_midi</tt><big>(</big><em>frequencies</em><big>)</big><a class="headerlink" href="#librosa.core.hz_to_midi" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the closest MIDI note number(s) for given frequencies</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">hz_to_midi</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
<span class="go">array([ 34.50637059])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">hz_to_midi</span><span class="p">([</span><span class="mi">110</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">440</span><span class="p">])</span>
<span class="go">array([ 45.,  57.,  69.])</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">float or np.ndarray [shape=(n,), dtype=float]</span></dt>
<dd><p class="first last">frequencies to convert</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>note_nums <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,), dtype=int]</span></dt>
<dd><p class="first last">closest MIDI notes to <tt class="docutils literal"><span class="pre">frequencies</span></tt></p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.hz_to_mel">
<tt class="descclassname">librosa.core.</tt><tt class="descname">hz_to_mel</tt><big>(</big><em>frequencies</em>, <em>htk=False</em><big>)</big><a class="headerlink" href="#librosa.core.hz_to_mel" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Hz to Mels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">hz_to_mel</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
<span class="go">array([0.9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">hz_to_mel</span><span class="p">([</span><span class="mi">110</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">440</span><span class="p">])</span>
<span class="go">array([ 1.65,  3.3 ,  6.6 ])</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] , float</span></dt>
<dd><p class="first last">scalar or array of frequencies</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>htk <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">use HTK formula instead of Slaney</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>mels <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">input frequencies in Mels</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.mel_to_hz">
<tt class="descclassname">librosa.core.</tt><tt class="descname">mel_to_hz</tt><big>(</big><em>mels</em>, <em>htk=False</em><big>)</big><a class="headerlink" href="#librosa.core.mel_to_hz" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert mel bin numbers to frequencies</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">mel_to_hz</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([ 200.])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">mel_to_hz</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">array([  66.66666667,  133.33333333,  200.        ,  266.66666667,</span>
<span class="go">        333.33333333])</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>mels <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)], float</span></dt>
<dd><p class="first last">mel bins to convert</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>htk <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">use HTK formula instead of Slaney</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">input mels in Hz</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.hz_to_octs">
<tt class="descclassname">librosa.core.</tt><tt class="descname">hz_to_octs</tt><big>(</big><em>frequencies</em>, <em>A440=440.0</em><big>)</big><a class="headerlink" href="#librosa.core.hz_to_octs" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert frequencies (Hz) to (fractional) octave numbers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">hz_to_octs</span><span class="p">(</span><span class="mf">440.0</span><span class="p">)</span>
<span class="go">array([ 4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">hz_to_octs</span><span class="p">([</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">])</span>
<span class="go">array([ 0.21864029,  1.21864029,  2.21864029,  3.21864029])</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or float</span></dt>
<dd><p class="first last">scalar or vector of frequencies</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>A440 <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">frequency of A440</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>octaves <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">octave number for each frequency</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.octs_to_hz">
<tt class="descclassname">librosa.core.</tt><tt class="descname">octs_to_hz</tt><big>(</big><em>octs</em>, <em>A440=440.0</em><big>)</big><a class="headerlink" href="#librosa.core.octs_to_hz" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert octaves numbers to frequencies.</p>
<p>Octaves are counted relative to A.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">octs_to_hz</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 55.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">octs_to_hz</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([   6.875,   13.75 ,   27.5  ,   55.   ,  110.   ])</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>octaves <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or float</span></dt>
<dd><p class="first last">octave number for each frequency</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>A440 <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">frequency of A440</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">scalar or vector of frequencies</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.fft_frequencies">
<tt class="descclassname">librosa.core.</tt><tt class="descname">fft_frequencies</tt><big>(</big><em>sr=22050</em>, <em>n_fft=2048</em><big>)</big><a class="headerlink" href="#librosa.core.fft_frequencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternative implementation of <tt class="docutils literal"><span class="pre">np.fft.fftfreqs</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="go">array([     0.   ,   1378.125,   2756.25 ,   4134.375,   5512.5  ,</span>
<span class="go">         6890.625,   8268.75 ,   9646.875,  11025.   ])</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Audio sampling rate</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">FFT window size</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>freqs <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(1 + n_fft/2,)]</span></dt>
<dd><p class="first last">Frequencies (0, sr/n_fft, 2*sr/n_fft, ..., sr/2)</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.cqt_frequencies">
<tt class="descclassname">librosa.core.</tt><tt class="descname">cqt_frequencies</tt><big>(</big><em>n_bins</em>, <em>fmin</em>, <em>bins_per_octave=12</em>, <em>tuning=0.0</em><big>)</big><a class="headerlink" href="#librosa.core.cqt_frequencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the center frequencies of Constant-Q bins.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Get the CQT frequencies for 24 notes, starting at C2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmin</span><span class="o">=</span><span class="n">librosa</span><span class="o">.</span><span class="n">midi_to_hz</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">note_to_midi</span><span class="p">(</span><span class="s">&#39;C2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">cqt_frequencies</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">)</span>
<span class="go">array([  32.70319566,   34.64782887,   36.70809599,   38.89087297,</span>
<span class="go">         41.20344461,   43.65352893,   46.24930284,   48.9994295 ,</span>
<span class="go">         51.9130872 ,   55.        ,   58.27047019,   61.73541266,</span>
<span class="go">         65.40639133,   69.29565774,   73.41619198,   77.78174593,</span>
<span class="go">         82.40688923,   87.30705786,   92.49860568,   97.998859  ,</span>
<span class="go">        103.82617439,  110.        ,  116.54094038,  123.47082531])</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>n_bins <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Number of constant-Q bins</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Minimum frequency</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Number of bins per octave</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">float in <tt class="docutils literal"><span class="pre">[-0.5,</span> <span class="pre">+0.5)</span></tt></span></dt>
<dd><p class="first last">Deviation from A440 tuning in fractional bins (cents)</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_bins,)]</span></dt>
<dd><p class="first last">Center frequency for each CQT bin</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.mel_frequencies">
<tt class="descclassname">librosa.core.</tt><tt class="descname">mel_frequencies</tt><big>(</big><em>n_mels=128</em>, <em>fmin=0.0</em>, <em>fmax=11025.0</em>, <em>htk=False</em>, <em>extra=False</em><big>)</big><a class="headerlink" href="#librosa.core.mel_frequencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the center frequencies of mel bands</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">mel_frequencies</span><span class="p">(</span><span class="n">n_mels</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="go">array([    0.        ,    81.15543818,   162.31087636,   243.46631454,</span>
<span class="go">        324.62175272,   405.7771909 ,   486.93262907,   568.08806725,</span>
<span class="go">        649.24350543,   730.39894361,   811.55438179,   892.70981997,</span>
<span class="go">        973.86525815,  1058.38224675,  1150.77458676,  1251.23239132,</span>
<span class="go">        1360.45974173,  1479.22218262,  1608.3520875 ,  1748.75449257,</span>
<span class="go">        1901.4134399 ,  2067.39887435,  2247.87414245,  2444.10414603,</span>
<span class="go">        2657.46420754,  2889.44970936,  3141.68657445,  3415.94266206,</span>
<span class="go">        3714.14015814,  4038.36904745,  4390.90176166,  4774.2091062 ,</span>
<span class="go">        5190.97757748,  5644.12819182,  6136.83695801,  6672.55713712,</span>
<span class="go">        7255.04344548,  7888.37837041,  8577.0007833 ,  9325.73705043])</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>n_mels <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">number of Mel bins</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt;= 0 [scalar]</span></dt>
<dd><p class="first last">minimum frequency (Hz)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fmax <span class="classifier-delimiter">:</span> <span class="classifier">float &gt;= 0 [scalar]</span></dt>
<dd><p class="first last">maximum frequency (Hz)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>htk <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">use HTK formula instead of Slaney</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>extra <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">include extra frequencies necessary for building Mel filters</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>bin_frequencies <span class="classifier-delimiter">:</span> <span class="classifier">ndarray [shape=(n_mels,)]</span></dt>
<dd><p class="first last">vector of Mel frequencies</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.A_weighting">
<tt class="descclassname">librosa.core.</tt><tt class="descname">A_weighting</tt><big>(</big><em>frequencies</em>, <em>min_db=-80.0</em><big>)</big><a class="headerlink" href="#librosa.core.A_weighting" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the A-weighting of a set of frequencies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Get the A-weighting for 20 Mel frequencies</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span>   <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">mel_frequencies</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">A_weighting</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>
<span class="go">array([-80.        , -13.35467911,  -6.59400464,  -3.57422971,</span>
<span class="go">        -1.87710933,  -0.83465455,  -0.15991521,   0.3164558 ,</span>
<span class="go">        0.68372258,   0.95279329,   1.13498903,   1.23933477,</span>
<span class="go">        1.27124465,   1.23163355,   1.1163366 ,   0.91575476,</span>
<span class="go">        0.6147545 ,   0.1929889 ,  -0.37407714,  -1.11314196])</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">scalar or np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">One or more frequencies (in Hz)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>min_db <span class="classifier-delimiter">:</span> <span class="classifier">float [scalar] or None</span></dt>
<dd><p class="first last">Clip weights below this threshold.
If <tt class="docutils literal"><span class="pre">None</span></tt>, no clipping is performed.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>A_weighting <span class="classifier-delimiter">:</span> <span class="classifier">scalar or np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">A_weighting[i]</span></tt> is the A-weighting of <tt class="docutils literal"><span class="pre">frequencies[i]</span></tt></p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.logamplitude">
<tt class="descclassname">librosa.core.</tt><tt class="descname">logamplitude</tt><big>(</big><em>S</em>, <em>ref_power=1.0</em>, <em>amin=1e-10</em>, <em>top_db=80.0</em><big>)</big><a class="headerlink" href="#librosa.core.logamplitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Log-scale the amplitude of a spectrogram.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Get a power spectrogram from a waveform y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log_S</span>   <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">logamplitude</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Compute dB relative to a standard reference of 1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log_S</span>   <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">logamplitude</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ref_power</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Compute dB relative to peak power</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log_S</span>   <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">logamplitude</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ref_power</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or compare to median power</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log_S</span>   <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">logamplitude</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">ref_power</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)]</span></dt>
<dd><p class="first last">input spectrogram</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ref_power <span class="classifier-delimiter">:</span> <span class="classifier">scalar or function</span></dt>
<dd><p class="first">If scalar, <tt class="docutils literal"><span class="pre">log(abs(S))</span></tt> is compared to <tt class="docutils literal"><span class="pre">log(ref_power)</span></tt>.
If a function, <tt class="docutils literal"><span class="pre">log(abs(S))</span></tt> is compared to
<tt class="docutils literal"><span class="pre">log(ref_power(abs(S)))</span></tt>.</p>
<p class="last">This is primarily useful for comparing to the maximum value of <tt class="docutils literal"><span class="pre">S</span></tt>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>amin <span class="classifier-delimiter">:</span> <span class="classifier">float [scalar]</span></dt>
<dd><p class="first last">minimum amplitude threshold for <tt class="docutils literal"><span class="pre">abs(S)</span></tt> and <tt class="docutils literal"><span class="pre">ref_power</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>top_db <span class="classifier-delimiter">:</span> <span class="classifier">float [scalar]</span></dt>
<dd><p class="first last">threshold log amplitude at top_db below the peak:
<tt class="docutils literal"><span class="pre">max(log(S))</span> <span class="pre">-</span> <span class="pre">top_db</span></tt></p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>log_S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)]</span></dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">log_S</span> <span class="pre">~=</span> <span class="pre">10</span> <span class="pre">*</span> <span class="pre">log10(S)</span> <span class="pre">-</span> <span class="pre">10</span> <span class="pre">*</span> <span class="pre">log10(abs(ref_power))</span></tt></p>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.perceptual_weighting">
<tt class="descclassname">librosa.core.</tt><tt class="descname">perceptual_weighting</tt><big>(</big><em>S</em>, <em>frequencies</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.core.perceptual_weighting" title="Permalink to this definition">¶</a></dt>
<dd><p>Perceptual weighting of a power spectrogram:</p>
<p><tt class="docutils literal"><span class="pre">S_p[f]</span> <span class="pre">=</span> <span class="pre">A_weighting(f)</span> <span class="pre">+</span> <span class="pre">10*log(S[f]</span> <span class="pre">/</span> <span class="pre">ref_power)</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Re-weight a CQT representation, using peak power as reference</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CQT</span>             <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">cqt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="mi">55</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="mi">440</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span>           <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">cqt_frequencies</span><span class="p">(</span><span class="n">CQT</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fmin</span><span class="o">=</span><span class="mi">55</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">percept_CQT</span>     <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">perceptual_weighting</span><span class="p">(</span><span class="n">CQT</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span>
<span class="go">                                                   ref_power=np.max)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)]</span></dt>
<dd><p class="first last">Power spectrogram</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d,)]</span></dt>
<dd><p class="first last">Center frequency for each row of <tt class="docutils literal"><span class="pre">S</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwargs</em></dt>
<dd><p class="first last">Additional keyword arguments to <a class="reference internal" href="#librosa.core.logamplitude" title="librosa.core.logamplitude"><tt class="xref py py-func docutils literal"><span class="pre">librosa.core.logamplitude()</span></tt></a>.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>S_p <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)]</span></dt>
<dd><p class="first last">perceptually weighted version of <tt class="docutils literal"><span class="pre">S</span></tt></p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.frames_to_time">
<tt class="descclassname">librosa.core.</tt><tt class="descname">frames_to_time</tt><big>(</big><em>frames</em>, <em>sr=22050</em>, <em>hop_length=512</em>, <em>n_fft=None</em><big>)</big><a class="headerlink" href="#librosa.core.frames_to_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts frame counts to time (seconds)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.wav&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span><span class="p">,</span> <span class="n">beats</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">beat_track</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beat_times</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">frames_to_time</span><span class="p">(</span><span class="n">beats</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Time conversion with a framing correction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">onset_env</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">onset_strength</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">onsets</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">onset_detect</span><span class="p">(</span><span class="n">onset_envelope</span><span class="o">=</span><span class="n">onset_env</span><span class="p">,</span>
<span class="go">                                        sr=sr)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">onset_times</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">frames_to_time</span><span class="p">(</span><span class="n">onsets</span><span class="p">,</span>
<span class="go">                                         sr=sr,</span>
<span class="go">                                         hop_length=64,</span>
<span class="go">                                         n_fft=1024)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>frames <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">vector of frame numbers</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">audio sampling rate</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">number of samples between successive frames</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">None or int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Optional: length of the FFT window.
If given, time conversion will include an offset of <tt class="docutils literal"><span class="pre">n_fft</span> <span class="pre">/</span> <span class="pre">2</span></tt>
to counteract windowing effects when using a non-centered STFT.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">time (in seconds) of each given frame number:
<tt class="docutils literal"><span class="pre">times[i]</span> <span class="pre">=</span> <span class="pre">frames[i]</span> <span class="pre">*</span> <span class="pre">hop_length</span> <span class="pre">/</span> <span class="pre">sr</span></tt></p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.time_to_frames">
<tt class="descclassname">librosa.core.</tt><tt class="descname">time_to_frames</tt><big>(</big><em>times</em>, <em>sr=22050</em>, <em>hop_length=512</em>, <em>n_fft=None</em><big>)</big><a class="headerlink" href="#librosa.core.time_to_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts time stamps into STFT frames.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Get the frame numbers for every 100ms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">time_to_frames</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span>
<span class="go">                           sr=22050, hop_length=512)</span>
<span class="go">array([ 0,  4,  8, 12, 17, 21, 25, 30, 34, 38])</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">vector of time stamps</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">audio sampling rate</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">number of samples between successive frames</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">None or int &gt; 0 [scalar]</span></dt>
<dd><p class="first">Optional: length of the FFT window.
If given, time conversion will include an offset of <tt class="docutils literal"><span class="pre">-</span> <span class="pre">n_fft</span> <span class="pre">/</span> <span class="pre">2</span></tt>
to counteract windowing effects in STFT.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This may result in negative frame indices.</p>
</div>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>frames <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,), dtype=int]</span></dt>
<dd><p class="first last">Frame numbers corresponding to the given times:
<tt class="docutils literal"><span class="pre">frames[i]</span> <span class="pre">=</span> <span class="pre">floor(</span> <span class="pre">times[i]</span> <span class="pre">*</span> <span class="pre">sr</span> <span class="pre">/</span> <span class="pre">hop_length</span> <span class="pre">)</span></tt></p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.autocorrelate">
<tt class="descclassname">librosa.core.</tt><tt class="descname">autocorrelate</tt><big>(</big><em>y</em>, <em>max_size=None</em><big>)</big><a class="headerlink" href="#librosa.core.autocorrelate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bounded auto-correlation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Compute full autocorrelation of y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span>   <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.wav&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_ac</span>    <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">autocorrelate</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Compute autocorrelation up to 4 seconds lag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_ac_4</span>  <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">autocorrelate</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">vector to autocorrelate</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>max_size <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 or None</span></dt>
<dd><p class="first last">maximum correlation lag.
If unspecified, defaults to <tt class="docutils literal"><span class="pre">len(y)</span></tt> (unbounded)</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>z <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,) or (max_size,)]</span></dt>
<dd><p class="first last">truncated autocorrelation <tt class="docutils literal"><span class="pre">y*y</span></tt></p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.localmax">
<tt class="descclassname">librosa.core.</tt><tt class="descname">localmax</tt><big>(</big><em>x</em>, <em>axis=0</em><big>)</big><a class="headerlink" href="#librosa.core.localmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local maxima in an array <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">localmax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([False, False, False,  True, False,  True, False, True],</span>
<span class="go">      dtype=bool)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Two-dimensional example</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">localmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[False, False, False],</span>
<span class="go">       [ True, False, False],</span>
<span class="go">       [False,  True,  True]], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">localmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[False, False,  True],</span>
<span class="go">       [False, False,  True],</span>
<span class="go">       [False, False,  True]], dtype=bool)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d1,d2,...)]</span></dt>
<dd><p class="first last">input vector or array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">axis along which to compute local maximality</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>m <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=x.shape, dtype=bool]</span></dt>
<dd><p class="first last">indicator vector of local maxima:
<tt class="docutils literal"><span class="pre">m[i]</span> <span class="pre">==</span> <span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">x[i]</span></tt> is a local maximum</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.core.peak_pick">
<tt class="descclassname">librosa.core.</tt><tt class="descname">peak_pick</tt><big>(</big><em>x</em>, <em>pre_max</em>, <em>post_max</em>, <em>pre_avg</em>, <em>post_avg</em>, <em>delta</em>, <em>wait</em><big>)</big><a class="headerlink" href="#librosa.core.peak_pick" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses a flexible heuristic to pick peaks in a signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Look +-3 steps</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># compute the moving average over +-5 steps</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># peaks must be &gt; avg + 0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># skip 10 steps before taking another peak</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">peak_pick</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">input signal to peak picks from</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>pre_max <span class="classifier-delimiter">:</span> <span class="classifier">int &gt;= 0 [scalar]</span></dt>
<dd><p class="first last">number of samples before n over which max is computed</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>post_max <span class="classifier-delimiter">:</span> <span class="classifier">int &gt;= 0 [scalar]</span></dt>
<dd><p class="first last">number of samples after n over which max is computed</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>pre_avg <span class="classifier-delimiter">:</span> <span class="classifier">int &gt;= 0 [scalar]</span></dt>
<dd><p class="first last">number of samples before n over which mean is computed</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>post_avg <span class="classifier-delimiter">:</span> <span class="classifier">int &gt;= 0 [scalar]</span></dt>
<dd><p class="first last">number of samples after n over which mean is computed</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>delta <span class="classifier-delimiter">:</span> <span class="classifier">float &gt;= 0 [scalar]</span></dt>
<dd><p class="first last">threshold offset for mean</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>wait <span class="classifier-delimiter">:</span> <span class="classifier">int &gt;= 0 [scalar]</span></dt>
<dd><p class="first last">number of samples to wait after picking a peak</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>peaks <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_peaks,), dtype=int]</span></dt>
<dd><p class="first last">indices of peaks in x</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>A sample n is selected as an peak if the corresponding x[n]
fulfills the following three conditions:</p>
<blockquote>
<div><ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">x[n]</span> <span class="pre">==</span> <span class="pre">max(x[n</span> <span class="pre">-</span> <span class="pre">pre_max:n</span> <span class="pre">+</span> <span class="pre">post_max])</span></tt></li>
<li><tt class="docutils literal"><span class="pre">x[n]</span> <span class="pre">&gt;=</span> <span class="pre">mean(x[n</span> <span class="pre">-</span> <span class="pre">pre_avg:n</span> <span class="pre">+</span> <span class="pre">post_avg])</span> <span class="pre">+</span> <span class="pre">delta</span></tt></li>
<li><tt class="docutils literal"><span class="pre">n</span> <span class="pre">-</span> <span class="pre">previous_n</span> <span class="pre">&gt;</span> <span class="pre">wait</span></tt></li>
</ol>
</div></blockquote>
<p class="last">where <tt class="docutils literal"><span class="pre">previous_n</span></tt> is the last sample picked as a peak (greedily).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Implementation based on
<a class="reference external" href="https://github.com/CPJKU/onset_detection/blob/master/onset_program.py">https://github.com/CPJKU/onset_detection/blob/master/onset_program.py</a></p>
<ul class="last simple">
<li>Boeck, Sebastian, Florian Krebs, and Markus Schedl.
&#8220;Evaluating the Online Capabilities of Onset Detection Methods.&#8221; ISMIR.
2012.</li>
</ul>
</div>
</dd></dl>

</div>
<div class="section" id="module-librosa.decompose">
<span id="spectrogram-decomposition"></span><span id="decompose"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">Spectrogram</span> <span class="pre">decomposition</span></tt><a class="headerlink" href="#module-librosa.decompose" title="Permalink to this headline">¶</a></h2>
<p>Spectrogram decomposition</p>
<dl class="function">
<dt id="librosa.decompose.decompose">
<tt class="descclassname">librosa.decompose.</tt><tt class="descname">decompose</tt><big>(</big><em>S</em>, <em>n_components=None</em>, <em>transformer=None</em>, <em>sort=False</em><big>)</big><a class="headerlink" href="#librosa.decompose.decompose" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose a feature matrix.</p>
<p>Given a spectrogram <tt class="docutils literal"><span class="pre">S</span></tt>, produce a decomposition into <tt class="docutils literal"><span class="pre">components</span></tt>
and <tt class="docutils literal"><span class="pre">activations</span></tt> such that <tt class="docutils literal"><span class="pre">S</span> <span class="pre">~=</span> <span class="pre">components.dot(activations)</span></tt>.</p>
<p>By default, this is done with with non-negative matrix factorization (NMF),
but any <tt class="docutils literal"><span class="pre">sklearn.decomposition</span></tt>-type object will work.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Decompose a magnitude spectrogram into 32 components with NMF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comps</span><span class="p">,</span> <span class="n">acts</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">decompose</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Sort components by ascending peak frequency</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comps</span><span class="p">,</span> <span class="n">acts</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">decompose</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
<span class="go">                                              sort=True)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or with sparse dictionary learning</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">decomposition</span><span class="o">.</span><span class="n">DictionaryLearning</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comps</span><span class="p">,</span> <span class="n">acts</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">decompose</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">transformer</span><span class="o">=</span><span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_features, n_samples), dtype=float]</span></dt>
<dd><p class="first last">The input feature matrix (e.g., magnitude spectrogram)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_components <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar] or None</span></dt>
<dd><p class="first last">number of desired components
if None, then <tt class="docutils literal"><span class="pre">n_features</span></tt> components are used</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>transformer <span class="classifier-delimiter">:</span> <span class="classifier">None or object</span></dt>
<dd><p class="first">If None, use <tt class="docutils literal"><span class="pre">sklearn.decomposition.NMF</span></tt></p>
<p>Otherwise, any object with a similar interface to NMF should work.
<tt class="docutils literal"><span class="pre">transformer</span></tt> must follow the scikit-learn convention, where
input data is <tt class="docutils literal"><span class="pre">(n_samples,</span> <span class="pre">n_features)</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">transformer.fit_transform()</span></tt> will be run on <tt class="docutils literal"><span class="pre">S.T</span></tt> (not <tt class="docutils literal"><span class="pre">S</span></tt>),
the return value of which is stored (transposed) as <tt class="docutils literal"><span class="pre">activations</span></tt></p>
<p>The components will be retrieved as <tt class="docutils literal"><span class="pre">transformer.components_.T</span></tt></p>
<p><tt class="docutils literal"><span class="pre">S</span> <span class="pre">~=</span> <span class="pre">np.dot(activations,</span> <span class="pre">transformer.components_).T</span></tt></p>
<p class="last">or equivalently:
<tt class="docutils literal"><span class="pre">S</span> <span class="pre">~=</span> <span class="pre">np.dot(transformer.components_.T,</span> <span class="pre">activations.T)</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sort <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If <tt class="docutils literal"><span class="pre">True</span></tt>, components are sorted by ascending peak frequency.</p>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If used with <tt class="docutils literal"><span class="pre">transformer</span></tt>, sorting is applied to copies
of the decomposition parameters, and not to <tt class="docutils literal"><span class="pre">transformer</span></tt>&#8216;s
internal parameters.</p>
</div>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>components: np.ndarray [shape=(n_features, n_components)]</dt>
<dd><p class="first last">matrix of components (basis elements).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>activations: np.ndarray [shape=(n_components, n_samples)]</dt>
<dd><p class="first last">transformed matrix/activation matrix</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.decompose.hpss">
<tt class="descclassname">librosa.decompose.</tt><tt class="descname">hpss</tt><big>(</big><em>S</em>, <em>kernel_size=31</em>, <em>power=2.0</em>, <em>mask=False</em><big>)</big><a class="headerlink" href="#librosa.decompose.hpss" title="Permalink to this definition">¶</a></dt>
<dd><p>Median-filtering harmonic percussive source separation (HPSS).</p>
<p>Decomposes an input spectrogram <tt class="docutils literal"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">H</span> <span class="pre">+</span> <span class="pre">P</span></tt>
where <tt class="docutils literal"><span class="pre">H</span></tt> contains the harmonic components,
and <tt class="docutils literal"><span class="pre">P</span></tt> contains the percussive components.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Separate into harmonic and percussive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">decompose</span><span class="o">.</span><span class="n">hpss</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Resynthesize the harmonic component as a waveform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_harmonic</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or with a narrower horizontal filter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">decompose</span><span class="o">.</span><span class="n">hpss</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">31</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Just get harmonic/percussive masks, not the spectra</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask_H</span><span class="p">,</span> <span class="n">mask_P</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">decompose</span><span class="o">.</span><span class="n">hpss</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, n)]</span></dt>
<dd><p class="first last">input spectrogram. May be real (magnitude) or complex.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>kernel_size <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple (kernel_harmonic, kernel_percussive)</span></dt>
<dd><p class="first last">kernel size(s) for the median filters.
If scalar, the same size is used for both harmonic and percussive.
If array_like, the first value specifies the width of the
harmonic filter, and the second value specifies the width of the
percussive filter.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>power <span class="classifier-delimiter">:</span> <span class="classifier">float &gt;= 0 [scalar]</span></dt>
<dd><p class="first last">Exponent for the Wiener filter when constructing mask matrices.
Mask matrices are defined by
<tt class="docutils literal"><span class="pre">mask_H</span> <span class="pre">=</span> <span class="pre">(r_H</span> <span class="pre">**</span> <span class="pre">power)</span> <span class="pre">/</span> <span class="pre">(r_H</span> <span class="pre">**</span> <span class="pre">power</span> <span class="pre">+</span> <span class="pre">r_P</span> <span class="pre">**</span> <span class="pre">power)</span></tt>
where <tt class="docutils literal"><span class="pre">r_H</span></tt> and <tt class="docutils literal"><span class="pre">r_P</span></tt> are the median-filter responses for
harmonic and percussive components.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>mask <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Return the masking matrices instead of components</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>harmonic <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, n)]</span></dt>
<dd><p class="first last">harmonic component (or mask)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>percussive <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, n)]</span></dt>
<dd><p class="first last">percussive component (or mask)</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Fitzgerald, Derry.
&#8220;Harmonic/percussive separation using median filtering.&#8221; (2010).</li>
</ul>
</div>
</dd></dl>

</div>
<div class="section" id="display">
<span id="id1"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">Display</span></tt><a class="headerlink" href="#display" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-librosa.display"></span><p>Display module for interacting with matplotlib</p>
<dl class="function">
<dt id="librosa.display.time_ticks">
<tt class="descclassname">librosa.display.</tt><tt class="descname">time_ticks</tt><big>(</big><em>locs</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.display.time_ticks" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot time-formatted axis ticks.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Tick at pre-computed beat times</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">time_ticks</span><span class="p">(</span><span class="n">beat_times</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Set the locations of the time stamps</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">time_ticks</span><span class="p">(</span><span class="n">locations</span><span class="p">,</span> <span class="n">timestamps</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Format in seconds</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">time_ticks</span><span class="p">(</span><span class="n">beat_times</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s">&#39;s&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Tick along the y axis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">time_ticks</span><span class="p">(</span><span class="n">beat_times</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>locations <span class="classifier-delimiter">:</span> <span class="classifier">list or np.ndarray</span></dt>
<dd><p class="first last">Time-stamps for tick marks</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_ticks <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 or None</span></dt>
<dd><p class="first last">Show this number of ticks (evenly spaced).
If none, all ticks are displayed.
Default: 5</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">&#8216;x&#8217; or &#8216;y&#8217;</span></dt>
<dd><p class="first last">Which axis should the ticks be plotted on?
Default: &#8216;x&#8217;</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fmt <span class="classifier-delimiter">:</span> <span class="classifier">None or {&#8216;ms&#8217;, &#8216;s&#8217;, &#8216;m&#8217;, &#8216;h&#8217;}</span></dt>
<dd><p class="first">ms: milliseconds   (eg, 241ms)
s: seconds         (eg, 1.43s)
m: minutes         (eg, 1:02)
h: hours           (eg, 1:02:03)</p>
<p>If none, formatted is automatically selected by the
range of the times data.</p>
<p class="last">Default: None</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwargs</em></dt>
<dd><p class="first last">Additional keyword arguments.
See <tt class="docutils literal"><span class="pre">matplotlib.pyplot.xticks</span></tt> or <tt class="docutils literal"><span class="pre">yticks</span></tt> for details.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li>See <tt class="docutils literal"><span class="pre">matplotlib.pyplot.xticks</span></tt> or <tt class="docutils literal"><span class="pre">yticks</span></tt> for details.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.display.cmap">
<tt class="descclassname">librosa.display.</tt><tt class="descname">cmap</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#librosa.display.cmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a default colormap from the given data.</p>
<p>If the data is boolean, use a black and white colormap.</p>
<p>If the data has both positive and negative values,
use a diverging colormap.</p>
<p>Otherwise, use a sequential map.</p>
<p>PuOr and OrRd are chosen to optimize visibility for color-blind people.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">cmap</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">&#39;OrRd&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">cmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">))</span>
<span class="go">&#39;BuPu_r&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">cmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="go">&#39;PuOr_r&#39;</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Input data</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>cmap_str</dt>
<dd><ul class="first last simple">
<li>If data is type=boolean, cmap_Str is &#8216;gray_r&#8217;</li>
<li>If data has only positive values, cmap_str is &#8216;OrRd&#8217;</li>
<li>If data has only negative values, cmap_str is &#8216;BuPu_r&#8217;</li>
<li>If data has both positive and negatives, cmap_str is &#8216;PuOr_r&#8217;</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.display.specshow">
<tt class="descclassname">librosa.display.</tt><tt class="descname">specshow</tt><big>(</big><em>data</em>, <em>sr=22050</em>, <em>hop_length=512</em>, <em>x_axis=None</em>, <em>y_axis=None</em>, <em>n_xticks=5</em>, <em>n_yticks=5</em>, <em>fmin=None</em>, <em>fmax=None</em>, <em>bins_per_octave=12</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.display.specshow" title="Permalink to this definition">¶</a></dt>
<dd><p>Display a spectrogram/chromagram/cqt/etc.</p>
<p>Functions as a drop-in replacement for <tt class="docutils literal"><span class="pre">matplotlib.pyplot.imshow</span></tt>,
but with useful defaults.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Visualize an STFT with linear frequency scaling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or with logarithmic frequency scaling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s">&#39;log&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Visualize a CQT with note markers</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CQT</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">cqt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">CQT</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s">&#39;cqt_note&#39;</span><span class="p">,</span>
<span class="go">                             fmin=librosa.midi_to_hz(24))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Draw time markers automatically</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
<span class="go">                             x_axis=&#39;time&#39;)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Draw a chromagram with pitch classes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">chromagram</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s">&#39;chroma&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Force a grayscale colormap (white -&gt; black)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">logamplitude</span><span class="p">(</span><span class="n">D</span><span class="p">),</span>
<span class="go">                             cmap=&#39;gray_r&#39;)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, n)]</span></dt>
<dd><p class="first last">Matrix to display (e.g., spectrogram)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Sample rate used to determine time scale in x-axis.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Hop length, also used to determine time scale in x-axis</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>x_axis <span class="classifier-delimiter">:</span> <span class="classifier">None or {&#8216;time&#8217;, &#8216;frames&#8217;, &#8216;off&#8217;}</span></dt>
<dd><p class="first">If None or &#8216;off&#8217;, no x axis is displayed.</p>
<p>If &#8216;time&#8217;, markers are shown as milliseconds, seconds,
minutes, or hours.  (See <a class="reference internal" href="#librosa.display.time_ticks" title="librosa.display.time_ticks"><tt class="xref py py-func docutils literal"><span class="pre">time_ticks()</span></tt></a> for details.)</p>
<p class="last">If &#8216;frames&#8217;, markers are shown as frame counts.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>y_axis <span class="classifier-delimiter">:</span> <span class="classifier">None or str</span></dt>
<dd><p class="first">Range for the y-axis.  Valid types are:</p>
<ul class="last simple">
<li>None or &#8216;off&#8217;: no y axis is displayed.</li>
<li>&#8216;linear&#8217;: frequency range is determined by the FFT window
and sampling rate.</li>
<li>&#8216;log&#8217;: the image is displayed on a vertical log scale.</li>
<li>&#8216;mel&#8217;: frequencies are determined by the mel scale.</li>
<li>&#8216;cqt_hz&#8217;: frequencies are determined by the CQT scale.</li>
<li>&#8216;cqt_note&#8217;: pitches are determined by the CQT scale.</li>
<li>&#8216;chroma&#8217;: pitches are determined by the chroma filters.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_xticks <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">If x_axis is drawn, the number of ticks to show</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_yticks <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">If y_axis is drawn, the number of ticks to show</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar] or None</span></dt>
<dd><p class="first last">Frequency of the lowest spectrogram bin.  Used for Mel and CQT
scales.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fmax <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar] or None</span></dt>
<dd><p class="first last">Used for setting the Mel frequency scales</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Number of bins per octave.  Used for CQT frequency scale.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwargs</em></dt>
<dd><p class="first last">Additional keyword arguments passed through to
<tt class="docutils literal"><span class="pre">matplotlib.pyplot.imshow</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>image <span class="classifier-delimiter">:</span> <span class="classifier"><tt class="docutils literal"><span class="pre">matplotlib.image.AxesImage</span></tt></span></dt>
<dd><p class="first last">As returned from <tt class="docutils literal"><span class="pre">matplotlib.pyplot.imshow</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">If y_axis is &#8216;cqt_hz&#8217; or &#8216;cqt_note&#8217; and <tt class="docutils literal"><span class="pre">fmin</span></tt> is not supplied.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="effects">
<span id="id2"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">Effects</span></tt><a class="headerlink" href="#effects" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-librosa.effects"></span><p>Effects and filters for audio buffer data</p>
<dl class="function">
<dt id="librosa.effects.hpss">
<tt class="descclassname">librosa.effects.</tt><tt class="descname">hpss</tt><big>(</big><em>y</em><big>)</big><a class="headerlink" href="#librosa.effects.hpss" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose an audio time series into harmonic and percussive components.</p>
<p>This function automates the STFT-&gt;HPSS-&gt;ISTFT pipeline, and ensures that
the output waveforms have equal length to the input waveform <tt class="docutils literal"><span class="pre">y</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Load a waveform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.mp3&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_harmonic</span><span class="p">,</span> <span class="n">y_percussive</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">effects</span><span class="o">.</span><span class="n">hpss</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">audio time series</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>y_harmonic <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">audio time series of the harmonic elements</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>y_percussive <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">audio time series of the percussive elements</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#librosa.decompose.hpss" title="librosa.decompose.hpss"><tt class="xref py py-func docutils literal"><span class="pre">librosa.decompose.hpss()</span></tt></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.effects.harmonic">
<tt class="descclassname">librosa.effects.</tt><tt class="descname">harmonic</tt><big>(</big><em>y</em><big>)</big><a class="headerlink" href="#librosa.effects.harmonic" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract harmonic elements from an audio time-series.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Load a waveform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.mp3&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_harmonic</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">effects</span><span class="o">.</span><span class="n">harmonic</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">audio time series</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>y_harmonic <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">audio time series of just the harmonic portion</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#librosa.decompose.hpss" title="librosa.decompose.hpss"><tt class="xref py py-func docutils literal"><span class="pre">librosa.decompose.hpss()</span></tt></a>, <a class="reference internal" href="#librosa.effects.hpss" title="librosa.effects.hpss"><tt class="xref py py-func docutils literal"><span class="pre">librosa.effects.hpss()</span></tt></a>,
<a class="reference internal" href="#librosa.effects.percussive" title="librosa.effects.percussive"><tt class="xref py py-func docutils literal"><span class="pre">librosa.effects.percussive()</span></tt></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.effects.percussive">
<tt class="descclassname">librosa.effects.</tt><tt class="descname">percussive</tt><big>(</big><em>y</em><big>)</big><a class="headerlink" href="#librosa.effects.percussive" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract percussive elements from an audio time-series.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Load a waveform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.mp3&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_percussive</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">effects</span><span class="o">.</span><span class="n">percussive</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">audio time series</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>y_percussive <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">audio time series of just the percussive portion</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#librosa.decompose.hpss" title="librosa.decompose.hpss"><tt class="xref py py-func docutils literal"><span class="pre">librosa.decompose.hpss()</span></tt></a>, <a class="reference internal" href="#librosa.effects.hpss" title="librosa.effects.hpss"><tt class="xref py py-func docutils literal"><span class="pre">librosa.effects.hpss()</span></tt></a>,
<a class="reference internal" href="#librosa.effects.percussive" title="librosa.effects.percussive"><tt class="xref py py-func docutils literal"><span class="pre">librosa.effects.percussive()</span></tt></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.effects.time_stretch">
<tt class="descclassname">librosa.effects.</tt><tt class="descname">time_stretch</tt><big>(</big><em>y</em>, <em>rate</em><big>)</big><a class="headerlink" href="#librosa.effects.time_stretch" title="Permalink to this definition">¶</a></dt>
<dd><p>Time-stretch an audio series by a fixed rate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Load a waveform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.mp3&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Compress to be twice as fast</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_fast</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">effects</span><span class="o">.</span><span class="n">time_stretch</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Or half the original speed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_slow</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">effects</span><span class="o">.</span><span class="n">time_stretch</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">audio time series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>rate <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Stretch factor.  If <tt class="docutils literal"><span class="pre">rate</span> <span class="pre">&gt;</span> <span class="pre">1</span></tt>, then the signal is sped up.
If <tt class="docutils literal"><span class="pre">rate</span> <span class="pre">&lt;</span> <span class="pre">1</span></tt>, then the signal is slowed down.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>y_stretch <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(rate * n,)]</span></dt>
<dd><p class="first last">audio time series stretched by the specified rate</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#librosa.core.phase_vocoder" title="librosa.core.phase_vocoder"><tt class="xref py py-func docutils literal"><span class="pre">librosa.core.phase_vocoder()</span></tt></a>,
<a class="reference internal" href="#librosa.effects.pitch_shift" title="librosa.effects.pitch_shift"><tt class="xref py py-func docutils literal"><span class="pre">librosa.effects.pitch_shift()</span></tt></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.effects.pitch_shift">
<tt class="descclassname">librosa.effects.</tt><tt class="descname">pitch_shift</tt><big>(</big><em>y</em>, <em>sr</em>, <em>n_steps</em>, <em>bins_per_octave=12</em><big>)</big><a class="headerlink" href="#librosa.effects.pitch_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Pitch-shift the waveform by <tt class="docutils literal"><span class="pre">n_steps</span></tt> half-steps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Load a waveform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.mp3&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Shift up by a major third (four half-steps)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_third</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">effects</span><span class="o">.</span><span class="n">pitch_shift</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Shift down by a tritone (six half-steps)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_tritone</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">effects</span><span class="o">.</span><span class="n">pitch_shift</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=-</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Shift up by 3 quarter-tones</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_three_qt</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">effects</span><span class="o">.</span><span class="n">pitch_shift</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                             bins_per_octave=24)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">audio time-series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">audio sampling rate of <tt class="docutils literal"><span class="pre">y</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_steps <span class="classifier-delimiter">:</span> <span class="classifier">float [scalar]</span></dt>
<dd><p class="first last">how many (fractional) half-steps to shift <tt class="docutils literal"><span class="pre">y</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd><p class="first last">how many steps per octave</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>y_shift <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">The pitch-shifted audio time-series</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#librosa.core.phase_vocoder" title="librosa.core.phase_vocoder"><tt class="xref py py-func docutils literal"><span class="pre">librosa.core.phase_vocoder()</span></tt></a>,
<a class="reference internal" href="#librosa.effects.time_stretch" title="librosa.effects.time_stretch"><tt class="xref py py-func docutils literal"><span class="pre">librosa.effects.time_stretch()</span></tt></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-librosa.feature">
<span id="feature-extraction"></span><span id="feature"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">Feature</span> <span class="pre">extraction</span></tt><a class="headerlink" href="#module-librosa.feature" title="Permalink to this headline">¶</a></h2>
<p>Feature extraction routines.</p>
<dl class="function">
<dt id="librosa.feature.logfsgram">
<tt class="descclassname">librosa.feature.</tt><tt class="descname">logfsgram</tt><big>(</big><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>n_fft=4096</em>, <em>hop_length=512</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.feature.logfsgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a log-frequency spectrogram (piano roll) using a fixed-window STFT.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># From time-series input</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S_log</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">logfsgram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or from power spectrogram input</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span>           <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S_log</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">logfsgram</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Convert to chroma</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chroma_map</span>  <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">cq_to_chroma</span><span class="p">(</span><span class="n">S_log</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span>           <span class="o">=</span> <span class="n">chroma_map</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S_log</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd><p class="first last">audio time series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">audio sampling rate of <tt class="docutils literal"><span class="pre">y</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)] or None</span></dt>
<dd><p class="first last">(optional) power spectrogram</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">FFT window size</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">hop length for STFT. See <a class="reference internal" href="#librosa.core.stft" title="librosa.core.stft"><tt class="xref py py-func docutils literal"><span class="pre">librosa.core.stft()</span></tt></a> for details.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Number of bins per octave. Defaults to 12.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">float in <tt class="docutils literal"><span class="pre">[-0.5,</span>&nbsp; <span class="pre">0.5)</span></tt> [scalar]</span></dt>
<dd><p class="first">Deviation (in fractions of a bin) from A440 tuning.</p>
<p class="last">If not provided, it will be automatically estimated.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwargs</em></dt>
<dd><p class="first last">Additional keyword arguments.
See <a class="reference internal" href="#librosa.filters.logfrequency" title="librosa.filters.logfrequency"><tt class="xref py py-func docutils literal"><span class="pre">librosa.filters.logfrequency()</span></tt></a></p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>P <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_pitches, t)]</span></dt>
<dd><p class="first last">P(f, t) contains the energy at pitch bin f, frame t.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>One of either <tt class="docutils literal"><span class="pre">S</span></tt> or <tt class="docutils literal"><span class="pre">y</span></tt> must be provided.
If <tt class="docutils literal"><span class="pre">y</span></tt> is provided, the power spectrogram is computed
automatically given the parameters <tt class="docutils literal"><span class="pre">n_fft</span></tt> and <tt class="docutils literal"><span class="pre">hop_length</span></tt>.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">S</span></tt> is provided, it is used as the input spectrogram, and
<tt class="docutils literal"><span class="pre">n_fft</span></tt> is inferred from its shape.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.chromagram">
<tt class="descclassname">librosa.feature.</tt><tt class="descname">chromagram</tt><big>(</big><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>norm=inf</em>, <em>n_fft=2048</em>, <em>hop_length=512</em>, <em>tuning=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.feature.chromagram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a chromagram from a spectrogram or waveform</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">chromagram</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Use a pre-computed spectrogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">4096</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">chromagram</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd><p class="first last">audio time series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">sampling rate of <tt class="docutils literal"><span class="pre">y</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)] or None</span></dt>
<dd><p class="first last">power spectrogram</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first">Column-wise normalization.
See <a class="reference internal" href="#librosa.util.normalize" title="librosa.util.normalize"><tt class="xref py py-func docutils literal"><span class="pre">librosa.util.normalize()</span></tt></a> for details.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">None</span></tt>, no normalization is performed.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int  &gt; 0 [scalar]</span></dt>
<dd><p class="first last">FFT window size if provided <tt class="docutils literal"><span class="pre">y,</span> <span class="pre">sr</span></tt> instead of <tt class="docutils literal"><span class="pre">S</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">hop length if provided <tt class="docutils literal"><span class="pre">y,</span> <span class="pre">sr</span></tt> instead of <tt class="docutils literal"><span class="pre">S</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">float in <tt class="docutils literal"><span class="pre">[-0.5,</span> <span class="pre">0.5)</span></tt> [scalar] or None.</span></dt>
<dd><p class="first last">Deviation from A440 tuning in fractional bins (cents).
If <tt class="docutils literal"><span class="pre">None</span></tt>, it is automatically estimated.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwargs</em></dt>
<dd><p class="first last">Additional keyword arguments to parameterize chroma filters.
See <a class="reference internal" href="#librosa.filters.chroma" title="librosa.filters.chroma"><tt class="xref py py-func docutils literal"><span class="pre">librosa.filters.chroma()</span></tt></a> for details.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">One of either <tt class="docutils literal"><span class="pre">S</span></tt> or <tt class="docutils literal"><span class="pre">y</span></tt> must be provided.
If <tt class="docutils literal"><span class="pre">y</span></tt> is provided, the magnitude spectrogram is computed
automatically given the parameters <tt class="docutils literal"><span class="pre">n_fft</span></tt> and <tt class="docutils literal"><span class="pre">hop_length</span></tt>.
If <tt class="docutils literal"><span class="pre">S</span></tt> is provided, it is used as the input spectrogram, and
<tt class="docutils literal"><span class="pre">n_fft</span></tt> is inferred from its shape.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>chromagram <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_chroma, t)]</span></dt>
<dd><p class="first last">Normalized energy for each chroma bin at each frame.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">if an improper value is supplied for norm</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.estimate_tuning">
<tt class="descclassname">librosa.feature.</tt><tt class="descname">estimate_tuning</tt><big>(</big><em>resolution=0.01</em>, <em>bins_per_octave=12</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.feature.estimate_tuning" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the tuning of an audio time series or spectrogram input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># With time-series input</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">estimate_tuning</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># In tenths of a cent</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">estimate_tuning</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Using spectrogram input</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">estimate_tuning</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Using pass-through arguments to ``librosa.feature.piptrack``</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">estimate_tuning</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">8192</span><span class="p">,</span>
<span class="go">                          fmax=librosa.midi_to_hz(128)))</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>resolution <span class="classifier-delimiter">:</span> <span class="classifier">float in <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">1)</span></tt></span></dt>
<dd><p class="first last">Resolution of the tuning as a fraction of a bin.
0.01 corresponds to cents.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">How many frequency bins per octave</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwargs</em></dt>
<dd><p class="first last">Additional keyword arguments.  See <a class="reference internal" href="#librosa.feature.piptrack" title="librosa.feature.piptrack"><tt class="xref py py-func docutils literal"><span class="pre">librosa.feature.piptrack()</span></tt></a></p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>tuning: float in <tt class="docutils literal"><span class="pre">[-0.5,</span> <span class="pre">0.5)</span></tt></dt>
<dd><p class="first last">estimated tuning deviation (fractions of a bin)</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.pitch_tuning">
<tt class="descclassname">librosa.feature.</tt><tt class="descname">pitch_tuning</tt><big>(</big><em>frequencies</em>, <em>resolution=0.01</em>, <em>bins_per_octave=12</em><big>)</big><a class="headerlink" href="#librosa.feature.pitch_tuning" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a collection of pitches, estimate its tuning offset
(in fractions of a bin) relative to A440=440.0Hz.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Generate notes at +25 cents</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freqs</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">cqt_frequencies</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="n">tuning</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">pitch_tuning</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>
<span class="go">0.25</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Track frequencies from a real spectrogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pitches</span><span class="p">,</span> <span class="n">magnitudes</span><span class="p">,</span> <span class="n">stft</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">ifptrack</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Select out pitches with high energy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pitches</span> <span class="o">=</span> <span class="n">pitches</span><span class="p">[</span><span class="n">magnitudes</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">magnitudes</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">pitch_tuning</span><span class="p">(</span><span class="n">pitches</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">array-like, float</span></dt>
<dd><p class="first last">A collection of frequencies detected in the signal.
See <a class="reference internal" href="#librosa.feature.piptrack" title="librosa.feature.piptrack"><tt class="xref py py-func docutils literal"><span class="pre">librosa.feature.piptrack()</span></tt></a></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>resolution <span class="classifier-delimiter">:</span> <span class="classifier">float in <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">1)</span></tt></span></dt>
<dd><p class="first last">Resolution of the tuning as a fraction of a bin.
0.01 corresponds to cents.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">How many frequency bins per octave</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>tuning: float in <tt class="docutils literal"><span class="pre">[-0.5,</span> <span class="pre">0.5)</span></tt></dt>
<dd><p class="first last">estimated tuning deviation (fractions of a bin)</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="#librosa.feature.estimate_tuning" title="librosa.feature.estimate_tuning"><tt class="xref py py-func docutils literal"><span class="pre">librosa.feature.estimate_tuning()</span></tt></a>
For estimating tuning from time-series or spectrogram input</li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.ifptrack">
<tt class="descclassname">librosa.feature.</tt><tt class="descname">ifptrack</tt><big>(</big><em>y</em>, <em>sr=22050</em>, <em>n_fft=4096</em>, <em>hop_length=None</em>, <em>fmin=None</em>, <em>fmax=None</em>, <em>threshold=0.75</em><big>)</big><a class="headerlink" href="#librosa.feature.ifptrack" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantaneous pitch frequency tracking.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pitches</span><span class="p">,</span> <span class="n">magnitudes</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">ifptrack</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>y: np.ndarray [shape=(n,)]</dt>
<dd><p class="first last">audio signal</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">audio sampling rate of <tt class="docutils literal"><span class="pre">y</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_fft: int &gt; 0 [scalar]</dt>
<dd><p class="first last">FFT window size</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar] or None</span></dt>
<dd><p class="first last">Hop size for STFT.  Defaults to <tt class="docutils literal"><span class="pre">n_fft</span> <span class="pre">/</span> <span class="pre">4</span></tt>.
See <a class="reference internal" href="#librosa.core.stft" title="librosa.core.stft"><tt class="xref py py-func docutils literal"><span class="pre">librosa.core.stft()</span></tt></a> for details.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>threshold <span class="classifier-delimiter">:</span> <span class="classifier">float in <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">1)</span></tt></span></dt>
<dd><p class="first last">Maximum fraction of expected frequency increment to tolerate</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float or tuple of float</span></dt>
<dd><p class="first">Ramp parameter for lower frequency cutoff.</p>
<p>If scalar, the ramp has 0 width.</p>
<p>If tuple, a linear ramp is applied from <tt class="docutils literal"><span class="pre">fmin[0]</span></tt> to <tt class="docutils literal"><span class="pre">fmin[1]</span></tt></p>
<p class="last">Default: (150.0, 300.0)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fmax <span class="classifier-delimiter">:</span> <span class="classifier">float or tuple of float</span></dt>
<dd><p class="first">Ramp parameter for upper frequency cutoff.</p>
<p>If scalar, the ramp has 0 width.</p>
<p>If tuple, a linear ramp is applied from <tt class="docutils literal"><span class="pre">fmax[0]</span></tt> to <tt class="docutils literal"><span class="pre">fmax[1]</span></tt></p>
<p class="last">Default: (2000.0, 4000.0)</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><p class="first">pitches : np.ndarray [shape=(d, t)]</p>
</li>
<li><dl class="first docutils">
<dt>magnitudes <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)]</span></dt>
<dd><p class="first">Where <tt class="docutils literal"><span class="pre">d</span></tt> is the subset of FFT bins within <tt class="docutils literal"><span class="pre">fmin</span></tt> and <tt class="docutils literal"><span class="pre">fmax</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">pitches[i,</span> <span class="pre">t]</span></tt> contains instantaneous frequencies at time <tt class="docutils literal"><span class="pre">t</span></tt></p>
<p class="last"><tt class="docutils literal"><span class="pre">magnitudes[i,</span> <span class="pre">t]</span></tt> contains their magnitudes.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>D <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t), dtype=complex]</span></dt>
<dd><p class="first last">STFT matrix</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.piptrack">
<tt class="descclassname">librosa.feature.</tt><tt class="descname">piptrack</tt><big>(</big><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>n_fft=4096</em>, <em>fmin=150.0</em>, <em>fmax=4000.0</em>, <em>threshold=0.1</em><big>)</big><a class="headerlink" href="#librosa.feature.piptrack" title="Permalink to this definition">¶</a></dt>
<dd><p>Pitch tracking on thresholded parabolically-interpolated STFT</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pitches</span><span class="p">,</span> <span class="n">magnitudes</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">piptrack</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>y: np.ndarray [shape=(n,)] or None</dt>
<dd><p class="first last">audio signal</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">audio sampling rate of <tt class="docutils literal"><span class="pre">y</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>S: np.ndarray [shape=(d, t)] or None</dt>
<dd><p class="first last">magnitude or power spectrogram</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar] or None</span></dt>
<dd><p class="first last">number of fft bins to use, if <tt class="docutils literal"><span class="pre">y</span></tt> is provided.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>threshold <span class="classifier-delimiter">:</span> <span class="classifier">float in <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">1)</span></tt></span></dt>
<dd><p class="first last">A bin in spectrum X is considered a pitch when it is greater than
<tt class="docutils literal"><span class="pre">threshold*X.max()</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd><p class="first last">lower frequency cutoff.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fmax <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd><p class="first last">upper frequency cutoff.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>One of <tt class="docutils literal"><span class="pre">S</span></tt> or <tt class="docutils literal"><span class="pre">y</span></tt> must be provided.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">S</span></tt> is not given, it is computed from <tt class="docutils literal"><span class="pre">y</span></tt> using
the default parameters of <tt class="docutils literal"><span class="pre">stft</span></tt>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul>
<li>pitches : np.ndarray [shape=(d, t)]</li>
<li><dl class="first docutils">
<dt>magnitudes <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d,t)]</span></dt>
<dd>Where <tt class="docutils literal"><span class="pre">d</span></tt> is the subset of FFT bins within <tt class="docutils literal"><span class="pre">fmin</span></tt> and <tt class="docutils literal"><span class="pre">fmax</span></tt>.<p><tt class="docutils literal"><span class="pre">pitches[f,</span> <span class="pre">t]</span></tt> contains instantaneous frequency at bin
<tt class="docutils literal"><span class="pre">f</span></tt>, time <tt class="docutils literal"><span class="pre">t</span></tt></p>
<p><tt class="docutils literal"><span class="pre">magnitudes[f,</span> <span class="pre">t]</span></tt> contains the corresponding magnitudes.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Both <tt class="docutils literal"><span class="pre">pitches</span></tt> and <tt class="docutils literal"><span class="pre">magnitudes</span></tt> take value 0 at bins
of non-maximal magnitude.</p>
</div>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><a class="reference external" href="https://ccrma.stanford.edu/~jos/sasp/Sinusoidal_Peak_Interpolation.html">https://ccrma.stanford.edu/~jos/sasp/Sinusoidal_Peak_Interpolation.html</a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.mfcc">
<tt class="descclassname">librosa.feature.</tt><tt class="descname">mfcc</tt><big>(</big><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>n_mfcc=20</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.feature.mfcc" title="Permalink to this definition">¶</a></dt>
<dd><p>Mel-frequency cepstral coefficients</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Generate mfccs from a time series</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mfccs</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">mfcc</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Use a pre-computed log-power Mel spectrogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_mels</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span>
<span class="go">                                       fmax=8000)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mfccs</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">mfcc</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">librosa</span><span class="o">.</span><span class="n">logamplitude</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Get more components</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mfccs</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">mfcc</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_mfcc</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd><p class="first last">audio time series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">sampling rate of <tt class="docutils literal"><span class="pre">y</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)] or None</span></dt>
<dd><p class="first last">log-power Mel spectrogram</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_mfcc: int &gt; 0 [scalar]</dt>
<dd><p class="first last">number of MFCCs to return</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwargs</em></dt>
<dd><p class="first last">Additional keyword arguments for
<a class="reference internal" href="#librosa.feature.melspectrogram" title="librosa.feature.melspectrogram"><tt class="xref py py-func docutils literal"><span class="pre">librosa.feature.melspectrogram()</span></tt></a>, if operating on time series</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>One of <tt class="docutils literal"><span class="pre">S</span></tt> or <tt class="docutils literal"><span class="pre">y,</span> <span class="pre">sr</span></tt> must be provided.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">S</span></tt> is not given, it is computed from <tt class="docutils literal"><span class="pre">y,</span> <span class="pre">sr</span></tt> using
the default parameters of <tt class="docutils literal"><span class="pre">melspectrogram</span></tt>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul>
<li><dl class="first docutils">
<dt>M <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_mfcc, t)]</span></dt>
<dd>MFCC sequence</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.melspectrogram">
<tt class="descclassname">librosa.feature.</tt><tt class="descname">melspectrogram</tt><big>(</big><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>n_fft=2048</em>, <em>hop_length=512</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.feature.melspectrogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a Mel-scaled power spectrogram.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Using a pre-computed power spectrogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">D</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Passing through arguments to the Mel filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_mels</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span>
<span class="go">                                       fmax=8000)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)] or None</span></dt>
<dd><p class="first last">audio time-series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">sampling rate of <tt class="docutils literal"><span class="pre">y</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)]</span></dt>
<dd><p class="first last">magnitude or power spectrogram</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">length of the FFT window</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first">number of samples between successive frames.</p>
<p class="last">See <a class="reference internal" href="#librosa.core.stft" title="librosa.core.stft"><tt class="xref py py-func docutils literal"><span class="pre">librosa.core.stft()</span></tt></a></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwargs</em></dt>
<dd><p class="first last">Additional keyword arguments for mel filterbank parameters.
See <a class="reference internal" href="#librosa.filters.mel" title="librosa.filters.mel"><tt class="xref py py-func docutils literal"><span class="pre">librosa.filters.mel()</span></tt></a> for details.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>One of either <tt class="docutils literal"><span class="pre">S</span></tt> or <tt class="docutils literal"><span class="pre">y,</span> <span class="pre">sr</span></tt> must be provided.
If the pair <tt class="docutils literal"><span class="pre">y,</span> <span class="pre">sr</span></tt> is provided, the power spectrogram is computed.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">S</span></tt> is provided, it is used as the spectrogram, and the
parameters <tt class="docutils literal"><span class="pre">y,</span> <span class="pre">n_fft,</span> <span class="pre">hop_length</span></tt> are ignored.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul>
<li><dl class="first docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_mels, t)]</span></dt>
<dd>Mel power spectrogram</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.delta">
<tt class="descclassname">librosa.feature.</tt><tt class="descname">delta</tt><big>(</big><em>data</em>, <em>width=9</em>, <em>order=1</em>, <em>axis=-1</em>, <em>trim=True</em><big>)</big><a class="headerlink" href="#librosa.feature.delta" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute delta features.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Compute MFCC deltas, delta-deltas</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mfccs</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">mfcc</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delta_mfcc</span>  <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">delta</span><span class="p">(</span><span class="n">mfccs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delta2_mfcc</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">delta</span><span class="p">(</span><span class="n">mfccs</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, T)]</span></dt>
<dd><p class="first last">the input data matrix (eg, spectrogram)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>width <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0, odd [scalar]</span></dt>
<dd><p class="first last">Number of frames over which to compute the delta feature</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">the order of the difference operator.
1 for first derivative, 2 for second, etc.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int [scalar]</span></dt>
<dd><p class="first last">the axis along which to compute deltas.
Default is -1 (columns).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>trim <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">set to True to trim the output matrix to the original size.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>delta_data <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t) or (d, t + window)]</span></dt>
<dd><p class="first last">delta matrix of <tt class="docutils literal"><span class="pre">data</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.stack_memory">
<tt class="descclassname">librosa.feature.</tt><tt class="descname">stack_memory</tt><big>(</big><em>data</em>, <em>n_steps=2</em>, <em>delay=1</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.feature.stack_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Short-term history embedding: vertically concatenate a data
vector or matrix with delayed copies of itself.</p>
<p>Each column <tt class="docutils literal"><span class="pre">data[:,</span> <span class="pre">i]</span></tt> is mapped to:</p>
<div class="highlight-python"><div class="highlight"><pre>data[:, i] -&gt;  [ data[:, i],                        ...
                 data[:, i - delay],                ...
                 ...
                 data[:, i - (n_steps-1)*delay],    ...
               ]
</pre></div>
</div>
<p>For columns <tt class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">(n_steps</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">delay</span></tt> , the data will be padded.
By default, the data is padded with zeros, but this behavior can be
overridden by supplying additional keyword arguments which are passed
to <tt class="docutils literal"><span class="pre">np.pad()</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Generate a data vector</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Keep two steps (current and previous)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">stack_memory</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">array([[-3, -2, -1,  0,  1,  2],</span>
<span class="go">       [ 0, -3, -2, -1,  0,  1]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or three steps</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">stack_memory</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([[-3, -2, -1,  0,  1,  2],</span>
<span class="go">       [ 0, -3, -2, -1,  0,  1],</span>
<span class="go">       [ 0,  0, -3, -2, -1,  0]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Use reflection padding instead of zero-padding</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">stack_memory</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;reflect&#39;</span><span class="p">)</span>
<span class="go">array([[-3, -2, -1,  0,  1,  2],</span>
<span class="go">       [-2, -3, -2, -1,  0,  1],</span>
<span class="go">       [-1, -2, -3, -2, -1,  0]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or pad with edge-values, and delay by 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">stack_memory</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;edge&#39;</span><span class="p">)</span>
<span class="go">array([[-3, -2, -1,  0,  1,  2],</span>
<span class="go">       [-3, -3, -3, -2, -1,  0],</span>
<span class="go">       [-3, -3, -3, -3, -3, -2]])</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(t,) or (d, t)]</span></dt>
<dd><p class="first last">Input data matrix.  If <tt class="docutils literal"><span class="pre">data</span></tt> is a vector (<tt class="docutils literal"><span class="pre">data.ndim</span> <span class="pre">==</span> <span class="pre">1</span></tt>),
it will be interpreted as a row matrix and reshaped to <tt class="docutils literal"><span class="pre">(1,</span> <span class="pre">t)</span></tt>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_steps <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">embedding dimension, the number of steps back in time to stack</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>delay <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">the number of columns to step</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwargs</em></dt>
<dd><p class="first last">Additional arguments to pass to <tt class="docutils literal"><span class="pre">np.pad</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>data_history <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(m * d, t)]</span></dt>
<dd><p class="first last">data augmented with lagged copies of itself,
where <tt class="docutils literal"><span class="pre">m</span> <span class="pre">==</span> <span class="pre">n_steps</span> <span class="pre">-</span> <span class="pre">1</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.feature.sync">
<tt class="descclassname">librosa.feature.</tt><tt class="descname">sync</tt><big>(</big><em>data</em>, <em>frames</em>, <em>aggregate=None</em><big>)</big><a class="headerlink" href="#librosa.feature.sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Synchronous aggregation of a feature matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Beat-synchronous MFCCs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span><span class="p">,</span> <span class="n">beats</span>    <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">beat_track</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span>               <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="go">                                                     hop_length=64)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mfcc</span>            <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">mfcc</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mfcc_sync</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">sync</span><span class="p">(</span><span class="n">mfcc</span><span class="p">,</span> <span class="n">beats</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Use median-aggregation instead of mean</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mfcc_sync</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">sync</span><span class="p">(</span><span class="n">mfcc</span><span class="p">,</span> <span class="n">beats</span><span class="p">,</span>
<span class="go">                                           aggregate=np.median)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Or max aggregation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mfcc_sync</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">sync</span><span class="p">(</span><span class="n">mfcc</span><span class="p">,</span> <span class="n">beats</span><span class="p">,</span>
<span class="go">                                           aggregate=np.max)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, T)]</span></dt>
<dd><p class="first last">matrix of features</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>frames <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(m,)]</span></dt>
<dd><p class="first last">ordered array of frame segment boundaries</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>aggregate <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">aggregation function (defualt: <tt class="docutils literal"><span class="pre">np.mean</span></tt>)</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>Y <span class="classifier-delimiter">:</span> <span class="classifier">ndarray [shape=(d, M)]</span></dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">Y[:,</span> <span class="pre">i]</span> <span class="pre">=</span> <span class="pre">aggregate(data[:,</span> <span class="pre">F[i-1]:F[i]],</span> <span class="pre">axis=1)</span></tt></p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In order to ensure total coverage, boundary points may be added
to <tt class="docutils literal"><span class="pre">frames</span></tt>.</p>
<p class="last">If synchronizing a feature matrix against beat tracker output, ensure
that frame numbers are properly aligned and use the same hop length.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-librosa.filters">
<span id="filter-banks"></span><span id="filters"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">Filter</span> <span class="pre">banks</span></tt><a class="headerlink" href="#module-librosa.filters" title="Permalink to this headline">¶</a></h2>
<p>Commonly used filter banks: DCT, Chroma, Mel, CQT</p>
<dl class="function">
<dt id="librosa.filters.dct">
<tt class="descclassname">librosa.filters.</tt><tt class="descname">dct</tt><big>(</big><em>n_filters</em>, <em>n_input</em><big>)</big><a class="headerlink" href="#librosa.filters.dct" title="Permalink to this definition">¶</a></dt>
<dd><p>Discrete cosine transform (DCT) basis</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Compute MFCCs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span>           <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dct_filters</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">dct</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mfcc</span>        <span class="o">=</span> <span class="n">dct_filters</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">logamplitude</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>n_filters <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">number of output components (DCT filters)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_input <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">number of input components (frequency bins)</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>dct_basis: np.ndarray [shape=(n_filters, n_input)]</dt>
<dd><p class="first last">DCT basis vectors</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.filters.mel">
<tt class="descclassname">librosa.filters.</tt><tt class="descname">mel</tt><big>(</big><em>sr</em>, <em>n_fft</em>, <em>n_mels=128</em>, <em>fmin=0.0</em>, <em>fmax=None</em>, <em>htk=False</em><big>)</big><a class="headerlink" href="#librosa.filters.mel" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Filterbank matrix to combine FFT bins into Mel-frequency bins</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mel_fb</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">mel</span><span class="p">(</span><span class="mi">22050</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or clip the maximum frequency to 8KHz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mel_fb</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">mel</span><span class="p">(</span><span class="mi">22050</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="mi">8000</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">sampling rate of the incoming signal</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">number of FFT components</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_mels <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">number of Mel bands to generate</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt;= 0 [scalar]</span></dt>
<dd><p class="first last">lowest frequency (in Hz)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fmax <span class="classifier-delimiter">:</span> <span class="classifier">float &gt;= 0 [scalar]</span></dt>
<dd><p class="first last">highest frequency (in Hz).
If <tt class="docutils literal"><span class="pre">None</span></tt>, use <tt class="docutils literal"><span class="pre">fmax</span> <span class="pre">=</span> <span class="pre">sr</span> <span class="pre">/</span> <span class="pre">2.0</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>htk <span class="classifier-delimiter">:</span> <span class="classifier">bool [scalar]</span></dt>
<dd><p class="first last">use HTK formula instead of Slaney</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>M <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_mels, 1 + n_fft/2)]</span></dt>
<dd><p class="first last">Mel transform matrix</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.filters.chroma">
<tt class="descclassname">librosa.filters.</tt><tt class="descname">chroma</tt><big>(</big><em>sr</em>, <em>n_fft</em>, <em>n_chroma=12</em>, <em>A440=440.0</em>, <em>ctroct=5.0</em>, <em>octwidth=2</em><big>)</big><a class="headerlink" href="#librosa.filters.chroma" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Filterbank matrix to convert STFT to chroma</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Build a simple chroma filter bank</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chroma_fb</span>   <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">chroma</span><span class="p">(</span><span class="mi">22050</span><span class="p">,</span> <span class="mi">4096</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Use quarter-tones instead of semitones</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chroma_fbq</span>  <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">chroma</span><span class="p">(</span><span class="mi">22050</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">n_chroma</span><span class="o">=</span><span class="mi">24</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Equally weight all octaves</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chroma_fb</span>   <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">chroma</span><span class="p">(</span><span class="mi">22050</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">octwidth</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">audio sampling rate</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">number of FFT bins</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_chroma <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">number of chroma bins</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>A440 <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Reference frequency for A440</p>
</dd>
</dl>
</li>
<li><p class="first">ctroct    : float &gt; 0 [scalar]</p>
</li>
<li><dl class="first docutils">
<dt>octwidth <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 or None [scalar]</span></dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">ctroct</span></tt> and <tt class="docutils literal"><span class="pre">octwidth</span></tt> specify a dominance window -
a Gaussian weighting centered on <tt class="docutils literal"><span class="pre">ctroct</span></tt> (in octs, A0 = 27.5Hz)
and with a gaussian half-width of <tt class="docutils literal"><span class="pre">octwidth</span></tt>.
Set <tt class="docutils literal"><span class="pre">octwidth</span></tt> to <tt class="docutils literal"><span class="pre">None</span></tt> to use a flat weighting.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>wts <span class="classifier-delimiter">:</span> <span class="classifier">ndarray [shape=(n_chroma, 1 + n_fft / 2)]</span></dt>
<dd><p class="first last">Chroma filter matrix</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.filters.logfrequency">
<tt class="descclassname">librosa.filters.</tt><tt class="descname">logfrequency</tt><big>(</big><em>sr</em>, <em>n_fft</em>, <em>n_bins=84</em>, <em>bins_per_octave=12</em>, <em>tuning=0.0</em>, <em>fmin=None</em>, <em>spread=0.125</em><big>)</big><a class="headerlink" href="#librosa.filters.logfrequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate a constant-Q filterbank for a fixed-window STFT.</p>
<p>Each filter is a log-normal window centered at the corresponding frequency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Simple log frequency filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logfs_fb</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">logfrequency</span><span class="p">(</span><span class="mi">22050</span><span class="p">,</span> <span class="mi">4096</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Use a narrower frequency range</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logfs_fb</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">logfrequency</span><span class="p">(</span><span class="mi">22050</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span>
<span class="go">                                            n_bins=48, fmin=110)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Use narrower filters for sparser response: 5% of a semitone</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logfs_fb</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">logfrequency</span><span class="p">(</span><span class="mi">22050</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">spread</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Or wider: 50% of a semitone</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logfs_fb</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">logfrequency</span><span class="p">(</span><span class="mi">22050</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">spread</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">audio sampling rate</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_fft <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">FFT window size</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_bins <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Number of bins.  Defaults to 84 (7 octaves).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Number of bins per octave. Defaults to 12 (semitones).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">None or float in <tt class="docutils literal"><span class="pre">[-0.5,</span> <span class="pre">+0.5]</span></tt> [scalar]</span></dt>
<dd><p class="first last">Tuning correction parameter, in fractions of a bin.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Minimum frequency bin. Defaults to <tt class="docutils literal"><span class="pre">C2</span> <span class="pre">~=</span> <span class="pre">32.70</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>spread <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Spread of each filter, as a fraction of a bin.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>C <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_bins, 1 + n_fft/2)]</span></dt>
<dd><p class="first last">log-frequency filter bank.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.filters.constant_q">
<tt class="descclassname">librosa.filters.</tt><tt class="descname">constant_q</tt><big>(</big><em>sr</em>, <em>fmin=None</em>, <em>n_bins=84</em>, <em>bins_per_octave=12</em>, <em>tuning=0.0</em>, <em>window=None</em>, <em>resolution=2</em>, <em>pad=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.filters.constant_q" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a constant-Q basis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Change the windowing function to Hamming instead of Hann</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span>   <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">constant_q</span><span class="p">(</span><span class="mi">22050</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Use a longer window for each filter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span>   <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">constant_q</span><span class="p">(</span><span class="mi">22050</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Pad the basis to fixed length</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span>   <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">constant_q</span><span class="p">(</span><span class="mi">22050</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Audio sampling rate</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fmin <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Minimum frequency bin. Defaults to <tt class="docutils literal"><span class="pre">C2</span> <span class="pre">~=</span> <span class="pre">32.70</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_bins <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Number of frequencies.  Defaults to 7 octaves (84 bins).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Number of bins per octave</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>tuning <span class="classifier-delimiter">:</span> <span class="classifier">float in <tt class="docutils literal"><span class="pre">[-0.5,</span> <span class="pre">+0.5)</span></tt> [scalar]</span></dt>
<dd><p class="first last">Tuning deviation from A440 in fractions of a bin</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">function or <tt class="docutils literal"><span class="pre">None</span></tt></span></dt>
<dd><p class="first last">Windowing function to apply to filters.
If <tt class="docutils literal"><span class="pre">None</span></tt>, no window is applied.
Default: <tt class="docutils literal"><span class="pre">scipy.signal.hann</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>resolution <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Resolution of filter windows. Larger values use longer windows.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>pad <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">Pad all filters to have constant width (equal to the longest filter).
By default, padding is done with zeros, but this can be overridden
by setting the <tt class="docutils literal"><span class="pre">mode=</span></tt> field in <em>kwargs</em>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwargs</em></dt>
<dd><p class="first last">Additional keyword arguments to <tt class="docutils literal"><span class="pre">np.pad()</span></tt> when <tt class="docutils literal"><span class="pre">pad==True</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>McVicar, Matthew. &#8220;A machine learning approach to automatic chord
extraction.&#8221; Dissertation, University of Bristol. 2013.</li>
</ul>
</div>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>filters <span class="classifier-delimiter">:</span> <span class="classifier">list of np.ndarray, <tt class="docutils literal"><span class="pre">len(filters)</span> <span class="pre">==</span> <span class="pre">n_bins</span></tt></span></dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">filters[i]</span></tt> is <tt class="docutils literal"><span class="pre">i</span></tt>th CQT basis filter (in the time-domain)</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.filters.cq_to_chroma">
<tt class="descclassname">librosa.filters.</tt><tt class="descname">cq_to_chroma</tt><big>(</big><em>n_input</em>, <em>bins_per_octave=12</em>, <em>n_chroma=12</em>, <em>roll=0</em><big>)</big><a class="headerlink" href="#librosa.filters.cq_to_chroma" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Constant-Q basis to Chroma.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Get a CQT, and wrap bins to chroma</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CQT</span>         <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">cqt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chroma_map</span>  <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">cq_to_chroma</span><span class="p">(</span><span class="n">CQT</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chromagram</span>  <span class="o">=</span> <span class="n">chroma_map</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">CQT</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>n_input <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Number of input components (CQT bins)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bins_per_octave <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">How many bins per octave in the CQT</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_chroma <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Number of output bins (per octave) in the chroma</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>roll <span class="classifier-delimiter">:</span> <span class="classifier">int [scalar]</span></dt>
<dd><p class="first last">Number of bins to offset the output by.
For example, if the 0-bin of the CQT is C, and
the desired 0-bin for the chroma is A, then roll=-3.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>cq_to_chroma <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_chroma, n_input)]</span></dt>
<dd><p class="first last">Transformation matrix: <tt class="docutils literal"><span class="pre">Chroma</span> <span class="pre">=</span> <span class="pre">np.dot(cq_to_chroma,</span> <span class="pre">CQT)</span></tt></p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">If <tt class="docutils literal"><span class="pre">n_input</span></tt> is not an integer multiple of <tt class="docutils literal"><span class="pre">n_chroma</span></tt></p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-librosa.onset">
<span id="onset-detection"></span><span id="onset"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">Onset</span> <span class="pre">detection</span></tt><a class="headerlink" href="#module-librosa.onset" title="Permalink to this headline">¶</a></h2>
<p>Onset detection</p>
<dl class="function">
<dt id="librosa.onset.onset_detect">
<tt class="descclassname">librosa.onset.</tt><tt class="descname">onset_detect</tt><big>(</big><em>y=None</em>, <em>sr=22050</em>, <em>onset_envelope=None</em>, <em>hop_length=64</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.onset.onset_detect" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic onset detector.  Locate note onset events by picking peaks in an
onset strength envelope.</p>
<p>See also: <a class="reference internal" href="#librosa.onset.onset_strength" title="librosa.onset.onset_strength"><tt class="xref py py-func docutils literal"><span class="pre">librosa.onset.onset_strength()</span></tt></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Get onset times from a signal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">onset_frames</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">onset_detect</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
<span class="go">                                              sr=sr, hop_length=64)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">onset_times</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">frames_to_time</span><span class="p">(</span><span class="n">onset_frames</span><span class="p">,</span>
<span class="go">                                         sr, hop_length=64)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or use a pre-computed onset envelope</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o_env</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">onset_strength</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">onset_frames</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">onset_detect</span><span class="p">(</span><span class="n">onset_envelope</span><span class="o">=</span><span class="n">o_env</span><span class="p">,</span>
<span class="go">                                              sr=sr)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">onset_times</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">frames_to_time</span><span class="p">(</span><span class="n">onset_frames</span><span class="p">,</span>
<span class="go">                                         sr, hop_length=64)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">audio time series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">sampling rate of <tt class="docutils literal"><span class="pre">y</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>onset_envelope <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(m,)]</span></dt>
<dd><p class="first last">(optional) pre-computed onset stength envelope</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">hop length (in samples)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwargs</em></dt>
<dd><p class="first">Additional parameters for peak picking</p>
<p class="last">See <a class="reference internal" href="#librosa.core.peak_pick" title="librosa.core.peak_pick"><tt class="xref py py-func docutils literal"><span class="pre">librosa.core.peak_pick()</span></tt></a> for details</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>onsets <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n_onsets,)]</span></dt>
<dd><p class="first last">estimated frame numbers of onsets</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">if neither <tt class="docutils literal"><span class="pre">y</span></tt> nor <tt class="docutils literal"><span class="pre">onsets</span></tt> are provided</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If no onset strength could be detected, onset_detect returns
an empty list.</p>
<p class="last">The peak_pick parameters were chosen by large-scale hyper-parameter
optimization over this dataset:
<a class="reference external" href="https://github.com/CPJKU/onset_db">https://github.com/CPJKU/onset_db</a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.onset.onset_strength">
<tt class="descclassname">librosa.onset.</tt><tt class="descname">onset_strength</tt><big>(</big><em>y=None</em>, <em>sr=22050</em>, <em>S=None</em>, <em>detrend=False</em>, <em>centering=True</em>, <em>feature=None</em>, <em>aggregate=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.onset.onset_strength" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a spectral flux onset strength envelope.</p>
<p>Onset strength at time t is determined by:</p>
<p><tt class="docutils literal"><span class="pre">mean_f</span> <span class="pre">max(0,</span> <span class="pre">S[f,</span> <span class="pre">t+1]</span> <span class="pre">-</span> <span class="pre">S[f,</span> <span class="pre">t])</span></tt></p>
<p>By default, if a time series <tt class="docutils literal"><span class="pre">y</span></tt> is provided, S will be the
log-power Mel spectrogram.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Mean aggregation with Mel-scaled spectrogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o_env</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">onset_strength</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Median aggregation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o_env</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">onset_strength</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span>
<span class="go">                                         aggregate=np.median)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Log-frequency spectrogram instead of Mel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o_env</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">onset_strength</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span>
<span class="go">                                         feature=librosa.feature.logfsgram)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or Mel spectrogram with customized options</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o_env</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">onset_strength</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span>
<span class="go">                                         n_mels=128,</span>
<span class="go">                                         fmin=32,</span>
<span class="go">                                         fmax=8000)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">audio time-series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">sampling rate of <tt class="docutils literal"><span class="pre">y</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, m)]</span></dt>
<dd><p class="first last">pre-computed (log-power) spectrogram</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>detrend <span class="classifier-delimiter">:</span> <span class="classifier">bool [scalar]</span></dt>
<dd><p class="first last">Filter the onset strength to remove the DC component</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>centering <span class="classifier-delimiter">:</span> <span class="classifier">bool [scalar]</span></dt>
<dd><p class="first last">Shift the onset function by <tt class="docutils literal"><span class="pre">n_fft</span> <span class="pre">/</span> <span class="pre">(2</span> <span class="pre">*</span> <span class="pre">hop_length)</span></tt> frames</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>feature <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">Function for computing time-series features, eg, scaled spectrograms.
By default, uses <a class="reference internal" href="#librosa.feature.melspectrogram" title="librosa.feature.melspectrogram"><tt class="xref py py-func docutils literal"><span class="pre">librosa.feature.melspectrogram()</span></tt></a></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>aggregate <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">Aggregation function to use when combining onsets
at different frequency bins.
Default: <tt class="docutils literal"><span class="pre">np.mean</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwargs</em></dt>
<dd><p class="first last">Additional parameters to <tt class="docutils literal"><span class="pre">feature()</span></tt>, if <tt class="docutils literal"><span class="pre">S</span></tt> is not provided.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if <tt class="docutils literal"><span class="pre">S</span></tt> is provided, then <tt class="docutils literal"><span class="pre">(y,</span> <span class="pre">sr)</span></tt> are optional.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>onset_envelope <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(m,)]</span></dt>
<dd><p class="first last">vector containing the onset strength envelope</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">if neither <tt class="docutils literal"><span class="pre">(y,</span> <span class="pre">sr)</span></tt> nor <tt class="docutils literal"><span class="pre">S</span></tt> are provided</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="output">
<span id="id3"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">Output</span></tt><a class="headerlink" href="#output" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-librosa.output"></span><p>Output routines for audio and analysis</p>
<dl class="function">
<dt id="librosa.output.annotation">
<tt class="descclassname">librosa.output.</tt><tt class="descname">annotation</tt><big>(</big><em>path</em>, <em>intervals</em>, <em>annotations=None</em>, <em>delimiter='</em>, <em>'</em>, <em>fmt='%0.3f'</em><big>)</big><a class="headerlink" href="#librosa.output.annotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Save annotations in a 3-column format:</p>
<div class="highlight-python"><div class="highlight"><pre>intervals[0, 0],intervals[0, 1],annotations[0]\n
intervals[1, 0],intervals[1, 1],annotations[1]\n
intervals[2, 0],intervals[2, 1],annotations[2]\n
...
</pre></div>
</div>
<p>This can be used for segment or chord annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Detect segment boundaries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">boundaries</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">agglomerative</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Convert to time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">boundary_times</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">frames_to_time</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="go">                                            hop_length=hop_length)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Make some fake annotations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Seg #{:03d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time_start</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Save the output</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">annotation</span><span class="p">(</span><span class="s">&#39;segments.csv&#39;</span><span class="p">,</span> <span class="n">boundary_times</span><span class="p">,</span>
<span class="go">                              annotations=annotations)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>path <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">path to save the output CSV file</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n, 2)]</span></dt>
<dd><p class="first">array of interval start and end-times.</p>
<ul class="last simple">
<li><tt class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">0]</span></tt> marks the start time of interval <tt class="docutils literal"><span class="pre">i</span></tt></li>
<li><tt class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">1]</span></tt> marks the endtime of interval <tt class="docutils literal"><span class="pre">i</span></tt></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">None or list-like [shape=(n,)]</span></dt>
<dd><p class="first last">optional list of annotation strings. <tt class="docutils literal"><span class="pre">annotations[i]</span></tt> applies
to the time range <tt class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">0]</span></tt> to <tt class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">1]</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>delimiter <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">character to separate fields</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fmt <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">format-string for rendering time data</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">if <tt class="docutils literal"><span class="pre">annotations</span></tt> is not <tt class="docutils literal"><span class="pre">None</span></tt> and length does
not match <tt class="docutils literal"><span class="pre">intervals</span></tt></p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.output.frames_csv">
<tt class="descclassname">librosa.output.</tt><tt class="descname">frames_csv</tt><big>(</big><em>path</em>, <em>frames</em>, <em>sr=22050</em>, <em>hop_length=512</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.output.frames_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert frames to time and store the output in CSV format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span><span class="p">,</span> <span class="n">beats</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">beat_track</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">frames_csv</span><span class="p">(</span><span class="s">&#39;beat_times.csv&#39;</span><span class="p">,</span> <span class="n">frames</span><span class="p">,</span>
<span class="go">                              sr=sr, hop_length=64)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>path <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">path to save the output CSV file</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>frames <span class="classifier-delimiter">:</span> <span class="classifier">list-like of ints</span></dt>
<dd><p class="first last">list of frame numbers for beat events</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">audio sampling rate</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">number of samples between success frames</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwargs</em></dt>
<dd><p class="first last">additional keyword arguments.  See <a class="reference internal" href="#librosa.output.times_csv" title="librosa.output.times_csv"><tt class="xref py py-func docutils literal"><span class="pre">librosa.output.times_csv()</span></tt></a></p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.output.times_csv">
<tt class="descclassname">librosa.output.</tt><tt class="descname">times_csv</tt><big>(</big><em>path</em>, <em>times</em>, <em>annotations=None</em>, <em>delimiter='</em>, <em>'</em>, <em>fmt='%0.3f'</em><big>)</big><a class="headerlink" href="#librosa.output.times_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Save time steps as in CSV format.  This can be used to store the output
of a beat-tracker or segmentation algorihtm.</p>
<p>If only <tt class="docutils literal"><span class="pre">times</span></tt> are provided, the file will contain each value
of <tt class="docutils literal"><span class="pre">times</span></tt> on a row:</p>
<div class="highlight-python"><div class="highlight"><pre>times[0]\n
times[1]\n
times[2]\n
...
</pre></div>
</div>
<p>If <tt class="docutils literal"><span class="pre">annotations</span></tt> are also provided, the file will contain
delimiter-separated values:</p>
<div class="highlight-python"><div class="highlight"><pre>times[0],annotations[0]\n
times[1],annotations[1]\n
times[2],annotations[2]\n
...
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tempo</span><span class="p">,</span> <span class="n">beats</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">beat_track</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">frames_to_time</span><span class="p">(</span><span class="n">beats</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">times_csv</span><span class="p">(</span><span class="s">&#39;beat_times.csv&#39;</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>path <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">path to save the output CSV file</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">list-like of floats</span></dt>
<dd><p class="first last">list of frame numbers for beat events</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>annotations <span class="classifier-delimiter">:</span> <span class="classifier">None or list-like</span></dt>
<dd><p class="first last">optional annotations for each time step</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>delimiter <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">character to separate fields</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fmt <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">format-string for rendering time</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">if <tt class="docutils literal"><span class="pre">annotations</span></tt> is not <tt class="docutils literal"><span class="pre">None</span></tt> and length does not
match <tt class="docutils literal"><span class="pre">times</span></tt></p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.output.write_wav">
<tt class="descclassname">librosa.output.</tt><tt class="descname">write_wav</tt><big>(</big><em>path</em>, <em>y</em>, <em>sr</em>, <em>normalize=True</em><big>)</big><a class="headerlink" href="#librosa.output.write_wav" title="Permalink to this definition">¶</a></dt>
<dd><p>Output a time series as a .wav file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Trim a signal to 5 seconds and save it back</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.wav&#39;</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">librosa</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">write_wav</span><span class="p">(</span><span class="s">&#39;file_trim_5s.wav&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>path <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">path to save the output wav file</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">audio time series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sr <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">sampling rate of <tt class="docutils literal"><span class="pre">y</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>normalize <span class="classifier-delimiter">:</span> <span class="classifier">boolean [scalar]</span></dt>
<dd><p class="first last">enable amplitude normalization</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-librosa.segment">
<span id="segmentation"></span><span id="segment"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">Segmentation</span></tt><a class="headerlink" href="#module-librosa.segment" title="Permalink to this headline">¶</a></h2>
<p>Temporal segmentation utilities</p>
<dl class="function">
<dt id="librosa.segment.recurrence_matrix">
<tt class="descclassname">librosa.segment.</tt><tt class="descname">recurrence_matrix</tt><big>(</big><em>data</em>, <em>k=None</em>, <em>width=1</em>, <em>metric='sqeuclidean'</em>, <em>sym=False</em><big>)</big><a class="headerlink" href="#librosa.segment.recurrence_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the binary recurrence matrix from a time-series.</p>
<p><tt class="docutils literal"><span class="pre">rec[i,j]</span> <span class="pre">==</span> <span class="pre">True</span></tt> &lt;=&gt; (<tt class="docutils literal"><span class="pre">data[:,i]</span></tt>, <tt class="docutils literal"><span class="pre">data[:,j]</span></tt>) are
k-nearest-neighbors and <tt class="docutils literal"><span class="pre">|i-j|</span> <span class="pre">&gt;=</span> <span class="pre">width</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mfcc</span>    <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">mfcc</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">recurrence_matrix</span><span class="p">(</span><span class="n">mfcc</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or fix the number of nearest neighbors to 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">recurrence_matrix</span><span class="p">(</span><span class="n">mfcc</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Suppress neighbors within +- 7 samples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">recurrence_matrix</span><span class="p">(</span><span class="n">mfcc</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Use cosine similarity instead of Euclidean distance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">recurrence_matrix</span><span class="p">(</span><span class="n">mfcc</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s">&#39;cosine&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Require mutual nearest neighbors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">recurrence_matrix</span><span class="p">(</span><span class="n">mfcc</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)]</span></dt>
<dd><p class="first last">A feature matrix</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar] or None</span></dt>
<dd><p class="first">the number of nearest-neighbors for each sample</p>
<p class="last">Default: <tt class="docutils literal"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">ceil(sqrt(t</span> <span class="pre">-</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">width</span> <span class="pre">+</span> <span class="pre">1))</span></tt>,
or <tt class="docutils literal"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">2</span></tt> if <tt class="docutils literal"><span class="pre">t</span> <span class="pre">&lt;=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">width</span> <span class="pre">+</span> <span class="pre">1</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>width <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">only link neighbors <tt class="docutils literal"><span class="pre">(data[:,</span> <span class="pre">i],</span> <span class="pre">data[:,</span> <span class="pre">j])</span></tt>
if <tt class="docutils literal"><span class="pre">|i-j|</span> <span class="pre">&gt;=</span> <span class="pre">width</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>metric <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">Distance metric to use for nearest-neighbor calculation.</p>
<p class="last">See <tt class="docutils literal"><span class="pre">scipy.spatial.distance.cdist()</span></tt> for details.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sym <span class="classifier-delimiter">:</span> <span class="classifier">bool [scalar]</span></dt>
<dd><p class="first last">set <tt class="docutils literal"><span class="pre">sym=True</span></tt> to only link mutual nearest-neighbors</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>rec <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(t,t), dtype=bool]</span></dt>
<dd><p class="first last">Binary recurrence matrix</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.segment.structure_feature">
<tt class="descclassname">librosa.segment.</tt><tt class="descname">structure_feature</tt><big>(</big><em>rec</em>, <em>pad=True</em>, <em>inverse=False</em><big>)</big><a class="headerlink" href="#librosa.segment.structure_feature" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the structure feature from a recurrence matrix.</p>
<p>The i&#8217;th column of the recurrence matrix is shifted up by i.
The resulting matrix is indexed horizontally by time,
and vertically by lag.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Build the structure feature over mfcc similarity</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mfccs</span>   <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">mfcc</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">recurrence_matrix</span><span class="p">(</span><span class="n">mfccs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span>       <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">structure_feature</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Invert the structure feature to get a recurrence matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R_hat</span>   <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">structure_feature</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>rec <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(t,t) or shape=(2*t, t)]</span></dt>
<dd><p class="first last">recurrence matrix (see <a class="reference internal" href="#librosa.segment.recurrence_matrix" title="librosa.segment.recurrence_matrix"><tt class="xref py py-func docutils literal"><span class="pre">librosa.segment.recurrence_matrix()</span></tt></a>)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>pad <span class="classifier-delimiter">:</span> <span class="classifier">bool [scalar]</span></dt>
<dd><p class="first last">Pad the matrix with <tt class="docutils literal"><span class="pre">t</span></tt> rows of zeros to avoid looping.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>inverse <span class="classifier-delimiter">:</span> <span class="classifier">bool [scalar]</span></dt>
<dd><p class="first last">Unroll the opposite direction. This is useful for converting
structure features back into recurrence plots.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>struct <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(2*t, t) or shape=(t, t)]</span></dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">struct[i,</span> <span class="pre">t]</span></tt> = the recurrence at time <tt class="docutils literal"><span class="pre">t</span></tt> with lag <tt class="docutils literal"><span class="pre">i</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">negative lag values are supported by wrapping to the
end of the array.</p>
</div>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.segment.agglomerative">
<tt class="descclassname">librosa.segment.</tt><tt class="descname">agglomerative</tt><big>(</big><em>data</em>, <em>k</em>, <em>clusterer=None</em><big>)</big><a class="headerlink" href="#librosa.segment.agglomerative" title="Permalink to this definition">¶</a></dt>
<dd><p>Bottom-up temporal segmentation.</p>
<p>Use a temporally-constrained agglomerative clustering routine to partition
<tt class="docutils literal"><span class="pre">data</span></tt> into <tt class="docutils literal"><span class="pre">k</span></tt> contiguous segments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Cluster by Mel spectrogram similarity</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Break into 32 segments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
<span class="go">                                       hop_length=512)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">boundary_frames</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">agglomerative</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">boundary_times</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">frames_to_time</span><span class="p">(</span><span class="n">boundary_frames</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
<span class="go">                                            hop_length=512)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, t)]</span></dt>
<dd><p class="first last">feature matrix</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">number of segments to produce</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>clusterer <span class="classifier-delimiter">:</span> <span class="classifier">sklearn.cluster.AgglomerativeClustering or <tt class="docutils literal"><span class="pre">None</span></tt></span></dt>
<dd><p class="first last">An optional agglomerativeclustering object.
If <tt class="docutils literal"><span class="pre">None</span></tt>, a constrained Ward object is instantiated.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>boundaries <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(k,)]</span></dt>
<dd><p class="first last">left-boundaries (frame numbers) of detected segments. This
will always include <tt class="docutils literal"><span class="pre">0</span></tt> as the first left-boundary.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-librosa.util">
<span id="utilities"></span><span id="util"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">Utilities</span></tt><a class="headerlink" href="#module-librosa.util" title="Permalink to this headline">¶</a></h2>
<p>Utility functions</p>
<dl class="function">
<dt id="librosa.util.example_audio_file">
<tt class="descclassname">librosa.util.</tt><tt class="descname">example_audio_file</tt><big>(</big><big>)</big><a class="headerlink" href="#librosa.util.example_audio_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the path to an included audio example file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Load the waveform from the example track</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">example_audio_file</span><span class="p">())</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li>None</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>filename <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Path to the audio example file included with librosa</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.util.frame">
<tt class="descclassname">librosa.util.</tt><tt class="descname">frame</tt><big>(</big><em>y</em>, <em>frame_length=2048</em>, <em>hop_length=512</em><big>)</big><a class="headerlink" href="#librosa.util.frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice a time series into overlapping frames.</p>
<p>This implementation uses low-level stride manipulation to avoid
redundant copies of the time series data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Load a file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.mp3&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Extract 2048-sample frames from y with a hop of 64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_frames</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">frame</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">frame_length</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">Time series to frame. Must be contiguous in memory</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>frame_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Length of the frame in samples</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop_length <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 [scalar]</span></dt>
<dd><p class="first last">Number of samples to hop between frames</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>y_frames <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(frame_length, N_FRAMES)]</span></dt>
<dd><p class="first last">An array of frames sampled from <tt class="docutils literal"><span class="pre">y</span></tt>:
<tt class="docutils literal"><span class="pre">y_frames[i,</span> <span class="pre">j]</span> <span class="pre">==</span> <span class="pre">y[j</span> <span class="pre">*</span> <span class="pre">hop_length</span> <span class="pre">+</span> <span class="pre">i]</span></tt></p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first">If <tt class="docutils literal"><span class="pre">y</span></tt> is not contiguous in memory, framing is invalid.
See <tt class="docutils literal"><span class="pre">np.ascontiguous()</span></tt> for details.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">hop_length</span> <span class="pre">&lt;</span> <span class="pre">1</span></tt>, frames cannot advance.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.util.pad_center">
<tt class="descclassname">librosa.util.</tt><tt class="descname">pad_center</tt><big>(</big><em>data</em>, <em>size</em>, <em>axis=-1</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.util.pad_center" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for np.pad to automatically center an array prior to padding.
This is analogous to <tt class="docutils literal"><span class="pre">str.center()</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Generate a window vector</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">hann</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Center and pad it out to length 1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;constant&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Pad a matrix along its first dimension</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Apad</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Or its second dimension</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Apad</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">pad_center</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Vector to be padded and centered</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>size <span class="classifier-delimiter">:</span> <span class="classifier">int &gt;= len(data) [scalar]</span></dt>
<dd><p class="first last">Length to pad <tt class="docutils literal"><span class="pre">data</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis along which to pad and center the data</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwargs</em></dt>
<dd><p class="first last">Additional keyword arguments passed to <tt class="docutils literal"><span class="pre">np.pad()</span></tt></p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>data_padded <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">data</span></tt> centered and padded to length <tt class="docutils literal"><span class="pre">size</span></tt> along the
specified axis</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">If <tt class="docutils literal"><span class="pre">size</span> <span class="pre">&lt;</span> <span class="pre">data.shape[axis]</span></tt></p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.util.fix_length">
<tt class="descclassname">librosa.util.</tt><tt class="descname">fix_length</tt><big>(</big><em>y</em>, <em>n</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.util.fix_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Fix the length of a one-dimensional array <tt class="docutils literal"><span class="pre">y</span></tt> to exactly <tt class="docutils literal"><span class="pre">n</span></tt>.</p>
<p>If <tt class="docutils literal"><span class="pre">len(y)</span> <span class="pre">&lt;</span> <span class="pre">n</span></tt>, pad according to the provided kwargs.
By default, <tt class="docutils literal"><span class="pre">y</span></tt> is padded with trailing zeros.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(m,)]</span></dt>
<dd><p class="first last">one-dimensional array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int &gt;= 0 [scalar]</span></dt>
<dd><p class="first last">desired length of the array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwargs</em></dt>
<dd><p class="first last">Additional keyword arguments.  See <tt class="docutils literal"><span class="pre">np.pad()</span></tt></p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(n,)]</span></dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">y</span></tt> either trimmed or padded to length <tt class="docutils literal"><span class="pre">n</span></tt></p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.util.axis_sort">
<tt class="descclassname">librosa.util.</tt><tt class="descname">axis_sort</tt><big>(</big><em>S</em>, <em>axis=-1</em>, <em>index=False</em>, <em>value=None</em><big>)</big><a class="headerlink" href="#librosa.util.axis_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort an array along its rows or columns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Visualize NMF output for a spectrogram S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Sort the columns of W by peak frequency bin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">decompose</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W_sort</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">axis_sort</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or sort by the lowest frequency bin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W_sort</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">axis_sort</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or sort the rows instead of the columns</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W_sort_rows</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">axis_sort</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Get the sorting index also, and use it to permute the rows of H</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W_sort</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">axis_sort</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H_sort</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># np.dot(W_sort, H_sort) == np.dot(W, H)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, n)]</span></dt>
<dd><p class="first last">Array to be sorted</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int [scalar]</span></dt>
<dd><p class="first">The axis along which to sort.</p>
<ul class="last simple">
<li><tt class="docutils literal"><span class="pre">axis=0</span></tt> to sort rows by peak column index</li>
<li><tt class="docutils literal"><span class="pre">axis=1</span></tt> to sort columns by peak row index</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>index <span class="classifier-delimiter">:</span> <span class="classifier">boolean [scalar]</span></dt>
<dd><p class="first last">If true, returns the index array as well as the permuted data.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>value <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">function to return the index corresponding to the sort order.
Default: <tt class="docutils literal"><span class="pre">np.argmax</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>S_sort <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, n)]</span></dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">S</span></tt> with the columns or rows permuted in sorting order</p>
</dd>
</dl>
</li>
<li><p class="first">idx : np.ndarray (optional) [shape=(d,) or (n,)]
If <tt class="docutils literal"><span class="pre">index</span> <span class="pre">==</span> <span class="pre">True</span></tt>, the sorting index used to permute <tt class="docutils literal"><span class="pre">S</span></tt>.
Length of <tt class="docutils literal"><span class="pre">idx</span></tt> corresponds to the selected <tt class="docutils literal"><span class="pre">axis</span></tt>.</p>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">If <tt class="docutils literal"><span class="pre">S</span></tt> does not have exactly 2 dimensions.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.util.normalize">
<tt class="descclassname">librosa.util.</tt><tt class="descname">normalize</tt><big>(</big><em>S</em>, <em>norm=inf</em>, <em>axis=0</em><big>)</big><a class="headerlink" href="#librosa.util.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize the columns or rows of a matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>S <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=(d, n)]</span></dt>
<dd><p class="first last">The matrix to normalize</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">{inf, -inf, 0, float &gt; 0}</span></dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">inf</span></tt>  : maximum absolute value</li>
<li><tt class="docutils literal"><span class="pre">-inf</span></tt> : mininum absolute value</li>
<li><tt class="docutils literal"><span class="pre">0</span></tt>    : number of non-zeros</li>
<li>float  : corresponding l_p norm.
See <tt class="docutils literal"><span class="pre">scipy.linalg.norm</span></tt> for details.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int [scalar]</span></dt>
<dd><p class="first last">Axis along which to compute the norm.
<tt class="docutils literal"><span class="pre">axis=0</span></tt> will normalize columns, <tt class="docutils literal"><span class="pre">axis=1</span></tt> will normalize rows.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>S_norm <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [shape=S.shape]</span></dt>
<dd><p class="first last">Normalized matrix</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Columns/rows with length 0 will be left as zeros.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="librosa.util.match_intervals">
<tt class="descclassname">librosa.util.</tt><tt class="descname">match_intervals</tt><big>(</big><em>intervals_from</em>, <em>intervals_to</em><big>)</big><a class="headerlink" href="#librosa.util.match_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Match one set of time intervals to another.</p>
<p>This can be useful for mapping beat timings to segments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>intervals_from <span class="classifier-delimiter">:</span> <span class="classifier">ndarray [shape=(n, 2)]</span></dt>
<dd><p class="first last">The time range for source intervals.
The <tt class="docutils literal"><span class="pre">i</span></tt> th interval spans time <tt class="docutils literal"><span class="pre">intervals_from[i,</span> <span class="pre">0]</span></tt>
to <tt class="docutils literal"><span class="pre">intervals_from[i,</span> <span class="pre">1]</span></tt>.
<tt class="docutils literal"><span class="pre">intervals_from[0,</span> <span class="pre">0]</span></tt> should be 0, <tt class="docutils literal"><span class="pre">intervals_from[-1,</span> <span class="pre">1]</span></tt>
should be the track duration.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>intervals_to <span class="classifier-delimiter">:</span> <span class="classifier">ndarray [shape=(m, 2)]</span></dt>
<dd><p class="first last">Analogous to <tt class="docutils literal"><span class="pre">intervals_from</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>interval_mapping <span class="classifier-delimiter">:</span> <span class="classifier">ndarray [shape=(n,)]</span></dt>
<dd><p class="first last">For each interval in <tt class="docutils literal"><span class="pre">intervals_from</span></tt>, the
corresponding interval in <tt class="docutils literal"><span class="pre">intervals_to</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.util.find_files">
<tt class="descclassname">librosa.util.</tt><tt class="descname">find_files</tt><big>(</big><em>directory</em>, <em>ext=None</em>, <em>recurse=True</em>, <em>case_sensitive=False</em>, <em>limit=None</em>, <em>offset=0</em><big>)</big><a class="headerlink" href="#librosa.util.find_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a sorted list of (audio) files in a directory or directory sub-tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Get all audio files in a directory sub-tree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">files</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_files</span><span class="p">(</span><span class="s">&#39;~/Music&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Look only within a specific directory, not the sub-tree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">files</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_files</span><span class="p">(</span><span class="s">&#39;~/Music&#39;</span><span class="p">,</span> <span class="n">recurse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Only look for mp3 files</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">files</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_files</span><span class="p">(</span><span class="s">&#39;~/Music&#39;</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s">&#39;mp3&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or just mp3 and ogg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">files</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_files</span><span class="p">(</span><span class="s">&#39;~/Music&#39;</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;mp3&#39;</span><span class="p">,</span> <span class="s">&#39;ogg&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Only get the first 10 files</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">files</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_files</span><span class="p">(</span><span class="s">&#39;~/Music&#39;</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Or last 10 files</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">files</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_files</span><span class="p">(</span><span class="s">&#39;~/Music&#39;</span><span class="p">,</span> <span class="n">offset</span><span class="o">=-</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>directory <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Path to look for files</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ext <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str</span></dt>
<dd><p class="first">A file extension or list of file extensions to include in the search.</p>
<p class="last">Default: <tt class="docutils literal"><span class="pre">['aac',</span> <span class="pre">'au',</span> <span class="pre">'flac',</span> <span class="pre">'m4a',</span> <span class="pre">'mp3',</span> <span class="pre">'ogg',</span> <span class="pre">'wav']</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>recurse <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first">If <tt class="docutils literal"><span class="pre">True</span></tt>, then all subfolders of <tt class="docutils literal"><span class="pre">directory</span></tt> will be searched.</p>
<p class="last">Otherwise, only <tt class="docutils literal"><span class="pre">directory</span></tt> will be searched.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>case_sensitive <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">If <tt class="docutils literal"><span class="pre">False</span></tt>, files matching upper-case version of
extensions will be included.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>limit <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0 or None</span></dt>
<dd><p class="first last">Return at most <tt class="docutils literal"><span class="pre">limit</span></tt> files. If <tt class="docutils literal"><span class="pre">None</span></tt>, all files are returned.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first">Return files starting at <tt class="docutils literal"><span class="pre">offset</span></tt> within the list.</p>
<p class="last">Use negative values to offset from the end of the list.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>files <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">The list of audio files.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="librosa.util.FeatureExtractor">
<em class="property">class </em><tt class="descclassname">librosa.util.</tt><tt class="descname">FeatureExtractor</tt><big>(</big><em>function</em>, <em>target=None</em>, <em>iterate=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.util.FeatureExtractor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">sklearn.base.BaseEstimator</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">sklearn.base.TransformerMixin</span></tt></p>
<p>Sci-kit learn wrapper class for feature extraction methods.</p>
<p>This class acts as a bridge between feature extraction functions
and scikit-learn pipelines.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">librosa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sklearn.pipeline</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Build a mel-spectrogram extractor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MS</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">FeatureExtractor</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">melspectrogram</span><span class="p">,</span>
<span class="go">                                       sr=22050, n_fft=2048,</span>
<span class="go">                                       n_mels=128, fmax=8000)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># And a log-amplitude extractor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LA</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">FeatureExtractor</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">logamplitude</span><span class="p">,</span>
<span class="go">                                       ref_power=np.max)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Chain them into a pipeline</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Features</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">Pipeline</span><span class="p">([(</span><span class="s">&#39;MelSpectrogram&#39;</span><span class="p">,</span> <span class="n">MS</span><span class="p">),</span>
<span class="go">                                          (&#39;LogAmplitude&#39;, LA)])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Load an audio file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;file.mp3&#39;</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Apply the transformation to y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">Features</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">y</span><span class="p">])</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>function <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first">The feature extraction function to wrap.</p>
<p class="last">Example: <tt class="docutils literal"><span class="pre">librosa.feature.melspectrogram</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span></dt>
<dd><p class="first">If <tt class="docutils literal"><span class="pre">None</span></tt>, then <tt class="docutils literal"><span class="pre">function</span></tt> is called with the input
data as the first positional argument.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">str</span></tt>, then <tt class="docutils literal"><span class="pre">function</span></tt> is called with the input
data as a keyword argument with key <tt class="docutils literal"><span class="pre">target</span></tt>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>iterate <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">If <tt class="docutils literal"><span class="pre">True</span></tt>, then <tt class="docutils literal"><span class="pre">function</span></tt> is applied iteratively to each
item of the input.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">False</span></tt>, then <tt class="docutils literal"><span class="pre">function</span></tt> is applied to the entire data
stream simultaneously.  This is useful for things like aggregation
and stacking.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>kwargs</em></dt>
<dd><p class="first last">Parameters to be passed through to <tt class="docutils literal"><span class="pre">function</span></tt></p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="librosa.util.FeatureExtractor.set_params">
<tt class="descname">set_params</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.util.FeatureExtractor.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the parameters of the feature extractor.</p>
</dd></dl>

<dl class="method">
<dt id="librosa.util.FeatureExtractor.fit">
<tt class="descname">fit</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#librosa.util.FeatureExtractor.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>This function does nothing, and is provided for interface compatibility.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Since most <tt class="docutils literal"><span class="pre">TransformerMixin</span></tt> classes implement some
statistical modeling (e.g., PCA), the <tt class="docutils literal"><span class="pre">fit()</span></tt> method is
required.</p>
<p class="last">For the <tt class="docutils literal"><span class="pre">FeatureExtraction</span></tt> class, all parameters are fixed
ahead of time, and no statistical estimation takes place.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="librosa.util.FeatureExtractor.transform">
<tt class="descname">transform</tt><big>(</big><em>X</em><big>)</big><a class="headerlink" href="#librosa.util.FeatureExtractor.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the feature transformation to an array of input data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>X <span class="classifier-delimiter">:</span> <span class="classifier">iterable</span></dt>
<dd><p class="first last">Array or list of input data</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>X_transform <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first">In positional argument mode (target=None), then
<tt class="docutils literal"><span class="pre">X_transform[i]</span> <span class="pre">=</span> <span class="pre">function(X[i],</span> <span class="pre">[feature</span> <span class="pre">parameters])</span></tt></p>
<p class="last">If the <tt class="docutils literal"><span class="pre">target</span></tt> parameter was given, then
<tt class="docutils literal"><span class="pre">X_transform[i]</span> <span class="pre">=</span> <span class="pre">function(target=X[i],</span> <span class="pre">[feature</span> <span class="pre">parameters])</span></tt></p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="librosa.util.buf_to_int">
<tt class="descclassname">librosa.util.</tt><tt class="descname">buf_to_int</tt><big>(</big><em>x</em>, <em>n_bytes=2</em><big>)</big><a class="headerlink" href="#librosa.util.buf_to_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a floating point buffer into integer values.
This is primarily useful as an intermediate step in wav output.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#librosa.util.buf_to_float" title="librosa.util.buf_to_float"><tt class="xref py py-func docutils literal"><span class="pre">librosa.util.buf_to_float()</span></tt></a></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [dtype=float]</span></dt>
<dd><p class="first last">Floating point data buffer</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_bytes <span class="classifier-delimiter">:</span> <span class="classifier">int [1, 2, 4]</span></dt>
<dd><p class="first last">Number of bytes per output sample</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>x_int <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [dtype=int]</span></dt>
<dd><p class="first last">The original buffer cast to integer type.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="librosa.util.buf_to_float">
<tt class="descclassname">librosa.util.</tt><tt class="descname">buf_to_float</tt><big>(</big><em>x</em>, <em>n_bytes=2</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em><big>)</big><a class="headerlink" href="#librosa.util.buf_to_float" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an integer buffer to floating point values.
This is primarily useful when loading integer-valued wav data
into numpy arrays.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#librosa.util.buf_to_float" title="librosa.util.buf_to_float"><tt class="xref py py-func docutils literal"><span class="pre">librosa.util.buf_to_float()</span></tt></a></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [dtype=int]</span></dt>
<dd><p class="first last">The integer-valued data buffer</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n_bytes <span class="classifier-delimiter">:</span> <span class="classifier">int [1, 2, 4]</span></dt>
<dd><p class="first last">The number of bytes per sample in <tt class="docutils literal"><span class="pre">x</span></tt></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">numeric type</span></dt>
<dd><p class="first last">The target output type (default: 32-bit float)</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>x_float <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray [dtype=float]</span></dt>
<dd><p class="first last">The input data buffer cast to floating point</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2014, Dawen Liang, Brian McFee, Matt McVicar, Colin Raffel.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>