

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>librosa.feature.spectral &mdash; librosa 0.5.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/banner.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> librosa
          

          
          </a>

          
            
            
              <div class="version">
                0.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core.html">Core IO and DSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../display.html">Display</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../feature.html">Feature extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../onset.html">Onset detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../beat.html">Beat and tempo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../decompose.html">Spectrogram decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../effects.html">Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../output.html">Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../segment.html">Temporal segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../util.html">Utilities</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../filters.html">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cache.html">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ioformats.html">Advanced I/O Use Cases</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">librosa</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>librosa.feature.spectral</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  


    
    



    <p class="scv-banner scv-sphinx_rtd_theme"><b>Warning:</b> This document is for an old version of librosa.</p>
<h1>Source code for librosa.feature.spectral</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Spectral feature extraction&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">filters</span>
<span class="kn">from</span> <span class="nn">..util.exceptions</span> <span class="k">import</span> <span class="n">ParameterError</span>
<span class="kn">from</span> <span class="nn">..util.deprecation</span> <span class="k">import</span> <span class="n">Deprecated</span><span class="p">,</span> <span class="n">rename_kw</span>

<span class="kn">from</span> <span class="nn">..core.time_frequency</span> <span class="k">import</span> <span class="n">fft_frequencies</span>
<span class="kn">from</span> <span class="nn">..core.audio</span> <span class="k">import</span> <span class="n">zero_crossings</span><span class="p">,</span> <span class="n">to_mono</span>
<span class="kn">from</span> <span class="nn">..core.spectrum</span> <span class="k">import</span> <span class="n">power_to_db</span><span class="p">,</span> <span class="n">_spectrogram</span>
<span class="kn">from</span> <span class="nn">..core.constantq</span> <span class="k">import</span> <span class="n">cqt</span><span class="p">,</span> <span class="n">hybrid_cqt</span>
<span class="kn">from</span> <span class="nn">..core.pitch</span> <span class="k">import</span> <span class="n">estimate_tuning</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;spectral_centroid&#39;</span><span class="p">,</span>
           <span class="s1">&#39;spectral_bandwidth&#39;</span><span class="p">,</span>
           <span class="s1">&#39;spectral_contrast&#39;</span><span class="p">,</span>
           <span class="s1">&#39;spectral_rolloff&#39;</span><span class="p">,</span>
           <span class="s1">&#39;poly_features&#39;</span><span class="p">,</span>
           <span class="s1">&#39;rmse&#39;</span><span class="p">,</span>
           <span class="s1">&#39;zero_crossing_rate&#39;</span><span class="p">,</span>
           <span class="s1">&#39;chroma_stft&#39;</span><span class="p">,</span>
           <span class="s1">&#39;chroma_cqt&#39;</span><span class="p">,</span>
           <span class="s1">&#39;chroma_cens&#39;</span><span class="p">,</span>
           <span class="s1">&#39;melspectrogram&#39;</span><span class="p">,</span>
           <span class="s1">&#39;mfcc&#39;</span><span class="p">,</span>
           <span class="s1">&#39;tonnetz&#39;</span><span class="p">]</span>


<span class="c1"># -- Spectral features -- #</span>
<div class="viewcode-block" id="spectral_centroid"><a class="viewcode-back" href="../../../generated/librosa.feature.spectral_centroid.html#librosa.feature.spectral_centroid">[docs]</a><span class="k">def</span> <span class="nf">spectral_centroid</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                      <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute the spectral centroid.</span>

<span class="sd">    Each frame of a magnitude spectrogram is normalized and treated as a</span>
<span class="sd">    distribution over frequency bins, from which the mean (centroid) is</span>
<span class="sd">    extracted per frame.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.core.stft` for details.</span>

<span class="sd">    freq : None or np.ndarray [shape=(d,) or shape=(d, t)]</span>
<span class="sd">        Center frequencies for spectrogram bins.</span>
<span class="sd">        If `None`, then FFT bin center frequencies are used.</span>
<span class="sd">        Otherwise, it can be a single array of `d` center frequencies,</span>
<span class="sd">        or a matrix of center frequencies as constructed by</span>
<span class="sd">        `librosa.core.ifgram`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    centroid : np.ndarray [shape=(1, t)]</span>
<span class="sd">        centroid frequencies</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.core.stft</span>
<span class="sd">        Short-time Fourier Transform</span>

<span class="sd">    librosa.core.ifgram</span>
<span class="sd">        Instantaneous-frequency spectrogram</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    From time-series input:</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; cent = librosa.feature.spectral_centroid(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; cent</span>
<span class="sd">    array([[ 4382.894,   626.588, ...,  5037.07 ,  5413.398]])</span>

<span class="sd">    From spectrogram input:</span>

<span class="sd">    &gt;&gt;&gt; S, phase = librosa.magphase(librosa.stft(y=y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_centroid(S=S)</span>
<span class="sd">    array([[ 4382.894,   626.588, ...,  5037.07 ,  5413.398]])</span>

<span class="sd">    Using variable bin center frequencies:</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; if_gram, D = librosa.ifgram(y)</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_centroid(S=np.abs(D), freq=if_gram)</span>
<span class="sd">    array([[ 4420.719,   625.769, ...,  5011.86 ,  5221.492]])</span>

<span class="sd">    Plot the result</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogy(cent.T, label=&#39;Spectral centroid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Hz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.xlim([0, cent.shape[-1]])</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;log Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Spectral centroid is only defined &#39;</span>
                             <span class="s1">&#39;with real-valued input&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">S</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Spectral centroid is only defined &#39;</span>
                             <span class="s1">&#39;with non-negative energies&#39;</span><span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Column-normalize S</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">freq</span> <span class="o">*</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                  <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="spectral_bandwidth"><a class="viewcode-back" href="../../../generated/librosa.feature.spectral_bandwidth.html#librosa.feature.spectral_bandwidth">[docs]</a><span class="k">def</span> <span class="nf">spectral_bandwidth</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                       <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">centroid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute p&#39;th-order spectral bandwidth:</span>

<span class="sd">        (sum_k S[k] * (freq[k] - centroid)**p)**(1/p)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.core.stft` for details.</span>

<span class="sd">    freq : None or np.ndarray [shape=(d,) or shape=(d, t)]</span>
<span class="sd">        Center frequencies for spectrogram bins.</span>
<span class="sd">        If `None`, then FFT bin center frequencies are used.</span>
<span class="sd">        Otherwise, it can be a single array of `d` center frequencies,</span>
<span class="sd">        or a matrix of center frequencies as constructed by</span>
<span class="sd">        `librosa.core.ifgram`</span>

<span class="sd">    centroid : None or np.ndarray [shape=(1, t)]</span>
<span class="sd">        pre-computed centroid frequencies</span>

<span class="sd">    norm : bool</span>
<span class="sd">        Normalize per-frame spectral energy (sum to one)</span>

<span class="sd">    p : float &gt; 0</span>
<span class="sd">        Power to raise deviation from spectral centroid.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bandwidth : np.ndarray [shape=(1, t)]</span>
<span class="sd">        frequency bandwidth for each frame</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    From time-series input</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; spec_bw = librosa.feature.spectral_bandwidth(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; spec_bw</span>
<span class="sd">    array([[ 3379.878,  1429.486, ...,  3235.214,  3080.148]])</span>

<span class="sd">    From spectrogram input</span>

<span class="sd">    &gt;&gt;&gt; S, phase = librosa.magphase(librosa.stft(y=y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_bandwidth(S=S)</span>
<span class="sd">    array([[ 3379.878,  1429.486, ...,  3235.214,  3080.148]])</span>

<span class="sd">    Using variable bin center frequencies</span>

<span class="sd">    &gt;&gt;&gt; if_gram, D = librosa.ifgram(y)</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_bandwidth(S=np.abs(D), freq=if_gram)</span>
<span class="sd">    array([[ 3380.011,  1429.11 , ...,  3235.22 ,  3080.148]])</span>

<span class="sd">    Plot the result</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogy(spec_bw.T, label=&#39;Spectral bandwidth&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Hz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.xlim([0, spec_bw.shape[-1]])</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;log Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Spectral bandwidth is only defined &#39;</span>
                             <span class="s1">&#39;with real-valued input&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">S</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Spectral bandwidth is only defined &#39;</span>
                             <span class="s1">&#39;with non-negative energies&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">centroid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">spectral_centroid</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
                                     <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
                                     <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                                     <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">freq</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Column-normalize S</span>
    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="n">deviation</span><span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="spectral_contrast"><a class="viewcode-back" href="../../../generated/librosa.feature.spectral_contrast.html#librosa.feature.spectral_contrast">[docs]</a><span class="k">def</span> <span class="nf">spectral_contrast</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                      <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="mf">200.0</span><span class="p">,</span> <span class="n">n_bands</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">quantile</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span>
                      <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute spectral contrast [1]_</span>

<span class="sd">    .. [1] Jiang, Dan-Ning, Lie Lu, Hong-Jiang Zhang, Jian-Hua Tao,</span>
<span class="sd">           and Lian-Hong Cai.</span>
<span class="sd">           &quot;Music type classification by spectral contrast feature.&quot;</span>
<span class="sd">           In Multimedia and Expo, 2002. ICME&#39;02. Proceedings.</span>
<span class="sd">           2002 IEEE International Conference on, vol. 1, pp. 113-116.</span>
<span class="sd">           IEEE, 2002.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number  &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.core.stft` for details.</span>

<span class="sd">    freq : None or np.ndarray [shape=(d,)]</span>
<span class="sd">        Center frequencies for spectrogram bins.</span>
<span class="sd">        If `None`, then FFT bin center frequencies are used.</span>
<span class="sd">        Otherwise, it can be a single array of `d` center frequencies.</span>

<span class="sd">    fmin : float &gt; 0</span>
<span class="sd">        Frequency cutoff for the first bin `[0, fmin]`</span>
<span class="sd">        Subsequent bins will cover `[fmin, 2*fmin]`, `[2*fmin, 4*fmin]`, etc.</span>

<span class="sd">    n_bands : int &gt; 1</span>
<span class="sd">        number of frequency bands</span>

<span class="sd">    quantile : float in (0, 1)</span>
<span class="sd">        quantile for determining peaks and valleys</span>

<span class="sd">    linear : bool</span>
<span class="sd">        If `True`, return the linear difference of magnitudes:</span>
<span class="sd">        `peaks - valleys`.</span>

<span class="sd">        If `False`, return the logarithmic difference:</span>
<span class="sd">        `log(peaks) - log(valleys)`.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    contrast : np.ndarray [shape=(n_bands + 1, t)]</span>
<span class="sd">        each row of spectral contrast values corresponds to a given</span>
<span class="sd">        octave-based frequency</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; contrast = librosa.feature.spectral_contrast(S=S, sr=sr)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S,</span>
<span class="sd">    ...                                                  ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(contrast, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Frequency bands&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Spectral contrast&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;freq.shape mismatch: expected &#39;</span>
                             <span class="s1">&#39;(</span><span class="si">{:d}</span><span class="s1">,)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">n_bands</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_bands</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;n_bands must be a positive integer&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">quantile</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;quantile must lie in the range (0, 1)&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fmin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;fmin must be a positive number&#39;</span><span class="p">)</span>

    <span class="n">octa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bands</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">octa</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">fmin</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_bands</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">octa</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sr</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Frequency band exceeds Nyquist. &#39;</span>
                             <span class="s1">&#39;Reduce either fmin or n_bands.&#39;</span><span class="p">)</span>

    <span class="n">valley</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_bands</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">peak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">valley</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">f_low</span><span class="p">,</span> <span class="n">f_high</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">octa</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">octa</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
        <span class="n">current_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freq</span> <span class="o">&gt;=</span> <span class="n">f_low</span><span class="p">,</span> <span class="n">freq</span> <span class="o">&lt;=</span> <span class="n">f_high</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">current_band</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">current_band</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">n_bands</span><span class="p">:</span>
            <span class="n">current_band</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">sub_band</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">current_band</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n_bands</span><span class="p">:</span>
            <span class="n">sub_band</span> <span class="o">=</span> <span class="n">sub_band</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Always take at least one bin from each side</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">quantile</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_band</span><span class="p">))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">sortedr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sub_band</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">valley</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sortedr</span><span class="p">[:</span><span class="n">idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">peak</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sortedr</span><span class="p">[</span><span class="o">-</span><span class="n">idx</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">linear</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">peak</span> <span class="o">-</span> <span class="n">valley</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span> <span class="o">-</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">valley</span><span class="p">)</span></div>


<div class="viewcode-block" id="spectral_rolloff"><a class="viewcode-back" href="../../../generated/librosa.feature.spectral_rolloff.html#librosa.feature.spectral_rolloff">[docs]</a><span class="k">def</span> <span class="nf">spectral_rolloff</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                     <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">roll_percent</span><span class="o">=</span><span class="mf">0.85</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute roll-off frequency</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.core.stft` for details.</span>

<span class="sd">    freq : None or np.ndarray [shape=(d,) or shape=(d, t)]</span>
<span class="sd">        Center frequencies for spectrogram bins.</span>
<span class="sd">        If `None`, then FFT bin center frequencies are used.</span>
<span class="sd">        Otherwise, it can be a single array of `d` center frequencies,</span>

<span class="sd">        .. note:: `freq` is assumed to be sorted in increasing order</span>

<span class="sd">    roll_percent : float [0 &lt; roll_percent &lt; 1]</span>
<span class="sd">        Roll-off percentage.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rolloff : np.ndarray [shape=(1, t)]</span>
<span class="sd">        roll-off frequency for each frame</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    From time-series input</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; rolloff = librosa.feature.spectral_rolloff(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; rolloff</span>
<span class="sd">    array([[ 8376.416,   968.994, ...,  8925.513,  9108.545]])</span>

<span class="sd">    From spectrogram input</span>

<span class="sd">    &gt;&gt;&gt; S, phase = librosa.magphase(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_rolloff(S=S, sr=sr)</span>
<span class="sd">    array([[ 8376.416,   968.994, ...,  8925.513,  9108.545]])</span>

<span class="sd">    &gt;&gt;&gt; # With a higher roll percentage:</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.spectral_rolloff(y=y, sr=sr, roll_percent=0.95)</span>
<span class="sd">    array([[ 10012.939,   3003.882, ...,  10034.473,  10077.539]])</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogy(rolloff.T, label=&#39;Roll-off frequency&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Hz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.xlim([0, rolloff.shape[-1]])</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;log Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">roll_percent</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;roll_percent must lie in the range (0, 1)&#39;</span><span class="p">)</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Spectral rolloff is only defined &#39;</span>
                             <span class="s1">&#39;with real-valued input&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">S</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Spectral rolloff is only defined &#39;</span>
                             <span class="s1">&#39;with non-negative energies&#39;</span><span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="c1"># Make sure that frequency can be broadcast</span>
    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">total_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="n">roll_percent</span> <span class="o">*</span> <span class="n">total_energy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">total_energy</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">ind</span> <span class="o">*</span> <span class="n">freq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="rmse"><a class="viewcode-back" href="../../../generated/librosa.feature.rmse.html#librosa.feature.rmse">[docs]</a><span class="k">def</span> <span class="nf">rmse</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">frame_length</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
         <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span>
         <span class="n">n_fft</span><span class="o">=</span><span class="n">Deprecated</span><span class="p">()):</span>
    <span class="sd">&#39;&#39;&#39;Compute root-mean-square (RMS) energy for each frame, either from the</span>
<span class="sd">    audio samples `y` or from a spectrogram `S`.</span>

<span class="sd">    Computing the energy from audio samples is faster as it doesn&#39;t require a</span>
<span class="sd">    STFT calculation. However, using a spectrogram will give a more accurate</span>
<span class="sd">    representation of energy over time because its frames can be windowed,</span>
<span class="sd">    thus prefer using `S` if it&#39;s already available.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        (optional) audio time series. Required if `S` is not input.</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude. Required if `y` is not input.</span>

<span class="sd">    frame_length : int &gt; 0 [scalar]</span>
<span class="sd">        length of analysis frame (in samples) for energy calculation</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.core.stft` for details.</span>

<span class="sd">    center : bool</span>
<span class="sd">        If `True` and operating on time-domain input (`y`), pad the signal</span>
<span class="sd">        by `frame_length//2` on either side.</span>

<span class="sd">        If operating on spectrogram input, this has no effect.</span>

<span class="sd">    pad_mode : str</span>
<span class="sd">        Padding mode for centered analysis.  See `np.pad` for valid</span>
<span class="sd">        values.</span>

<span class="sd">    n_fft : [DEPRECATED]</span>
<span class="sd">        .. warning:: This parameter name was deprecated in librosa 0.5.0</span>
<span class="sd">            Use the `frame_length` parameter instead.</span>
<span class="sd">            The `n_fft` parameter will be removed in librosa 0.6.0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rms : np.ndarray [shape=(1, t)]</span>
<span class="sd">        RMS value for each frame</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.rmse(y=y)</span>
<span class="sd">    array([[ 0.   ,  0.056, ...,  0.   ,  0.   ]], dtype=float32)</span>

<span class="sd">    Or from spectrogram input</span>

<span class="sd">    &gt;&gt;&gt; S, phase = librosa.magphase(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; rms = librosa.feature.rmse(S=S)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogy(rms.T, label=&#39;RMS Energy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.xlim([0, rms.shape[-1]])</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;log Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    Use a STFT window of constant ones and no frame centering to get consistent</span>
<span class="sd">    results with the RMS energy computed from the audio samples `y`</span>

<span class="sd">    &gt;&gt;&gt; S = librosa.magphase(librosa.stft(y, window=np.ones, center=False))[0]</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.rmse(S=S)</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">frame_length</span> <span class="o">=</span> <span class="n">rename_kw</span><span class="p">(</span><span class="s1">&#39;n_fft&#39;</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">,</span>
                             <span class="s1">&#39;frame_length&#39;</span><span class="p">,</span> <span class="n">frame_length</span><span class="p">,</span>
                             <span class="s1">&#39;0.5&#39;</span><span class="p">,</span> <span class="s1">&#39;0.6&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Either `y` or `S` should be input.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">to_mono</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">frame_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">frame</span><span class="p">(</span><span class="n">y</span><span class="p">,</span>
                       <span class="n">frame_length</span><span class="o">=</span><span class="n">frame_length</span><span class="p">,</span>
                       <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span>
                            <span class="n">n_fft</span><span class="o">=</span><span class="n">frame_length</span><span class="p">,</span>
                            <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Either `y` or `S` must be input.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>


<div class="viewcode-block" id="poly_features"><a class="viewcode-back" href="../../../generated/librosa.feature.poly_features.html#librosa.feature.poly_features">[docs]</a><span class="k">def</span> <span class="nf">poly_features</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                  <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Get coefficients of fitting an nth-order polynomial to the columns</span>
<span class="sd">    of a spectrogram.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        audio sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        (optional) spectrogram magnitude</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        FFT window size</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length for STFT. See `librosa.core.stft` for details.</span>

<span class="sd">    order : int &gt; 0</span>
<span class="sd">        order of the polynomial to fit</span>

<span class="sd">    freq : None or np.ndarray [shape=(d,) or shape=(d, t)]</span>
<span class="sd">        Center frequencies for spectrogram bins.</span>
<span class="sd">        If `None`, then FFT bin center frequencies are used.</span>
<span class="sd">        Otherwise, it can be a single array of `d` center frequencies,</span>
<span class="sd">        or a matrix of center frequencies as constructed by</span>
<span class="sd">        `librosa.core.ifgram`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coefficients : np.ndarray [shape=(order+1, t)]</span>
<span class="sd">        polynomial coefficients for each frame.</span>

<span class="sd">        `coeffecients[0]` corresponds to the highest degree (`order`),</span>

<span class="sd">        `coefficients[1]` corresponds to the next highest degree (`order-1`),</span>

<span class="sd">        down to the constant term `coefficients[order]`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>

<span class="sd">    Fit a degree-0 polynomial (constant) to each frame</span>

<span class="sd">    &gt;&gt;&gt; p0 = librosa.feature.poly_features(S=S, order=0)</span>

<span class="sd">    Fit a linear polynomial to each frame</span>

<span class="sd">    &gt;&gt;&gt; p1 = librosa.feature.poly_features(S=S, order=1)</span>

<span class="sd">    Fit a quadratic to each frame</span>

<span class="sd">    &gt;&gt;&gt; p2 = librosa.feature.poly_features(S=S, order=2)</span>

<span class="sd">    Plot the results for comparison</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(8, 8))</span>
<span class="sd">    &gt;&gt;&gt; ax = plt.subplot(4,1,1)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(p2[2], label=&#39;order=2&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(p1[1], label=&#39;order=1&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(p0[0], label=&#39;order=0&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Constant&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(4,1,2, sharex=ax)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(p2[1], label=&#39;order=2&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(p1[0], label=&#39;order=1&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Linear&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(4,1,3, sharex=ax)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(p2[0], label=&#39;order=2&#39;, alpha=0.8)</span>
<span class="sd">    &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Quadratic&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(4,1,4, sharex=ax)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.amplitude_to_db(S, ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">)</span>

    <span class="c1"># Compute the center frequencies of each bin</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">fft_frequencies</span><span class="p">(</span><span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

    <span class="c1"># If frequencies are constant over frames, then we only need to fit once</span>
    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Else, fit each frame independently and stack the results</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">freq</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">S</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">order</span><span class="p">)]</span>
                                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">coefficients</span></div>


<div class="viewcode-block" id="zero_crossing_rate"><a class="viewcode-back" href="../../../generated/librosa.feature.zero_crossing_rate.html#librosa.feature.zero_crossing_rate">[docs]</a><span class="k">def</span> <span class="nf">zero_crossing_rate</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">frame_length</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute the zero-crossing rate of an audio time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)]</span>
<span class="sd">        Audio time series</span>

<span class="sd">    frame_length : int &gt; 0</span>
<span class="sd">        Length of the frame over which to compute zero crossing rates</span>

<span class="sd">    hop_length : int &gt; 0</span>
<span class="sd">        Number of samples to advance for each frame</span>

<span class="sd">    center : bool</span>
<span class="sd">        If `True`, frames are centered by padding the edges of `y`.</span>
<span class="sd">        This is similar to the padding in `librosa.core.stft`,</span>
<span class="sd">        but uses edge-value copies instead of reflection.</span>

<span class="sd">    kwargs : additional keyword arguments</span>
<span class="sd">        See `librosa.core.zero_crossings`</span>

<span class="sd">        .. note:: By default, the `pad` parameter is set to `False`, which</span>
<span class="sd">            differs from the default specified by</span>
<span class="sd">            `librosa.core.zero_crossings`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    zcr : np.ndarray [shape=(1, t)]</span>
<span class="sd">        `zcr[0, i]` is the fraction of zero crossings in the</span>
<span class="sd">        `i` th frame</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.core.zero_crossings</span>
<span class="sd">        Compute zero-crossings in a time-series</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.zero_crossing_rate(y)</span>
<span class="sd">    array([[ 0.134,  0.139, ...,  0.387,  0.322]])</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">util</span><span class="o">.</span><span class="n">valid_audio</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">frame_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>

    <span class="n">y_framed</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">frame</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">frame_length</span><span class="p">,</span> <span class="n">hop_length</span><span class="p">)</span>

    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;pad&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="n">crossings</span> <span class="o">=</span> <span class="n">zero_crossings</span><span class="p">(</span><span class="n">y_framed</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">crossings</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<span class="c1"># -- Chroma --#</span>
<div class="viewcode-block" id="chroma_stft"><a class="viewcode-back" href="../../../generated/librosa.feature.chroma_stft.html#librosa.feature.chroma_stft">[docs]</a><span class="k">def</span> <span class="nf">chroma_stft</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
                <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">tuning</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute a chromagram from a waveform or power spectrogram.</span>

<span class="sd">    This implementation is derived from `chromagram_E` [1]_</span>

<span class="sd">    .. [1] Ellis, Daniel P.W.  &quot;Chroma feature analysis and synthesis&quot;</span>
<span class="sd">           2007/04/21</span>
<span class="sd">           http://labrosa.ee.columbia.edu/matlab/chroma-ansyn/</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        power spectrogram</span>

<span class="sd">    norm : float or None</span>
<span class="sd">        Column-wise normalization.</span>
<span class="sd">        See `librosa.util.normalize` for details.</span>

<span class="sd">        If `None`, no normalization is performed.</span>

<span class="sd">    n_fft : int  &gt; 0 [scalar]</span>
<span class="sd">        FFT window size if provided `y, sr` instead of `S`</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        hop length if provided `y, sr` instead of `S`</span>

<span class="sd">    tuning : float in `[-0.5, 0.5)` [scalar] or None.</span>
<span class="sd">        Deviation from A440 tuning in fractional bins (cents).</span>
<span class="sd">        If `None`, it is automatically estimated.</span>

<span class="sd">    kwargs : additional keyword arguments</span>
<span class="sd">        Arguments to parameterize chroma filters.</span>
<span class="sd">        See `librosa.filters.chroma` for details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    chromagram  : np.ndarray [shape=(n_chroma, t)]</span>
<span class="sd">        Normalized energy for each chroma bin at each frame.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.filters.chroma</span>
<span class="sd">        Chroma filter bank construction</span>
<span class="sd">    librosa.util.normalize</span>
<span class="sd">        Vector normalization</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.chroma_stft(y=y, sr=sr)</span>
<span class="sd">    array([[ 0.974,  0.881, ...,  0.925,  1.   ],</span>
<span class="sd">           [ 1.   ,  0.841, ...,  0.882,  0.878],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 0.658,  0.985, ...,  0.878,  0.764],</span>
<span class="sd">           [ 0.969,  0.92 , ...,  0.974,  0.915]])</span>

<span class="sd">    Use an energy (magnitude) spectrum instead of power spectrogram</span>

<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))</span>
<span class="sd">    &gt;&gt;&gt; chroma = librosa.feature.chroma_stft(S=S, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; chroma</span>
<span class="sd">    array([[ 0.884,  0.91 , ...,  0.861,  0.858],</span>
<span class="sd">           [ 0.963,  0.785, ...,  0.968,  0.896],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 0.871,  1.   , ...,  0.928,  0.829],</span>
<span class="sd">           [ 1.   ,  0.982, ...,  0.93 ,  0.878]])</span>

<span class="sd">    Use a pre-computed power spectrogram with a larger frame</span>

<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y, n_fft=4096))**2</span>
<span class="sd">    &gt;&gt;&gt; chroma = librosa.feature.chroma_stft(S=S, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; chroma</span>
<span class="sd">    array([[ 0.685,  0.477, ...,  0.961,  0.986],</span>
<span class="sd">           [ 0.674,  0.452, ...,  0.952,  0.926],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 0.844,  0.575, ...,  0.934,  0.869],</span>
<span class="sd">           [ 0.793,  0.663, ...,  0.964,  0.972]])</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(10, 4))</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma, y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Chromagram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                            <span class="n">power</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">n_chroma</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;n_chroma&#39;</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tuning</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tuning</span> <span class="o">=</span> <span class="n">estimate_tuning</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">n_chroma</span><span class="p">)</span>

    <span class="c1"># Get the filter bank</span>
    <span class="k">if</span> <span class="s1">&#39;A440&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;A440&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">440.0</span> <span class="o">*</span> <span class="mf">2.0</span><span class="o">**</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">tuning</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_chroma</span><span class="p">)</span>

    <span class="n">chromafb</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">chroma</span><span class="p">(</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Compute raw chroma</span>
    <span class="n">raw_chroma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">chromafb</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>

    <span class="c1"># Compute normalization factor for each frame</span>
    <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">raw_chroma</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="chroma_cqt"><a class="viewcode-back" href="../../../generated/librosa.feature.chroma_cqt.html#librosa.feature.chroma_cqt">[docs]</a><span class="k">def</span> <span class="nf">chroma_cqt</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">norm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">tuning</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_chroma</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
               <span class="n">n_octaves</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cqt_mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Constant-Q chromagram</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)]</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    C : np.ndarray [shape=(d, t)] [Optional]</span>
<span class="sd">        a pre-computed constant-Q spectrogram</span>

<span class="sd">    hop_length : int &gt; 0</span>
<span class="sd">        number of samples between successive chroma frames</span>

<span class="sd">    fmin : float &gt; 0</span>
<span class="sd">        minimum frequency to analyze in the CQT.</span>
<span class="sd">        Default: &#39;C1&#39; ~= 32.7 Hz</span>

<span class="sd">    norm : int &gt; 0, +-np.inf, or None</span>
<span class="sd">        Column-wise normalization of the chromagram.</span>

<span class="sd">    threshold : float</span>
<span class="sd">        Pre-normalization energy threshold.  Values below the</span>
<span class="sd">        threshold are discarded, resulting in a sparse chromagram.</span>

<span class="sd">    tuning : float</span>
<span class="sd">        Deviation (in cents) from A440 tuning</span>

<span class="sd">    n_chroma : int &gt; 0</span>
<span class="sd">        Number of chroma bins to produce</span>

<span class="sd">    n_octaves : int &gt; 0</span>
<span class="sd">        Number of octaves to analyze above `fmin`</span>

<span class="sd">    window : None or np.ndarray</span>
<span class="sd">        Optional window parameter to `filters.cq_to_chroma`</span>

<span class="sd">    bins_per_octave : int &gt; 0</span>
<span class="sd">        Number of bins per octave in the CQT.</span>
<span class="sd">        Default: matches `n_chroma`</span>

<span class="sd">    cqt_mode : [&#39;full&#39;, &#39;hybrid&#39;]</span>
<span class="sd">        Constant-Q transform mode</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    chromagram : np.ndarray [shape=(n_chroma, t)]</span>
<span class="sd">        The output chromagram</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.util.normalize</span>
<span class="sd">    librosa.core.cqt</span>
<span class="sd">    librosa.core.hybrid_cqt</span>
<span class="sd">    chroma_stft</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compare a long-window STFT chromagram to the CQT chromagram</span>


<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(),</span>
<span class="sd">    ...                      offset=10, duration=15)</span>
<span class="sd">    &gt;&gt;&gt; chroma_stft = librosa.feature.chroma_stft(y=y, sr=sr,</span>
<span class="sd">    ...                                           n_chroma=12, n_fft=4096)</span>
<span class="sd">    &gt;&gt;&gt; chroma_cq = librosa.feature.chroma_cqt(y=y, sr=sr)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma_stft, y_axis=&#39;chroma&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;chroma_stft&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma_cq, y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;chroma_cqt&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">cqt_func</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;full&#39;</span><span class="p">:</span> <span class="n">cqt</span><span class="p">,</span> <span class="s1">&#39;hybrid&#39;</span><span class="p">:</span> <span class="n">hybrid_cqt</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">bins_per_octave</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bins_per_octave</span> <span class="o">=</span> <span class="n">n_chroma</span>

    <span class="c1"># Build the CQT if we don&#39;t have one already</span>
    <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cqt_func</span><span class="p">[</span><span class="n">cqt_mode</span><span class="p">](</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
                                      <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                                      <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
                                      <span class="n">n_bins</span><span class="o">=</span><span class="n">n_octaves</span> <span class="o">*</span> <span class="n">bins_per_octave</span><span class="p">,</span>
                                      <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">bins_per_octave</span><span class="p">,</span>
                                      <span class="n">tuning</span><span class="o">=</span><span class="n">tuning</span><span class="p">))</span>

    <span class="c1"># Map to chroma</span>
    <span class="n">cq_to_chr</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">cq_to_chroma</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                     <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">bins_per_octave</span><span class="p">,</span>
                                     <span class="n">n_chroma</span><span class="o">=</span><span class="n">n_chroma</span><span class="p">,</span>
                                     <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
                                     <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
    <span class="n">chroma</span> <span class="o">=</span> <span class="n">cq_to_chr</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chroma</span><span class="p">[</span><span class="n">chroma</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># Normalize</span>
    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chroma</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">chroma</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">chroma</span></div>


<div class="viewcode-block" id="chroma_cens"><a class="viewcode-back" href="../../../generated/librosa.feature.chroma_cens.html#librosa.feature.chroma_cens">[docs]</a><span class="k">def</span> <span class="nf">chroma_cens</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">tuning</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_chroma</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
                <span class="n">n_octaves</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">bins_per_octave</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cqt_mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">norm</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">win_len_smooth</span><span class="o">=</span><span class="mi">41</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Computes the chroma variant &quot;Chroma Energy Normalized&quot; (CENS), following [1]_.</span>

<span class="sd">    .. [1] Meinard Mller and Sebastian Ewert</span>
<span class="sd">           Chroma Toolbox: MATLAB implementations for extracting variants of chroma-based audio features</span>
<span class="sd">           In Proceedings of the International Conference on Music Information Retrieval (ISMIR), 2011.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)]</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr : number &gt; 0</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    C : np.ndarray [shape=(d, t)] [Optional]</span>
<span class="sd">        a pre-computed constant-Q spectrogram</span>

<span class="sd">    hop_length : int &gt; 0</span>
<span class="sd">        number of samples between successive chroma frames</span>

<span class="sd">    fmin : float &gt; 0</span>
<span class="sd">        minimum frequency to analyze in the CQT.</span>
<span class="sd">        Default: &#39;C1&#39; ~= 32.7 Hz</span>

<span class="sd">    norm : int &gt; 0, +-np.inf, or None</span>
<span class="sd">        Column-wise normalization of the chromagram.</span>

<span class="sd">    tuning : float</span>
<span class="sd">        Deviation (in cents) from A440 tuning</span>

<span class="sd">    n_chroma : int &gt; 0</span>
<span class="sd">        Number of chroma bins to produce</span>

<span class="sd">    n_octaves : int &gt; 0</span>
<span class="sd">        Number of octaves to analyze above `fmin`</span>

<span class="sd">    window : None or np.ndarray</span>
<span class="sd">        Optional window parameter to `filters.cq_to_chroma`</span>

<span class="sd">    bins_per_octave : int &gt; 0</span>
<span class="sd">        Number of bins per octave in the CQT.</span>
<span class="sd">        Default: matches `n_chroma`</span>

<span class="sd">    cqt_mode : [&#39;full&#39;, &#39;hybrid&#39;]</span>
<span class="sd">        Constant-Q transform mode</span>

<span class="sd">    win_len_smooth : int &gt; 0</span>
<span class="sd">        Length of temporal smoothing window.</span>
<span class="sd">        Default: 41</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    chroma_cens : np.ndarray [shape=(n_chroma, t)]</span>
<span class="sd">        The output cens-chromagram</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    chroma_cqt</span>
<span class="sd">        Compute a chromagram from a constant-Q transform.</span>

<span class="sd">    chroma_stft</span>
<span class="sd">        Compute a chromagram from an STFT spectrogram or waveform.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compare standard cqt chroma to CENS.</span>


<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(),</span>
<span class="sd">    ...                      offset=10, duration=15)</span>
<span class="sd">    &gt;&gt;&gt; chroma_cens = librosa.feature.chroma_cens(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; chroma_cq = librosa.feature.chroma_cqt(y=y, sr=sr)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma_cq, y_axis=&#39;chroma&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;chroma_cq&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2,1,2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(chroma_cens, y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;chroma_cens&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">chroma</span> <span class="o">=</span> <span class="n">chroma_cqt</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span>
                        <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                        <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
                        <span class="n">bins_per_octave</span><span class="o">=</span><span class="n">bins_per_octave</span><span class="p">,</span>
                        <span class="n">tuning</span><span class="o">=</span><span class="n">tuning</span><span class="p">,</span>
                        <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">n_chroma</span><span class="o">=</span><span class="n">n_chroma</span><span class="p">,</span>
                        <span class="n">n_octaves</span><span class="o">=</span><span class="n">n_octaves</span><span class="p">,</span>
                        <span class="n">cqt_mode</span><span class="o">=</span><span class="n">cqt_mode</span><span class="p">,</span>
                        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>

    <span class="c1"># L1-Normalization</span>
    <span class="n">chroma</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">chroma</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Quantize amplitudes</span>
    <span class="n">QUANT_STEPS</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">]</span>
    <span class="n">QUANT_WEIGHTS</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">]</span>

    <span class="n">chroma_quant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">chroma</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">cur_quant_step_idx</span><span class="p">,</span> <span class="n">cur_quant_step</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">QUANT_STEPS</span><span class="p">):</span>
        <span class="n">chroma_quant</span> <span class="o">+=</span> <span class="p">(</span><span class="n">chroma</span> <span class="o">&gt;</span> <span class="n">cur_quant_step</span><span class="p">)</span> <span class="o">*</span> <span class="n">QUANT_WEIGHTS</span><span class="p">[</span><span class="n">cur_quant_step_idx</span><span class="p">]</span>

    <span class="c1"># Apply temporal smoothing</span>
    <span class="n">win</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">win_len_smooth</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">win</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>
    <span class="n">win</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>

    <span class="n">cens</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">chroma_quant</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span>
                                   <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;fill&#39;</span><span class="p">)</span>

    <span class="c1"># L2-Normalization</span>
    <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">cens</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="tonnetz"><a class="viewcode-back" href="../../../generated/librosa.feature.tonnetz.html#librosa.feature.tonnetz">[docs]</a><span class="k">def</span> <span class="nf">tonnetz</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">chroma</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Computes the tonal centroid features (tonnetz), following the method of</span>
<span class="sd">    [1]_.</span>

<span class="sd">    .. [1] Harte, C., Sandler, M., &amp; Gasser, M. (2006). &quot;Detecting Harmonic</span>
<span class="sd">           Change in Musical Audio.&quot; In Proceedings of the 1st ACM Workshop</span>
<span class="sd">           on Audio and Music Computing Multimedia (pp. 21-26).</span>
<span class="sd">           Santa Barbara, CA, USA: ACM Press. doi:10.1145/1178723.1178727.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        Audio time series.</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    chroma : np.ndarray [shape=(n_chroma, t)] or None</span>
<span class="sd">        Normalized energy for each chroma bin at each frame.</span>

<span class="sd">        If `None`, a cqt chromagram is performed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tonnetz : np.ndarray [shape(6, t)]</span>
<span class="sd">        Tonal centroid features for each frame.</span>

<span class="sd">        Tonnetz dimensions:</span>
<span class="sd">            - 0: Fifth x-axis</span>
<span class="sd">            - 1: Fifth y-axis</span>
<span class="sd">            - 2: Minor x-axis</span>
<span class="sd">            - 3: Minor y-axis</span>
<span class="sd">            - 4: Major x-axis</span>
<span class="sd">            - 5: Major y-axis</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    chroma_cqt</span>
<span class="sd">        Compute a chromagram from a constant-Q transform.</span>

<span class="sd">    chroma_stft</span>
<span class="sd">        Compute a chromagram from an STFT spectrogram or waveform.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute tonnetz features from the harmonic component of a song</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; y = librosa.effects.harmonic(y)</span>
<span class="sd">    &gt;&gt;&gt; tonnetz = librosa.feature.tonnetz(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; tonnetz</span>
<span class="sd">    array([[-0.073, -0.053, ..., -0.054, -0.073],</span>
<span class="sd">           [ 0.001,  0.001, ..., -0.054, -0.062],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 0.039,  0.034, ...,  0.044,  0.064],</span>
<span class="sd">           [ 0.005,  0.002, ...,  0.011,  0.017]])</span>

<span class="sd">    Compare the tonnetz features to `chroma_cqt`</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(tonnetz, y_axis=&#39;tonnetz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Tonal Centroids (Tonnetz)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.feature.chroma_cqt(y, sr=sr),</span>
<span class="sd">    ...                          y_axis=&#39;chroma&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Chroma&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">chroma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Either the audio samples or the chromagram must be &#39;</span>
                             <span class="s1">&#39;passed as an argument.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">chroma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chroma</span> <span class="o">=</span> <span class="n">chroma_cqt</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>

    <span class="c1"># Generate Transformation matrix</span>
    <span class="n">dim_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">chroma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">7.</span> <span class="o">/</span> <span class="mi">6</span><span class="p">,</span> <span class="mf">7.</span> <span class="o">/</span> <span class="mi">6</span><span class="p">,</span>
                        <span class="mf">3.</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                        <span class="mf">2.</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">2.</span> <span class="o">/</span> <span class="mi">3</span><span class="p">])</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">dim_map</span><span class="p">)</span>

    <span class="c1"># Even rows compute sin()</span>
    <span class="n">V</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>         <span class="c1"># Fifths</span>
                  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>         <span class="c1"># Minor</span>
                  <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>    <span class="c1"># Major</span>

    <span class="n">phi</span> <span class="o">=</span> <span class="n">R</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">V</span><span class="p">)</span>

    <span class="c1"># Do the transform to tonnetz</span>
    <span class="k">return</span> <span class="n">phi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">chroma</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span></div>


<span class="c1"># -- Mel spectrogram and MFCCs -- #</span>
<div class="viewcode-block" id="mfcc"><a class="viewcode-back" href="../../../generated/librosa.feature.mfcc.html#librosa.feature.mfcc">[docs]</a><span class="k">def</span> <span class="nf">mfcc</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_mfcc</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mel-frequency cepstral coefficients</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y     : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        audio time series</span>

<span class="sd">    sr    : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    S     : np.ndarray [shape=(d, t)] or None</span>
<span class="sd">        log-power Mel spectrogram</span>

<span class="sd">    n_mfcc: int &gt; 0 [scalar]</span>
<span class="sd">        number of MFCCs to return</span>

<span class="sd">    kwargs : additional keyword arguments</span>
<span class="sd">        Arguments to `melspectrogram`, if operating</span>
<span class="sd">        on time series input</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    M     : np.ndarray [shape=(n_mfcc, t)]</span>
<span class="sd">        MFCC sequence</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    melspectrogram</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Generate mfccs from a time series</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.mfcc(y=y, sr=sr)</span>
<span class="sd">    array([[ -5.229e+02,  -4.944e+02, ...,  -5.229e+02,  -5.229e+02],</span>
<span class="sd">           [  7.105e-15,   3.787e+01, ...,  -7.105e-15,  -7.105e-15],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  1.066e-14,  -7.500e+00, ...,   1.421e-14,   1.421e-14],</span>
<span class="sd">           [  3.109e-14,  -5.058e+00, ...,   2.931e-14,   2.931e-14]])</span>

<span class="sd">    Use a pre-computed log-power Mel spectrogram</span>

<span class="sd">    &gt;&gt;&gt; S = librosa.feature.melspectrogram(y=y, sr=sr, n_mels=128,</span>
<span class="sd">    ...                                    fmax=8000)</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.mfcc(S=librosa.power_to_db(S))</span>
<span class="sd">    array([[ -5.207e+02,  -4.898e+02, ...,  -5.207e+02,  -5.207e+02],</span>
<span class="sd">           [ -2.576e-14,   4.054e+01, ...,  -3.997e-14,  -3.997e-14],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  7.105e-15,  -3.534e+00, ...,   0.000e+00,   0.000e+00],</span>
<span class="sd">           [  3.020e-14,  -2.613e+00, ...,   3.553e-14,   3.553e-14]])</span>

<span class="sd">    Get more components</span>

<span class="sd">    &gt;&gt;&gt; mfccs = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=40)</span>

<span class="sd">    Visualize the MFCC series</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(10, 4))</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(mfccs, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;MFCC&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">power_to_db</span><span class="p">(</span><span class="n">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">filters</span><span class="o">.</span><span class="n">dct</span><span class="p">(</span><span class="n">n_mfcc</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">S</span><span class="p">)</span></div>


<div class="viewcode-block" id="melspectrogram"><a class="viewcode-back" href="../../../generated/librosa.feature.melspectrogram.html#librosa.feature.melspectrogram">[docs]</a><span class="k">def</span> <span class="nf">melspectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                   <span class="n">power</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute a mel-scaled spectrogram.</span>

<span class="sd">    If a spectrogram input `S` is provided, then it is mapped directly onto</span>
<span class="sd">    the mel basis `mel_f` by `mel_f.dot(S)`.</span>

<span class="sd">    If a time-series input `y, sr` is provided, then its magnitude spectrogram</span>
<span class="sd">    `S` is first computed, and then mapped onto the mel scale by</span>
<span class="sd">    `mel_f.dot(S**power)`.  By default, `power=2` operates on a power spectrum.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : np.ndarray [shape=(n,)] or None</span>
<span class="sd">        audio time-series</span>

<span class="sd">    sr : number &gt; 0 [scalar]</span>
<span class="sd">        sampling rate of `y`</span>

<span class="sd">    S : np.ndarray [shape=(d, t)]</span>
<span class="sd">        spectrogram</span>

<span class="sd">    n_fft : int &gt; 0 [scalar]</span>
<span class="sd">        length of the FFT window</span>

<span class="sd">    hop_length : int &gt; 0 [scalar]</span>
<span class="sd">        number of samples between successive frames.</span>
<span class="sd">        See `librosa.core.stft`</span>

<span class="sd">    power : float &gt; 0 [scalar]</span>
<span class="sd">        Exponent for the magnitude melspectrogram.</span>
<span class="sd">        e.g., 1 for energy, 2 for power, etc.</span>

<span class="sd">    kwargs : additional keyword arguments</span>
<span class="sd">      Mel filter bank parameters.</span>
<span class="sd">      See `librosa.filters.mel` for details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : np.ndarray [shape=(n_mels, t)]</span>
<span class="sd">        Mel spectrogram</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    librosa.filters.mel</span>
<span class="sd">        Mel filter bank construction</span>

<span class="sd">    librosa.core.stft</span>
<span class="sd">        Short-time Fourier Transform</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; librosa.feature.melspectrogram(y=y, sr=sr)</span>
<span class="sd">    array([[  2.891e-07,   2.548e-03, ...,   8.116e-09,   5.633e-09],</span>
<span class="sd">           [  1.986e-07,   1.162e-02, ...,   9.332e-08,   6.716e-09],</span>
<span class="sd">           ...,</span>
<span class="sd">           [  3.668e-09,   2.029e-08, ...,   3.208e-09,   2.864e-09],</span>
<span class="sd">           [  2.561e-10,   2.096e-09, ...,   7.543e-10,   6.101e-10]])</span>

<span class="sd">    Using a pre-computed power spectrogram</span>

<span class="sd">    &gt;&gt;&gt; D = np.abs(librosa.stft(y))**2</span>
<span class="sd">    &gt;&gt;&gt; S = librosa.feature.melspectrogram(S=D)</span>

<span class="sd">    &gt;&gt;&gt; # Passing through arguments to the Mel filters</span>
<span class="sd">    &gt;&gt;&gt; S = librosa.feature.melspectrogram(y=y, sr=sr, n_mels=128,</span>
<span class="sd">    ...                                     fmax=8000)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(10, 4))</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.power_to_db(S,</span>
<span class="sd">    ...                                              ref=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;mel&#39;, fmax=8000,</span>
<span class="sd">    ...                          x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar(format=&#39;%+2.0f dB&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Mel spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span> <span class="o">=</span> <span class="n">_spectrogram</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_length</span><span class="p">,</span>
                            <span class="n">power</span><span class="o">=</span><span class="n">power</span><span class="p">)</span>

    <span class="c1"># Build a Mel filter</span>
    <span class="n">mel_basis</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">mel</span><span class="p">(</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mel_basis</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2013--2017, librosa development team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
        <span class="fa fa-book"> Other Versions</span>
        v: 0.5.1
        <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
        <dl>
            <dt>Tags</dt>
            <dd><a href="../../../../0.4.1/index.html">0.4.1</a></dd>
            <dd><a href="../../../../0.4.2/index.html">0.4.2</a></dd>
            <dd><a href="../../../../0.4.3/index.html">0.4.3</a></dd>
            <dd><a href="../../../../0.5.0/index.html">0.5.0</a></dd>
            <dd><a href="spectral.html">0.5.1</a></dd>
            <dd><a href="../../../../0.6.0/index.html">0.6.0</a></dd>
            <dd><a href="../../../../0.6.1/index.html">0.6.1</a></dd>
            <dd><a href="../../../../v0.1.0/index.html">v0.1.0</a></dd>
            <dd><a href="../../../../v0.4.0/index.html">v0.4.0</a></dd>
        </dl>
        <dl>
            <dt>Branches</dt>
            <dd><a href="../../../../master/index.html">master</a></dd>
        </dl>
    </div>
</div>


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.5.1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>