

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>librosa.segment &mdash; librosa 0.4.3 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/banner.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="librosa 0.4.3 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> librosa
          

          
          </a>

          
            
            
              <div class="version">
                0.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../core.html">Core IO and DSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../display.html">Display</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../feature.html">Feature extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../onset.html">Onset detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../beat.html">Beat and tempo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../decompose.html">Spectrogram decomposition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../effects.html">Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../output.html">Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../segment.html">Temporal segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../util.html">Utilities</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filters.html">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cache.html">Caching</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">librosa</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>librosa.segment</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for librosa.segment</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Temporal segmentation</span>
<span class="sd">=====================</span>

<span class="sd">Recurrence and self-similarity</span>
<span class="sd">------------------------------</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    recurrence_matrix</span>
<span class="sd">    recurrence_to_lag</span>
<span class="sd">    lag_to_recurrence</span>
<span class="sd">    timelag_filter</span>

<span class="sd">Temporal clustering</span>
<span class="sd">-------------------</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    agglomerative</span>
<span class="sd">    subsegment</span>

<span class="sd">Deprecated</span>
<span class="sd">----------</span>
<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    structure_feature</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">decorator</span> <span class="k">import</span> <span class="n">decorator</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span>

<span class="kn">import</span> <span class="nn">sklearn</span>
<span class="kn">import</span> <span class="nn">sklearn.cluster</span>
<span class="kn">import</span> <span class="nn">sklearn.feature_extraction</span>
<span class="kn">import</span> <span class="nn">sklearn.neighbors</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">.util.exceptions</span> <span class="k">import</span> <span class="n">ParameterError</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;recurrence_matrix&#39;</span><span class="p">,</span>
           <span class="s1">&#39;recurrence_to_lag&#39;</span><span class="p">,</span>
           <span class="s1">&#39;lag_to_recurrence&#39;</span><span class="p">,</span>
           <span class="s1">&#39;timelag_filter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;agglomerative&#39;</span><span class="p">,</span>
           <span class="s1">&#39;subsegment&#39;</span><span class="p">,</span>
           <span class="c1"># Deprecated functions</span>
           <span class="s1">&#39;structure_feature&#39;</span><span class="p">]</span>


<span class="nd">@cache</span>
<div class="viewcode-block" id="recurrence_matrix"><a class="viewcode-back" href="../../generated/librosa.segment.recurrence_matrix.html#librosa.segment.recurrence_matrix">[docs]</a><span class="k">def</span> <span class="nf">recurrence_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span>
                      <span class="n">sym</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;connectivity&#39;</span><span class="p">,</span>
                      <span class="n">bandwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute a recurrence matrix from a data matrix.</span>


<span class="sd">    `rec[i, j]` is non-zero if (`data[:, i]`, `data[:, j]`) are</span>
<span class="sd">    k-nearest-neighbors and `|i - j| &gt;= width`</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        A feature matrix</span>

<span class="sd">    k : int &gt; 0 [scalar] or None</span>
<span class="sd">        the number of nearest-neighbors for each sample</span>

<span class="sd">        Default: `k = 2 * ceil(sqrt(t - 2 * width + 1))`,</span>
<span class="sd">        or `k = 2` if `t &lt;= 2 * width + 1`</span>

<span class="sd">    width : int &gt;= 1 [scalar]</span>
<span class="sd">        only link neighbors `(data[:, i], data[:, j])`</span>
<span class="sd">        if `|i - j| &gt;= width`</span>

<span class="sd">    metric : str</span>
<span class="sd">        Distance metric to use for nearest-neighbor calculation.</span>

<span class="sd">        See `sklearn.neighbors.NearestNeighbors` for details.</span>

<span class="sd">    sym : bool [scalar]</span>
<span class="sd">        set `sym=True` to only link mutual nearest-neighbors</span>

<span class="sd">    sparse : bool [scalar]</span>
<span class="sd">        if False, returns a dense type (ndarray)</span>
<span class="sd">        if True, returns a sparse type (scipy.sparse.csr_matrix)</span>

<span class="sd">    mode : str, {&#39;connectivity&#39;, &#39;distance&#39;, &#39;affinity&#39;}</span>
<span class="sd">        If &#39;connectivity&#39;, a binary connectivity matrix is produced.</span>

<span class="sd">        If &#39;distance&#39;, then a non-zero entry contains the distance between</span>
<span class="sd">        points.</span>

<span class="sd">        If &#39;adjacency&#39;, then non-zero entries are mapped to</span>
<span class="sd">        `exp( - distance(i, j) / bandwidth)` where `bandwidth` is</span>
<span class="sd">        as specified below.</span>

<span class="sd">    bandwidth : None or float &gt; 0</span>
<span class="sd">        If using ``mode=&#39;affinity&#39;``, this can be used to set the</span>
<span class="sd">        bandwidth on the affinity kernel.</span>

<span class="sd">        If no value is provided, it is set automatically to the median</span>
<span class="sd">        distance between furthest nearest neighbors.</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to compute recurrence.</span>
<span class="sd">        By default, the last index (-1) is taken.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rec : np.ndarray or scipy.sparse.csr_matrix, [shape=(t, t)]</span>
<span class="sd">        Recurrence matrix</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sklearn.neighbors.NearestNeighbors</span>
<span class="sd">    scipy.spatial.distance.cdist</span>
<span class="sd">    librosa.feature.stack_memory</span>
<span class="sd">    recurrence_to_lag</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Find nearest neighbors in MFCC space</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; mfcc = librosa.feature.mfcc(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; R = librosa.segment.recurrence_matrix(mfcc)</span>

<span class="sd">    Or fix the number of nearest neighbors to 5</span>

<span class="sd">    &gt;&gt;&gt; R = librosa.segment.recurrence_matrix(mfcc, k=5)</span>

<span class="sd">    Suppress neighbors within +- 7 samples</span>

<span class="sd">    &gt;&gt;&gt; R = librosa.segment.recurrence_matrix(mfcc, width=7)</span>

<span class="sd">    Use cosine similarity instead of Euclidean distance</span>

<span class="sd">    &gt;&gt;&gt; R = librosa.segment.recurrence_matrix(mfcc, metric=&#39;cosine&#39;)</span>

<span class="sd">    Require mutual nearest neighbors</span>

<span class="sd">    &gt;&gt;&gt; R = librosa.segment.recurrence_matrix(mfcc, sym=True)</span>

<span class="sd">    Use an affinity matrix instead of binary connectivity</span>

<span class="sd">    &gt;&gt;&gt; R_aff = librosa.segment.recurrence_matrix(mfcc, mode=&#39;affinity&#39;)</span>

<span class="sd">    Plot the feature and recurrence matrices</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(8, 4))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(R, x_axis=&#39;time&#39;, y_axis=&#39;time&#39;,</span>
<span class="sd">    ...                          aspect=&#39;equal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Binary recurrence (symmetric)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(R_aff, x_axis=&#39;time&#39;, y_axis=&#39;time&#39;,</span>
<span class="sd">    ...                          aspect=&#39;equal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Affinity recurrence&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># Swap observations to the first dimension and flatten the rest</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">width</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;width must be at least 1&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;connectivity&#39;</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="s1">&#39;affinity&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">((</span><span class="s2">&quot;Invalid mode=&#39;</span><span class="si">{}</span><span class="s2">&#39;. Must be one of &quot;</span>
                              <span class="s2">&quot;[&#39;connectivity&#39;, &#39;distance&#39;, &quot;</span>
                              <span class="s2">&quot;&#39;affinity&#39;]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">bandwidth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bandwidth</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid bandwidth=</span><span class="si">{}</span><span class="s1">. &#39;</span>
                                 <span class="s1">&#39;Must be strictly positive.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">))</span>

    <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="c1"># Build the neighbor search object</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">knn</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">neighbors</span><span class="o">.</span><span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">width</span><span class="p">),</span>
                                                 <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                                                 <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">knn</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">neighbors</span><span class="o">.</span><span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">width</span><span class="p">),</span>
                                                 <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                                                 <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;brute&#39;</span><span class="p">)</span>

    <span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># Get the knn graph</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;affinity&#39;</span><span class="p">:</span>
        <span class="n">kng_mode</span> <span class="o">=</span> <span class="s1">&#39;distance&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kng_mode</span> <span class="o">=</span> <span class="n">mode</span>

    <span class="n">rec</span> <span class="o">=</span> <span class="n">knn</span><span class="o">.</span><span class="n">kneighbors_graph</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">kng_mode</span><span class="p">)</span><span class="o">.</span><span class="n">tolil</span><span class="p">()</span>

    <span class="c1"># Remove connections within width</span>
    <span class="k">for</span> <span class="n">diag</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
        <span class="n">rec</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">diag</span><span class="p">)</span>

    <span class="c1"># Retain only the top-k links per point</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="c1"># Get the links from point i</span>
        <span class="n">links</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Order them ascending</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">links</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">rec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">links</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">())][</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Everything past the kth closest gets squashed</span>
        <span class="n">rec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="n">k</span><span class="p">:]]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># symmetrize</span>
    <span class="k">if</span> <span class="n">sym</span><span class="p">:</span>
        <span class="n">rec</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">rec</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
    <span class="n">rec</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;connectivity&#39;</span><span class="p">:</span>
        <span class="n">rec</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;affinity&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bandwidth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bandwidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">rec</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">rec</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="n">bandwidth</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">sparse</span><span class="p">:</span>
        <span class="n">rec</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">rec</span></div>


<div class="viewcode-block" id="recurrence_to_lag"><a class="viewcode-back" href="../../generated/librosa.segment.recurrence_to_lag.html#librosa.segment.recurrence_to_lag">[docs]</a><span class="k">def</span> <span class="nf">recurrence_to_lag</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Convert a recurrence matrix into a lag matrix.</span>

<span class="sd">        `lag[i, j] == rec[i+j, j]`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rec : np.ndarray, or scipy.sparse.spmatrix [shape=(n, n)]</span>
<span class="sd">        A (binary) recurrence matrix, as returned by `recurrence_matrix`</span>

<span class="sd">    pad : bool</span>
<span class="sd">        If False, `lag` matrix is square, which is equivalent to</span>
<span class="sd">        assuming that the signal repeats itself indefinitely.</span>

<span class="sd">        If True, `lag` is padded with `n` zeros, which eliminates</span>
<span class="sd">        the assumption of repetition.</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis to keep as the `time` axis.</span>
<span class="sd">        The alternate axis will be converted to lag coordinates.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lag : np.ndarray</span>
<span class="sd">        The recurrence matrix in (lag, time) (if `axis=1`)</span>
<span class="sd">        or (time, lag) (if `axis=0`) coordinates</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError : if `rec` is non-square</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    recurrence_matrix</span>
<span class="sd">    lag_to_recurrence</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; mfccs = librosa.feature.mfcc(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; recurrence = librosa.segment.recurrence_matrix(mfccs)</span>
<span class="sd">    &gt;&gt;&gt; lag_pad = librosa.segment.recurrence_to_lag(recurrence, pad=True)</span>
<span class="sd">    &gt;&gt;&gt; lag_nopad = librosa.segment.recurrence_to_lag(recurrence, pad=False)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(8, 4))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(lag_pad, x_axis=&#39;time&#39;, y_axis=&#39;lag&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Lag (zero-padded)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(lag_nopad, x_axis=&#39;time&#39;, y_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Lag (no padding)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rec</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;non-square recurrence matrix shape: &#39;</span>
                             <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="n">sparse</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>

    <span class="n">roll_ax</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
        <span class="n">roll_ax</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">axis</span>
        <span class="n">lag_format</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">format</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rec</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">rec</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pad</span><span class="p">:</span>
            <span class="n">kron</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">lag</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">kron</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">rec</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;lil&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lag</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pad</span><span class="p">:</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
            <span class="n">padding</span><span class="p">[(</span><span class="mi">1</span><span class="o">-</span><span class="n">axis</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">lag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lag</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">idx_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">lag</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">idx_slice</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">lag</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx_slice</span><span class="p">)]</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">roll_sparse</span><span class="p">(</span><span class="n">lag</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx_slice</span><span class="p">)],</span> <span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">roll_ax</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lag</span><span class="o">.</span><span class="n">asformat</span><span class="p">(</span><span class="n">lag_format</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">lag</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="lag_to_recurrence"><a class="viewcode-back" href="../../generated/librosa.segment.lag_to_recurrence.html#librosa.segment.lag_to_recurrence">[docs]</a><span class="k">def</span> <span class="nf">lag_to_recurrence</span><span class="p">(</span><span class="n">lag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Convert a lag matrix into a recurrence matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lag : np.ndarray or scipy.sparse.spmatrix</span>
<span class="sd">        A lag matrix, as produced by `recurrence_to_lag`</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis corresponding to the time dimension.</span>
<span class="sd">        The alternate axis will be interpreted in lag coordinates.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rec : np.ndarray or scipy.sparse.spmatrix [shape=(n, n)]</span>
<span class="sd">        A recurrence matrix in (time, time) coordinates</span>
<span class="sd">        For sparse matrices, format will match that of `lag`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ParameterError : if `lag` does not have the correct shape</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    recurrence_to_lag</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; mfccs = librosa.feature.mfcc(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; recurrence = librosa.segment.recurrence_matrix(mfccs)</span>
<span class="sd">    &gt;&gt;&gt; lag_pad = librosa.segment.recurrence_to_lag(recurrence, pad=True)</span>
<span class="sd">    &gt;&gt;&gt; lag_nopad = librosa.segment.recurrence_to_lag(recurrence, pad=False)</span>
<span class="sd">    &gt;&gt;&gt; rec_pad = librosa.segment.lag_to_recurrence(lag_pad)</span>
<span class="sd">    &gt;&gt;&gt; rec_nopad = librosa.segment.lag_to_recurrence(lag_nopad)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(8, 4))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 2, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(lag_pad, x_axis=&#39;time&#39;, y_axis=&#39;lag&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Lag (zero-padded)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(lag_nopad, x_axis=&#39;time&#39;, y_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Lag (no padding)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 2, 3)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(rec_pad, x_axis=&#39;time&#39;, y_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Recurrence (with padding)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 2, 4)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(rec_nopad, x_axis=&#39;time&#39;, y_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Recurrence (without padding)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid target axis: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>

    <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lag</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="p">(</span><span class="n">lag</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">lag</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span>
                         <span class="n">lag</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lag</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;Invalid lag matrix shape: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lag</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># Since lag must be 2-dimensional, abs(axis) = axis</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">lag</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="n">sparse</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">lag</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
        <span class="n">rec</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">lag</span><span class="p">)</span>
        <span class="n">roll_ax</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">axis</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rec</span> <span class="o">=</span> <span class="n">lag</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">roll_ax</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">idx_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">lag</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">idx_slice</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">rec</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx_slice</span><span class="p">)]</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">roll_sparse</span><span class="p">(</span><span class="n">lag</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx_slice</span><span class="p">)],</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">roll_ax</span><span class="p">)</span>

    <span class="n">sub_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">rec</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">sub_slice</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">rec</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sub_slice</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rec</span><span class="o">.</span><span class="n">asformat</span><span class="p">(</span><span class="n">lag</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="timelag_filter"><a class="viewcode-back" href="../../generated/librosa.segment.timelag_filter.html#librosa.segment.timelag_filter">[docs]</a><span class="k">def</span> <span class="nf">timelag_filter</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Filtering in the time-lag domain.</span>

<span class="sd">    This is primarily useful for adapting image filters to operate on</span>
<span class="sd">    `structure_feature` output.</span>

<span class="sd">    Using `timelag_filter` is equivalent to the following sequence of</span>
<span class="sd">    operations:</span>

<span class="sd">    &gt;&gt;&gt; data_tl = librosa.segment.recurrence_to_lag(data)</span>
<span class="sd">    &gt;&gt;&gt; data_filtered_tl = function(data_tl)</span>
<span class="sd">    &gt;&gt;&gt; data_filtered = librosa.segment.lag_to_recurrence(data_filtered_tl)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    function : callable</span>
<span class="sd">        The filtering function to wrap, e.g., `scipy.ndimage.median_filter`</span>

<span class="sd">    pad : bool</span>
<span class="sd">        Whether to zero-pad the structure feature matrix</span>

<span class="sd">    index : int &gt;= 0</span>
<span class="sd">        If `function` accepts input data as a positional argument, it should be</span>
<span class="sd">        indexed by `index`</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    wrapped_function : callable</span>
<span class="sd">        A new filter function which applies in time-lag space rather than</span>
<span class="sd">        time-time space.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    structure_feature</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Apply a 5-bin median filter to the diagonal of a recurrence matrix</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; mfcc = librosa.feature.mfcc(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; rec = librosa.segment.recurrence_matrix(mfcc, sym=True)</span>
<span class="sd">    &gt;&gt;&gt; from scipy.ndimage import median_filter</span>
<span class="sd">    &gt;&gt;&gt; diagonal_median = librosa.segment.timelag_filter(median_filter)</span>
<span class="sd">    &gt;&gt;&gt; rec_filtered = diagonal_median(rec, size=(1, 5), mode=&#39;mirror&#39;)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(rec, x_axis=&#39;time&#39;, y_axis=&#39;time&#39;,</span>
<span class="sd">    ...                          aspect=&#39;equal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Raw recurrence matrix&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(rec_filtered, x_axis=&#39;time&#39;, y_axis=&#39;time&#39;,</span>
<span class="sd">    ...                          aspect=&#39;equal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Filtered recurrence matrix&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="nd">@cache</span>
    <span class="k">def</span> <span class="nf">__my_filter</span><span class="p">(</span><span class="n">wrapped_f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Decorator to wrap the filter&#39;&#39;&#39;</span>
        <span class="c1"># Map the input data into time-lag space</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="n">args</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">recurrence_to_lag</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">)</span>

        <span class="c1"># Apply the filtering function</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">wrapped_f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Map back into time-time and return</span>
        <span class="k">return</span> <span class="n">lag_to_recurrence</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">decorator</span><span class="p">(</span><span class="n">__my_filter</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span></div>


<span class="nd">@cache</span>
<div class="viewcode-block" id="subsegment"><a class="viewcode-back" href="../../generated/librosa.segment.subsegment.html#librosa.segment.subsegment">[docs]</a><span class="k">def</span> <span class="nf">subsegment</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">frames</span><span class="p">,</span> <span class="n">n_segments</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Sub-divide a segmentation by feature clustering.</span>

<span class="sd">    Given a set of frame boundaries (`frames`), and a data matrix (`data`),</span>
<span class="sd">    each successive interval defined by `frames` is partitioned into</span>
<span class="sd">    `n_segments` by constrained agglomerative clustering.</span>

<span class="sd">    .. note::</span>
<span class="sd">        If an interval spans fewer than `n_segments` frames, then each</span>
<span class="sd">        frame becomes a sub-segment.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        Data matrix to use in clustering</span>

<span class="sd">    frames : np.ndarray [shape=(n_boundaries,)], dtype=int, non-negative]</span>
<span class="sd">        Array of beat or segment boundaries, as provided by</span>
<span class="sd">        `librosa.beat.beat_track`,</span>
<span class="sd">        `librosa.onset.onset_detect`,</span>
<span class="sd">        or `agglomerative`.</span>

<span class="sd">    n_segments : int &gt; 0</span>
<span class="sd">        Maximum number of frames to sub-divide each interval.</span>

<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to apply the segmentation.</span>
<span class="sd">        By default, the last index (-1) is taken.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    boundaries : np.ndarray [shape=(n_subboundaries,)]</span>
<span class="sd">        List of sub-divided segment boundaries</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    agglomerative : Temporal segmentation</span>
<span class="sd">    librosa.onset.onset_detect : Onset detection</span>
<span class="sd">    librosa.beat.beat_track : Beat tracking</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Load audio, detect beat frames, and subdivide in twos by CQT</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(), duration=15)</span>
<span class="sd">    &gt;&gt;&gt; tempo, beats = librosa.beat.beat_track(y=y, sr=sr, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; cqt = librosa.cqt(y, sr=sr, hop_length=512)</span>
<span class="sd">    &gt;&gt;&gt; subseg = librosa.segment.subsegment(cqt, beats, n_segments=2)</span>
<span class="sd">    &gt;&gt;&gt; subseg</span>
<span class="sd">    array([  0,   2,   4,  21,  23,  26,  43,  55,  63,  72,  83,</span>
<span class="sd">            97, 102, 111, 122, 137, 142, 153, 162, 180, 182, 185,</span>
<span class="sd">           202, 210, 221, 231, 241, 256, 261, 271, 281, 296, 301,</span>
<span class="sd">           310, 320, 339, 341, 344, 361, 368, 382, 389, 401, 416,</span>
<span class="sd">           420, 430, 436, 451, 456, 465, 476, 489, 496, 503, 515,</span>
<span class="sd">           527, 535, 544, 553, 558, 571, 578, 590, 607, 609, 638])</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.logamplitude(cqt**2,</span>
<span class="sd">    ...                                               ref_power=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;cqt_hz&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.vlines(beats, 0, cqt.shape[0], color=&#39;r&#39;, alpha=0.5,</span>
<span class="sd">    ...            label=&#39;Beats&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.vlines(subseg, 0, cqt.shape[0], color=&#39;b&#39;, linestyle=&#39;--&#39;,</span>
<span class="sd">    ...            alpha=0.5, label=&#39;Sub-beats&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True, shadow=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;CQT + Beat and sub-beat markers&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">frames</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">fix_frames</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_segments</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span><span class="s1">&#39;n_segments must be a positive integer&#39;</span><span class="p">)</span>

    <span class="n">boundaries</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">idx_slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">for</span> <span class="n">seg_start</span><span class="p">,</span> <span class="n">seg_end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">frames</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">idx_slices</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">seg_start</span><span class="p">,</span> <span class="n">seg_end</span><span class="p">)</span>
        <span class="n">boundaries</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">seg_start</span> <span class="o">+</span> <span class="n">agglomerative</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">idx_slices</span><span class="p">],</span>
                                                    <span class="nb">min</span><span class="p">(</span><span class="n">seg_end</span> <span class="o">-</span> <span class="n">seg_start</span><span class="p">,</span> <span class="n">n_segments</span><span class="p">),</span>
                                                    <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)</span></div>


<div class="viewcode-block" id="agglomerative"><a class="viewcode-back" href="../../generated/librosa.segment.agglomerative.html#librosa.segment.agglomerative">[docs]</a><span class="k">def</span> <span class="nf">agglomerative</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">clusterer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bottom-up temporal segmentation.</span>

<span class="sd">    Use a temporally-constrained agglomerative clustering routine to partition</span>
<span class="sd">    `data` into `k` contiguous segments.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data     : np.ndarray</span>
<span class="sd">        data to cluster</span>

<span class="sd">    k        : int &gt; 0 [scalar]</span>
<span class="sd">        number of segments to produce</span>

<span class="sd">    clusterer : sklearn.cluster.AgglomerativeClustering, optional</span>
<span class="sd">        An optional AgglomerativeClustering object.</span>
<span class="sd">        If `None`, a constrained Ward object is instantiated.</span>

<span class="sd">    axis : int</span>
<span class="sd">        axis along which to cluster.</span>
<span class="sd">        By default, the last axis (-1) is chosen.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    boundaries : np.ndarray [shape=(k,)]</span>
<span class="sd">        left-boundaries (frame numbers) of detected segments. This</span>
<span class="sd">        will always include `0` as the first left-boundary.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sklearn.cluster.AgglomerativeClustering</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Cluster by chroma similarity, break into 20 segments</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file(), duration=15)</span>
<span class="sd">    &gt;&gt;&gt; chroma = librosa.feature.chroma_cqt(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; boundary_frames = librosa.segment.agglomerative(chroma, 20)</span>
<span class="sd">    &gt;&gt;&gt; librosa.frames_to_time(boundary_frames, sr=sr)</span>
<span class="sd">    array([  0.   ,   1.672,   2.322,   2.624,   3.251,   3.506,</span>
<span class="sd">             4.18 ,   5.387,   6.014,   6.293,   6.943,   7.198,</span>
<span class="sd">             7.848,   9.033,   9.706,   9.961,  10.635,  10.89 ,</span>
<span class="sd">            11.54 ,  12.539])</span>

<span class="sd">    Plot the segmentation against the spectrogram</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; S = np.abs(librosa.stft(y))**2</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(librosa.logamplitude(S, ref_power=np.max),</span>
<span class="sd">    ...                          y_axis=&#39;log&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.vlines(boundary_frames, 0, S.shape[0], color=&#39;r&#39;, alpha=0.9,</span>
<span class="sd">    ...            label=&#39;Segment boundaries&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(frameon=True, shadow=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Power spectrogram&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Make sure we have at least two dimensions</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># Swap data index to position 0</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Flatten the features</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">clusterer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Connect the temporal connectivity graph</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">feature_extraction</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">grid_to_graph</span><span class="p">(</span><span class="n">n_x</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                                                              <span class="n">n_y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_z</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Instantiate the clustering object</span>
        <span class="n">clusterer</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">AgglomerativeClustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
                                                            <span class="n">connectivity</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span>
                                                            <span class="n">memory</span><span class="o">=</span><span class="n">cache</span><span class="p">)</span>

    <span class="c1"># Fit the model</span>
    <span class="n">clusterer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># Find the change points from the labels</span>
    <span class="n">boundaries</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">boundaries</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">clusterer</span><span class="o">.</span><span class="n">labels_</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)</span></div>


<span class="c1"># Deprecated functions</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">decorators</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;0.4&#39;</span><span class="p">,</span> <span class="s1">&#39;0.5&#39;</span><span class="p">)</span>
<span class="nd">@cache</span>
<div class="viewcode-block" id="structure_feature"><a class="viewcode-back" href="../../generated/librosa.segment.structure_feature.html#librosa.segment.structure_feature">[docs]</a><span class="k">def</span> <span class="nf">structure_feature</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Compute the structure feature from a recurrence matrix.</span>

<span class="sd">    The i&#39;th column of the recurrence matrix is shifted up by i.</span>
<span class="sd">    The resulting matrix is indexed horizontally by time,</span>
<span class="sd">    and vertically by lag.</span>

<span class="sd">    .. warning:: Deprected in librosa 0.4</span>
<span class="sd">                 Functionality is superseded by</span>
<span class="sd">                 `librosa.segment.recurrence_to_lag` and</span>
<span class="sd">                 `librosa.segment.lag_to_recurrence`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rec   : np.ndarray [shape=(t,t) or shape=(2*t, t)]</span>
<span class="sd">        recurrence matrix or pre-computed structure feature</span>

<span class="sd">    pad : bool [scalar]</span>
<span class="sd">        Pad the matrix with `t` rows of zeros to avoid looping.</span>

<span class="sd">    inverse : bool [scalar]</span>
<span class="sd">        Unroll the opposite direction. This is useful for converting</span>
<span class="sd">        structure features back into recurrence plots.</span>

<span class="sd">        .. note: Reversing with `pad==True` will truncate the</span>
<span class="sd">            inferred padding.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    struct : np.ndarray [shape=(2*t, t) or shape=(t, t)]</span>
<span class="sd">        `struct[i, t]` = the recurrence at time `t` with lag `i`.</span>

<span class="sd">        .. note:: negative lag values are supported by wrapping to the</span>
<span class="sd">            end of the array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    recurrence_matrix : build a recurrence matrix from feature vectors</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Build the structure feature over mfcc similarity</span>

<span class="sd">    &gt;&gt;&gt; y, sr = librosa.load(librosa.util.example_audio_file())</span>
<span class="sd">    &gt;&gt;&gt; mfccs = librosa.feature.mfcc(y=y, sr=sr)</span>
<span class="sd">    &gt;&gt;&gt; recurrence = librosa.segment.recurrence_matrix(mfccs)</span>
<span class="sd">    &gt;&gt;&gt; struct = librosa.segment.structure_feature(recurrence)</span>


<span class="sd">    Invert the structure feature to get a recurrence matrix</span>

<span class="sd">    &gt;&gt;&gt; recurrence_2 = librosa.segment.structure_feature(struct,</span>
<span class="sd">    ...                                                  inverse=True)</span>

<span class="sd">    Display recurrence in time-time and time-lag space</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(10, 5))</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 1)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(recurrence, aspect=&#39;equal&#39;, x_axis=&#39;time&#39;,</span>
<span class="sd">    ...                          y_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Recurrence (time-time)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(1, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; librosa.display.specshow(struct, aspect=&#39;auto&#39;, x_axis=&#39;time&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Lag&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Structure feature&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lag_to_recurrence</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">recurrence_to_lag</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">)</span></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, librosa development team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
        <span class="fa fa-book"> Other Versions</span>
        v: 0.4.3
        <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
        <dl>
            <dt>Tags</dt>
            <dd><a href="../../../0.4.0rc1/index.html">0.4.0rc1</a></dd>
            <dd><a href="../../../0.4.0rc2/index.html">0.4.0rc2</a></dd>
            <dd><a href="../../../0.4.1/index.html">0.4.1</a></dd>
            <dd><a href="../../../0.4.1rc0/index.html">0.4.1rc0</a></dd>
            <dd><a href="../../../0.4.2/index.html">0.4.2</a></dd>
            <dd><a href="segment.html">0.4.3</a></dd>
            <dd><a href="../../../0.4.3rc0/index.html">0.4.3rc0</a></dd>
            <dd><a href="../../../0.5.0/index.html">0.5.0</a></dd>
            <dd><a href="../../../0.5.0rc0/index.html">0.5.0rc0</a></dd>
            <dd><a href="../../../0.5.1/index.html">0.5.1</a></dd>
            <dd><a href="../../../0.6.0/index.html">0.6.0</a></dd>
            <dd><a href="../../../0.6.0rc0/index.html">0.6.0rc0</a></dd>
            <dd><a href="../../../0.6.0rc1/index.html">0.6.0rc1</a></dd>
            <dd><a href="../../../v0.1.0/index.html">v0.1.0</a></dd>
            <dd><a href="../../../v0.4.0/index.html">v0.4.0</a></dd>
        </dl>
        <dl>
            <dt>Branches</dt>
            <dd><a href="../../../display-bin-centering/index.html">display-bin-centering</a></dd>
            <dd><a href="../../../master/index.html">master</a></dd>
        </dl>
    </div>
</div>


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.4.3',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>